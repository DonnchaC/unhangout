/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(1);\nmodule.exports = __webpack_require__(5);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi editor\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_editor?");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/scss/editor.scss\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./static/scss/editor.scss?");

/***/ },
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\n__webpack_require__(6);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/js/editor/index.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./static/js/editor/index.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar prosemirror = __webpack_require__(7);\n__webpack_require__(59);\n//require(\"prosemirror/dist/menu/tooltipmenu\");\n\n/** http://youmightnotneedjquery.com/#ready */\nfunction ready(fn) {\n  if (document.readyState !== 'loading') {\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', fn);\n  }\n};\n\nvar replaceTextarea = function replaceTextarea(textarea) {\n  textarea.style.display = \"none\";\n  var container = document.createElement(\"div\");\n  container.className = textarea.className + \" rich-text-editor\";\n  textarea.parentNode.insertBefore(container, textarea);\n\n  var editor = new prosemirror.ProseMirror({\n    place: container,\n    menuBar: true,\n    //tooltipMenu: true,\n    doc: textarea.value,\n    docFormat: \"html\"\n  });\n  editor.on(\"change\", function () {\n    return textarea.value = editor.getContent(\"html\");\n  });\n};\nvar replaceAllTextareas = function replaceAllTextareas() {\n  ready(function () {\n    var els = document.querySelectorAll(\".js-rich-text-editor\");\n    for (var i = 0; i < els.length; i++) {\n      replaceTextarea(els[i]);\n    }\n  });\n};\nreplaceAllTextareas();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/js/editor/prosemirror.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./static/js/editor/prosemirror.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Keymap = exports.baseCommands = exports.Command = exports.CommandSet = exports.MarkedRange = exports.NodeSelection = exports.TextSelection = exports.Selection = exports.defineOption = exports.ProseMirror = undefined;\n\nvar _main = __webpack_require__(8);\n\nObject.defineProperty(exports, \"ProseMirror\", {\n  enumerable: true,\n  get: function get() {\n    return _main.ProseMirror;\n  }\n});\n\nvar _options = __webpack_require__(35);\n\nObject.defineProperty(exports, \"defineOption\", {\n  enumerable: true,\n  get: function get() {\n    return _options.defineOption;\n  }\n});\n\nvar _selection = __webpack_require__(49);\n\nObject.defineProperty(exports, \"Selection\", {\n  enumerable: true,\n  get: function get() {\n    return _selection.Selection;\n  }\n});\nObject.defineProperty(exports, \"TextSelection\", {\n  enumerable: true,\n  get: function get() {\n    return _selection.TextSelection;\n  }\n});\nObject.defineProperty(exports, \"NodeSelection\", {\n  enumerable: true,\n  get: function get() {\n    return _selection.NodeSelection;\n  }\n});\n\nvar _range = __webpack_require__(56);\n\nObject.defineProperty(exports, \"MarkedRange\", {\n  enumerable: true,\n  get: function get() {\n    return _range.MarkedRange;\n  }\n});\n\nvar _command = __webpack_require__(37);\n\nObject.defineProperty(exports, \"CommandSet\", {\n  enumerable: true,\n  get: function get() {\n    return _command.CommandSet;\n  }\n});\nObject.defineProperty(exports, \"Command\", {\n  enumerable: true,\n  get: function get() {\n    return _command.Command;\n  }\n});\n\nvar _base_commands = __webpack_require__(47);\n\nObject.defineProperty(exports, \"baseCommands\", {\n  enumerable: true,\n  get: function get() {\n    return _base_commands.baseCommands;\n  }\n});\n\n__webpack_require__(58);\n\nvar _browserkeymap = __webpack_require__(11);\n\nvar _browserkeymap2 = _interopRequireDefault(_browserkeymap);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Keymap = _browserkeymap2.default;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/index.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/index.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DIRTY_REDRAW = exports.DIRTY_RESCAN = exports.ProseMirror = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(9);\n\nvar _browserkeymap = __webpack_require__(11);\n\nvar _browserkeymap2 = _interopRequireDefault(_browserkeymap);\n\nvar _sortedinsert = __webpack_require__(12);\n\nvar _sortedinsert2 = _interopRequireDefault(_sortedinsert);\n\nvar _map = __webpack_require__(13);\n\nvar _event = __webpack_require__(14);\n\nvar _dom = __webpack_require__(10);\n\nvar _format = __webpack_require__(15);\n\nvar _options = __webpack_require__(35);\n\nvar _selection = __webpack_require__(49);\n\nvar _dompos = __webpack_require__(50);\n\nvar _draw = __webpack_require__(51);\n\nvar _input = __webpack_require__(52);\n\nvar _history = __webpack_require__(55);\n\nvar _range = __webpack_require__(56);\n\nvar _transform = __webpack_require__(57);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; This is the class used to represent instances of the editor. A\n// ProseMirror editor holds a [document](#Node) and a\n// [selection](#Selection), and displays an editable surface\n// representing that document in the browser document.\n//\n// Contains event methods (`on`, etc) from the [event\n// mixin](#EventMixin).\n\nvar ProseMirror = exports.ProseMirror = function () {\n  // :: (Object)\n  // Construct a new editor from a set of [options](#edit_options)\n  // and, if it has a [`place`](#place) option, add it to the\n  // document.\n\n  function ProseMirror(opts) {\n    _classCallCheck(this, ProseMirror);\n\n    (0, _dom.ensureCSSAdded)();\n\n    opts = this.options = (0, _options.parseOptions)(opts);\n    // :: Schema\n    // The schema for this editor's document.\n    this.schema = opts.schema;\n    if (opts.doc == null) opts.doc = this.schema.node(\"doc\", null, [this.schema.node(\"paragraph\")]);\n    // :: DOMNode\n    // The editable DOM node containing the document.\n    this.content = (0, _dom.elt)(\"div\", { class: \"ProseMirror-content\", \"pm-container\": true });\n    // :: DOMNode\n    // The outer DOM element of the editor.\n    this.wrapper = (0, _dom.elt)(\"div\", { class: \"ProseMirror\" }, this.content);\n    this.wrapper.ProseMirror = this;\n\n    if (opts.place && opts.place.appendChild) opts.place.appendChild(this.wrapper);else if (opts.place) opts.place(this.wrapper);\n\n    this.setDocInner(opts.docFormat ? (0, _format.parseFrom)(this.schema, opts.doc, opts.docFormat) : opts.doc);\n    (0, _draw.draw)(this, this.doc);\n    this.content.contentEditable = true;\n    if (opts.label) this.content.setAttribute(\"aria-label\", opts.label);\n\n    // :: Object\n    // A namespace where modules can store references to themselves\n    // associated with this editor instance.\n    this.mod = Object.create(null);\n    this.cached = Object.create(null);\n    this.operation = null;\n    this.dirtyNodes = new _map.Map(); // Maps node object to 1 (re-scan content) or 2 (redraw entirely)\n    this.flushScheduled = null;\n\n    this.sel = new _selection.SelectionState(this, (0, _selection.findSelectionAtStart)(this.doc));\n    this.accurateSelection = false;\n    this.input = new _input.Input(this);\n\n    // :: Object<Command>\n    // The commands available in the editor.\n    this.commands = null;\n    this.commandKeys = null;\n    (0, _options.initOptions)(this);\n  }\n\n  // :: (string, any)\n  // Update the value of the given [option](#edit_options).\n\n\n  _createClass(ProseMirror, [{\n    key: \"setOption\",\n    value: function setOption(name, value) {\n      (0, _options.setOption)(this, name, value);\n      // :: (name: string, value: *) #path=ProseMirror#events#optionChanged\n      // Fired when [`setOption`](#ProseMirror.setOption) is called.\n      this.signal(\"optionChanged\", name, value);\n    }\n\n    // :: (string) → any\n    // Get the current value of the given [option](#edit_options).\n\n  }, {\n    key: \"getOption\",\n    value: function getOption(name) {\n      return this.options[name];\n    }\n\n    // :: Selection\n    // Get the current selection.\n\n  }, {\n    key: \"setTextSelection\",\n\n\n    // :: (number, ?number)\n    // Set the selection to a [text selection](#TextSelection) from\n    // `anchor` to `head`, or, if `head` is null, a cursor selection at\n    // `anchor`.\n    value: function setTextSelection(anchor) {\n      var head = arguments.length <= 1 || arguments[1] === undefined ? anchor : arguments[1];\n\n      this.checkPos(head, true);\n      if (anchor != head) this.checkPos(anchor, true);\n      this.setSelection(new _selection.TextSelection(anchor, head));\n    }\n\n    // :: (number)\n    // Set the selection to a node selection on the node after `pos`.\n\n  }, {\n    key: \"setNodeSelection\",\n    value: function setNodeSelection(pos) {\n      this.checkPos(pos, false);\n      var node = this.doc.nodeAt(pos);\n      if (!node) throw new RangeError(\"Trying to set a node selection that doesn't point at a node\");\n      if (!node.type.selectable) throw new RangeError(\"Trying to select a non-selectable node\");\n      this.setSelection(new _selection.NodeSelection(pos, pos + node.nodeSize, node));\n    }\n\n    // :: (Selection)\n    // Set the selection to the given selection object.\n\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      this.ensureOperation();\n      if (!selection.eq(this.sel.range)) this.sel.setAndSignal(selection);\n    }\n\n    // :: (any, ?string)\n    // Replace the editor's document. When `format` is given, it should\n    // be a [parsable format](#format), and `value` should something in\n    // that format. If not, `value` should be a `Node`.\n\n  }, {\n    key: \"setContent\",\n    value: function setContent(value, format) {\n      if (format) value = (0, _format.parseFrom)(this.schema, value, format);\n      this.setDoc(value);\n    }\n\n    // :: (?string, ?Object) → any\n    // Get the editor's content in a given format. When `format` is not\n    // given, a `Node` is returned. If it is given, it should be an\n    // existing [serialization format](#format). Options to the serializer\n    // may be given as a second argument.\n\n  }, {\n    key: \"getContent\",\n    value: function getContent(format, options) {\n      return format ? (0, _format.serializeTo)(this.doc, format, options || {}) : this.doc;\n    }\n  }, {\n    key: \"setDocInner\",\n    value: function setDocInner(doc) {\n      if (doc.type != this.schema.nodes.doc) throw new RangeError(\"Trying to set a document with a different schema\");\n      // :: Node The current document.\n      this.doc = doc;\n      this.ranges = new _range.RangeStore(this);\n      // :: History The edit history for the editor.\n      this.history = new _history.History(this);\n    }\n\n    // :: (Node, ?Selection)\n    // Set the editor's content, and optionally include a new selection.\n\n  }, {\n    key: \"setDoc\",\n    value: function setDoc(doc, sel) {\n      if (!sel) sel = (0, _selection.findSelectionAtStart)(doc);\n      // :: (doc: Node, selection: Selection) #path=ProseMirror#events#beforeSetDoc\n      // Fired when [`setDoc`](#ProseMirror.setDoc) is called, before\n      // the document is actually updated.\n      this.signal(\"beforeSetDoc\", doc, sel);\n      this.ensureOperation();\n      this.setDocInner(doc);\n      this.operation.docSet = true;\n      this.sel.set(sel, true);\n      // :: (doc: Node, selection: Selection) #path=ProseMirror#events#setDoc\n      // Fired when [`setDoc`](#ProseMirror.setDoc) is called, after\n      // the document is updated.\n      this.signal(\"setDoc\", doc, sel);\n    }\n  }, {\n    key: \"updateDoc\",\n    value: function updateDoc(doc, mapping, selection) {\n      this.ensureOperation();\n      this.ranges.transform(mapping);\n      this.operation.mappings.push(mapping);\n      this.doc = doc;\n      this.sel.setAndSignal(selection || this.sel.range.map(doc, mapping));\n      // :: () #path=ProseMirror#events#change\n      // Fired when the document has changed. See\n      // [`setDoc`](#ProseMirror.event_setDoc) and\n      // [`transform`](#ProseMirror.event_transform) for more specific\n      // change-related events.\n      this.signal(\"change\");\n    }\n\n    // :: EditorTransform\n    // Create an editor- and selection-aware `Transform` for this editor.\n\n  }, {\n    key: \"apply\",\n\n\n    // :: (Transform, ?Object) → union<Transform,bool>\n    // Apply a transformation (which you might want to create with the\n    // [`tr` getter](#ProseMirror.tr)) to the document in the editor.\n    // The following options are supported:\n    //\n    // **`selection`**`: ?Selection`\n    //   : A new selection to set after the transformation is applied.\n    //\n    // **`scrollIntoView`**: ?bool\n    //   : When true, scroll the selection into view on the next\n    //     [redraw](#ProseMirror.flush).\n    //\n    // **`filter`**: ?bool\n    //   : When set to false, suppresses the ability of the\n    //     [`\"filterTransform\"` event](#ProseMirror.event_beforeTransform)\n    //     to cancel this transform.\n    //\n    // Returns the transform, or `false` if there were no steps in it.\n    //\n    // Has the following property:\n    value: function apply(transform) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? nullOptions : arguments[1];\n\n      if (!transform.steps.length) return false;\n      if (!transform.docs[0].eq(this.doc)) throw new RangeError(\"Applying a transform that does not start with the current document\");\n\n      // :: (transform: Transform) #path=ProseMirror#events#filterTransform\n      // Fired before a transform (applied without `filter: false`) is\n      // applied. The handler can return a truthy value to cancel the\n      // transform.\n      if (options.filter !== false && this.signalHandleable(\"filterTransform\", transform)) return false;\n\n      var selectionBeforeTransform = this.selection;\n\n      // :: (transform: Transform, options: Object) #path=ProseMirror#events#beforeTransform\n      // Indicates that the given transform is about to be\n      // [applied](#ProseMirror.apply). The handler may add additional\n      // [steps](#Step) to the transform, but it it not allowed to\n      // interfere with the editor's state.\n      this.signal(\"beforeTransform\", transform, options);\n      this.updateDoc(transform.doc, transform, options.selection);\n      // :: (transform: Transform, selectionBeforeTransform: Selection, options: Object) #path=ProseMirror#events#transform\n      // Signals that a (non-empty) transformation has been aplied to\n      // the editor. Passes the `Transform`, the selection before the\n      // transform, and the options given to [`apply`](#ProseMirror.apply)\n      // as arguments to the handler.\n      this.signal(\"transform\", transform, selectionBeforeTransform, options);\n      if (options.scrollIntoView) this.scrollIntoView();\n      return transform;\n    }\n\n    // :: (number, ?bool)\n    // Verify that the given position is valid in the current document,\n    // and throw an error otherwise. When `textblock` is true, the position\n    // must also fall within a textblock node.\n\n  }, {\n    key: \"checkPos\",\n    value: function checkPos(pos, textblock) {\n      var valid = pos >= 0 && pos <= this.doc.content.size;\n      if (valid && textblock) valid = this.doc.resolve(pos).parent.isTextblock;\n      if (!valid) throw new RangeError(\"Position \" + pos + \" is not valid in current document\");\n    }\n\n    // : (?Object) → Operation\n    // Ensure that an operation has started.\n\n  }, {\n    key: \"ensureOperation\",\n    value: function ensureOperation(options) {\n      return this.operation || this.startOperation(options);\n    }\n\n    // : (?Object) → Operation\n    // Start an operation and schedule a flush so that any effect of\n    // the operation shows up in the DOM.\n\n  }, {\n    key: \"startOperation\",\n    value: function startOperation(options) {\n      var _this = this;\n\n      this.operation = new Operation(this, options);\n      if (!(options && options.readSelection === false) && this.sel.readFromDOM()) this.operation.sel = this.sel.range;\n\n      if (this.flushScheduled == null) this.flushScheduled = (0, _dom.requestAnimationFrame)(function () {\n        return _this.flush();\n      });\n      return this.operation;\n    }\n\n    // Cancel any scheduled operation flush.\n\n  }, {\n    key: \"unscheduleFlush\",\n    value: function unscheduleFlush() {\n      if (this.flushScheduled != null) {\n        (0, _dom.cancelAnimationFrame)(this.flushScheduled);\n        this.flushScheduled = null;\n      }\n    }\n\n    // :: () → bool\n    // Flush any pending changes to the DOM. When the document,\n    // selection, or marked ranges in an editor change, the DOM isn't\n    // updated immediately, but rather scheduled to be updated the next\n    // time the browser redraws the screen. This method can be used to\n    // force this to happen immediately. It can be useful when you, for\n    // example, want to measure where on the screen a part of the\n    // document ends up, immediately after changing the document.\n    //\n    // Returns true when it updated the document DOM.\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      this.unscheduleFlush();\n\n      if (!document.body.contains(this.wrapper) || !this.operation) return false;\n      // :: () #path=ProseMirror#events#flushing\n      // Fired when the editor is about to [flush](#ProseMirror.flush)\n      // an update to the DOM.\n      this.signal(\"flushing\");\n\n      var op = this.operation,\n          redrawn = false;\n      if (!op) return false;\n      if (op.composing) this.input.applyComposition();\n\n      this.operation = null;\n      this.accurateSelection = true;\n\n      if (op.doc != this.doc || this.dirtyNodes.size) {\n        (0, _draw.redraw)(this, this.dirtyNodes, this.doc, op.doc);\n        this.dirtyNodes.clear();\n        redrawn = true;\n      }\n\n      if (redrawn || !op.sel.eq(this.sel.range) || op.focus) this.sel.toDOM(op.focus);\n\n      // FIXME somehow schedule this relative to ui/update so that it\n      // doesn't cause extra layout\n      if (op.scrollIntoView !== false) (0, _dompos.scrollIntoView)(this, op.scrollIntoView);\n      // :: () #path=ProseMirror#events#draw\n      // Fired when the editor redrew its document in the DOM.\n      if (redrawn) this.signal(\"draw\");\n      // :: () #path=ProseMirror#events#flush\n      // Fired when the editor has finished\n      // [flushing](#ProseMirror.flush) an update to the DOM.\n      this.signal(\"flush\");\n      this.accurateSelection = false;\n      return redrawn;\n    }\n\n    // :: (Keymap, ?number)\n    // Add a\n    // [keymap](https://github.com/marijnh/browserkeymap#an-object-type-for-keymaps)\n    // to the editor. Keymaps added in this way are queried before the\n    // base keymap. The `rank` parameter can be used to\n    // control when they are queried relative to other maps added like\n    // this. Maps with a lower rank get queried first.\n\n  }, {\n    key: \"addKeymap\",\n    value: function addKeymap(map) {\n      var rank = arguments.length <= 1 || arguments[1] === undefined ? 50 : arguments[1];\n\n      (0, _sortedinsert2.default)(this.input.keymaps, { map: map, rank: rank }, function (a, b) {\n        return a.rank - b.rank;\n      });\n    }\n\n    // :: (union<string, Keymap>)\n    // Remove the given keymap, or the keymap with the given name, from\n    // the editor.\n\n  }, {\n    key: \"removeKeymap\",\n    value: function removeKeymap(map) {\n      var maps = this.input.keymaps;\n      for (var i = 0; i < maps.length; ++i) {\n        if (maps[i].map == map || maps[i].map.options.name == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n      }\n    }\n\n    // :: (number, number, ?Object) → MarkedRange\n    // Create a marked range between the given positions. Marked ranges\n    // “track” the part of the document they point to—as the document\n    // changes, they are updated to move, grow, and shrink along with\n    // their content.\n    //\n    // `options` may be an object containing these properties:\n    //\n    // **`inclusiveLeft`**`: bool = false`\n    //   : Whether the left side of the range is inclusive. When it is,\n    //     content inserted at that point will become part of the range.\n    //     When not, it will be outside of the range.\n    //\n    // **`inclusiveRight`**`: bool = false`\n    //   : Whether the right side of the range is inclusive.\n    //\n    // **`removeWhenEmpty`**`: bool = true`\n    //   : Whether the range should be forgotten when it becomes empty\n    //     (because all of its content was deleted).\n    //\n    // **`className`**: string\n    //   : A CSS class to add to the inline content that is part of this\n    //     range.\n\n  }, {\n    key: \"markRange\",\n    value: function markRange(from, to, options) {\n      this.checkPos(from);\n      this.checkPos(to);\n      var range = new _range.MarkedRange(from, to, options);\n      this.ranges.addRange(range);\n      return range;\n    }\n\n    // :: (MarkedRange)\n    // Remove the given range from the editor.\n\n  }, {\n    key: \"removeRange\",\n    value: function removeRange(range) {\n      this.ranges.removeRange(range);\n    }\n\n    // :: (MarkType, ?bool, ?Object)\n    // Set (when `to` is true), unset (`to` is false), or toggle (`to`\n    // is null) the given mark type on the selection. When there is a\n    // non-empty selection, the marks of the selection are updated. When\n    // the selection is empty, the set of [active\n    // marks](#ProseMirror.activeMarks) is updated.\n\n  }, {\n    key: \"setMark\",\n    value: function setMark(type, to, attrs) {\n      var sel = this.selection;\n      if (sel.empty) {\n        var marks = this.activeMarks(),\n            $head = undefined;\n        if (to == null) to = !type.isInSet(marks);\n        if (to && ($head = this.doc.resolve(sel.head)) && !$head.parent.contentMatchAt($head.index()).allowsMark(type)) return;\n        this.input.storedMarks = to ? type.create(attrs).addToSet(marks) : type.removeFromSet(marks);\n        // :: () #path=ProseMirror#events#activeMarkChange\n        // Fired when the set of [active marks](#ProseMirror.activeMarks) changes.\n        this.signal(\"activeMarkChange\");\n      } else {\n        if (to != null ? to : !this.doc.rangeHasMark(sel.from, sel.to, type)) this.apply(this.tr.addMark(sel.from, sel.to, type.create(attrs)));else this.apply(this.tr.removeMark(sel.from, sel.to, type));\n      }\n    }\n\n    // :: () → [Mark]\n    // Get the marks at the cursor. By default, this yields the marks\n    // associated with the content at the cursor, as per `Node.marksAt`.\n    // But `setMark` may have been used to change the set of active\n    // marks, in which case that set is returned.\n\n  }, {\n    key: \"activeMarks\",\n    value: function activeMarks() {\n      var head;\n      return this.input.storedMarks || ((head = this.selection.head) != null ? this.doc.marksAt(head) : []);\n    }\n\n    // :: ()\n    // Give the editor focus.\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (this.operation) this.operation.focus = true;else this.sel.toDOM(true);\n    }\n\n    // :: () → bool\n    // Query whether the editor has focus.\n\n  }, {\n    key: \"hasFocus\",\n    value: function hasFocus() {\n      if (this.sel.range instanceof _selection.NodeSelection) return document.activeElement == this.content;else return (0, _selection.hasFocus)(this);\n    }\n\n    // :: ({top: number, left: number}) → ?number\n    // If the given coordinates (which should be relative to the top\n    // left corner of the window—not the page) fall within the editable\n    // content, this method will return the document position that\n    // corresponds to those coordinates.\n\n  }, {\n    key: \"posAtCoords\",\n    value: function posAtCoords(coords) {\n      this.flush();\n      return (0, _dompos.posAtCoords)(this, coords);\n    }\n\n    // :: (number) → {top: number, left: number, bottom: number}\n    // Find the screen coordinates (relative to top left corner of the\n    // window) of the given document position.\n\n  }, {\n    key: \"coordsAtPos\",\n    value: function coordsAtPos(pos) {\n      this.checkPos(pos);\n      this.flush();\n      return (0, _dompos.coordsAtPos)(this, pos);\n    }\n\n    // :: (?number)\n    // Scroll the given position, or the cursor position if `pos` isn't\n    // given, into view.\n\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView() {\n      var pos = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n\n      if (pos) this.checkPos(pos);\n      this.ensureOperation();\n      this.operation.scrollIntoView = pos;\n    }\n\n    // :: (string, ?[any]) → bool\n    // Execute the named [command](#Command). If the command takes\n    // parameters, they can be passed as an array.\n\n  }, {\n    key: \"execCommand\",\n    value: function execCommand(name, params) {\n      var cmd = this.commands[name];\n      return !!(cmd && cmd.exec(this, params) !== false);\n    }\n\n    // :: (string) → ?string\n    // Return the name of the key that is bound to the given command, if\n    // any.\n\n  }, {\n    key: \"keyForCommand\",\n    value: function keyForCommand(name) {\n      var cached = this.commandKeys[name];\n      if (cached !== undefined) return cached;\n\n      var cmd = this.commands[name],\n          keymap = this.input.baseKeymap;\n      if (!cmd) return this.commandKeys[name] = null;\n      var key = cmd.spec.key || (_dom.browser.mac ? cmd.spec.macKey : cmd.spec.pcKey);\n      if (key) {\n        key = _browserkeymap2.default.normalizeKeyName(Array.isArray(key) ? key[0] : key);\n        var deflt = keymap.bindings[key];\n        if (Array.isArray(deflt) ? deflt.indexOf(name) > -1 : deflt == name) return this.commandKeys[name] = key;\n      }\n      for (var _key in keymap.bindings) {\n        var bound = keymap.bindings[_key];\n        if (Array.isArray(bound) ? bound.indexOf(name) > -1 : bound == name) return this.commandKeys[name] = _key;\n      }\n      return this.commandKeys[name] = null;\n    }\n  }, {\n    key: \"markRangeDirty\",\n    value: function markRangeDirty(from, to) {\n      var doc = arguments.length <= 2 || arguments[2] === undefined ? this.doc : arguments[2];\n\n      this.ensureOperation();\n      var dirty = this.dirtyNodes;\n      var $from = doc.resolve(from),\n          $to = doc.resolve(to);\n      var same = $from.sameDepth($to);\n      for (var depth = 0; depth <= same; depth++) {\n        var child = $from.node(depth);\n        if (!dirty.has(child)) dirty.set(child, DIRTY_RESCAN);\n      }\n      var start = $from.index(same),\n          end = $to.index(same) + (same == $to.depth && $to.atNodeBoundary ? 0 : 1);\n      var parent = $from.node(same);\n      for (var i = start; i < end; i++) {\n        dirty.set(parent.child(i), DIRTY_REDRAW);\n      }\n    }\n  }, {\n    key: \"markAllDirty\",\n    value: function markAllDirty() {\n      this.dirtyNodes.set(this.doc, DIRTY_REDRAW);\n    }\n\n    // :: (string) → string\n    // Return a translated string, if a translate function has been supplied,\n    // or the original string.\n\n  }, {\n    key: \"translate\",\n    value: function translate(string) {\n      var trans = this.options.translate;\n      return trans ? trans(string) : string;\n    }\n  }, {\n    key: \"selection\",\n    get: function get() {\n      if (!this.accurateSelection) this.ensureOperation();\n      return this.sel.range;\n    }\n  }, {\n    key: \"tr\",\n    get: function get() {\n      return new _transform.EditorTransform(this);\n    }\n  }]);\n\n  return ProseMirror;\n}();\n\n// :: Object\n// The object `{scrollIntoView: true}`, which is a common argument to\n// pass to `ProseMirror.apply` or `EditorTransform.apply`.\n\n\nProseMirror.prototype.apply.scroll = { scrollIntoView: true };\n\nvar DIRTY_RESCAN = exports.DIRTY_RESCAN = 1,\n    DIRTY_REDRAW = exports.DIRTY_REDRAW = 2;\n\nvar nullOptions = {};\n\n(0, _event.eventMixin)(ProseMirror);\n\n// Operations are used to delay/batch DOM updates. When a change to\n// the editor state happens, it is not immediately flushed to the DOM,\n// but rather a call to `ProseMirror.flush` is scheduled using\n// `requestAnimationFrame`. An object of this class is stored in the\n// editor's `operation` property, and holds information about the\n// state at the start of the operation, which can be used to determine\n// the minimal DOM update needed. It also stores information about\n// whether a focus needs to happen on flush, and whether something\n// needs to be scrolled into view.\n\nvar Operation = function Operation(pm, options) {\n  _classCallCheck(this, Operation);\n\n  this.doc = pm.doc;\n  this.docSet = false;\n  this.sel = options && options.selection || pm.sel.range;\n  this.scrollIntoView = false;\n  this.focus = false;\n  this.mappings = [];\n  this.composing = null;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/main.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/main.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _dom = __webpack_require__(10);\n\n(0, _dom.insertCSS)(\"\\n\\n.ProseMirror {\\n  border: 1px solid silver;\\n  position: relative;\\n}\\n\\n.ProseMirror-content {\\n  padding: 4px 8px 4px 14px;\\n  white-space: pre-wrap;\\n  line-height: 1.2;\\n}\\n\\n.ProseMirror-drop-target {\\n  position: absolute;\\n  width: 1px;\\n  background: #666;\\n  pointer-events: none;\\n}\\n\\n.ProseMirror-content ul.tight p, .ProseMirror-content ol.tight p {\\n  margin: 0;\\n}\\n\\n.ProseMirror-content ul, .ProseMirror-content ol {\\n  padding-left: 30px;\\n  cursor: default;\\n}\\n\\n.ProseMirror-content blockquote {\\n  padding-left: 1em;\\n  border-left: 3px solid #eee;\\n  margin-left: 0; margin-right: 0;\\n}\\n\\n.ProseMirror-content pre {\\n  white-space: pre-wrap;\\n}\\n\\n.ProseMirror-selectednode {\\n  outline: 2px solid #8cf;\\n}\\n\\n.ProseMirror-nodeselection *::selection { background: transparent; }\\n.ProseMirror-nodeselection *::-moz-selection { background: transparent; }\\n\\n.ProseMirror-content p:first-child,\\n.ProseMirror-content h1:first-child,\\n.ProseMirror-content h2:first-child,\\n.ProseMirror-content h3:first-child,\\n.ProseMirror-content h4:first-child,\\n.ProseMirror-content h5:first-child,\\n.ProseMirror-content h6:first-child {\\n  margin-top: .3em;\\n}\\n\\n/* Add space around the hr to make clicking it easier */\\n\\n.ProseMirror-content hr {\\n  position: relative;\\n  height: 6px;\\n  border: none;\\n}\\n\\n.ProseMirror-content hr:after {\\n  content: \\\"\\\";\\n  position: absolute;\\n  left: 10px;\\n  right: 10px;\\n  top: 2px;\\n  border-top: 2px solid silver;\\n}\\n\\n.ProseMirror-content img {\\n  cursor: default;\\n}\\n\\n/* Make sure li selections wrap around markers */\\n\\n.ProseMirror-content li {\\n  position: relative;\\n  pointer-events: none; /* Don't do weird stuff with marker clicks */\\n}\\n.ProseMirror-content li > * {\\n  pointer-events: auto;\\n}\\n\\nli.ProseMirror-selectednode {\\n  outline: none;\\n}\\n\\nli.ProseMirror-selectednode:after {\\n  content: \\\"\\\";\\n  position: absolute;\\n  left: -32px;\\n  right: -2px; top: -2px; bottom: -2px;\\n  border: 2px solid #8cf;\\n  pointer-events: none;\\n}\\n\\n\");\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/css.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/css.js?");

/***/ },
/* 10 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.elt = elt;\nexports.requestAnimationFrame = requestAnimationFrame;\nexports.cancelAnimationFrame = cancelAnimationFrame;\nexports.contains = contains;\nexports.insertCSS = insertCSS;\nexports.ensureCSSAdded = ensureCSSAdded;\nfunction elt(tag, attrs) {\n  var result = document.createElement(tag);\n  if (attrs) for (var name in attrs) {\n    if (name == \"style\") result.style.cssText = attrs[name];else if (attrs[name] != null) result.setAttribute(name, attrs[name]);\n  }\n\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    add(args[i], result);\n  }return result;\n}\n\nfunction add(value, target) {\n  if (typeof value == \"string\") value = document.createTextNode(value);\n\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      add(value[i], target);\n    }\n  } else {\n    target.appendChild(value);\n  }\n}\n\nvar reqFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\nvar cancelFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n\nfunction requestAnimationFrame(f) {\n  if (reqFrame) return reqFrame(f);else return setTimeout(f, 10);\n}\n\nfunction cancelAnimationFrame(handle) {\n  if (reqFrame) return cancelFrame(handle);else clearTimeout(handle);\n}\n\nvar ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n\nvar browser = exports.browser = {\n  mac: /Mac/.test(navigator.platform),\n  ie: ie_upto10 || !!ie_11up,\n  ie_version: ie_upto10 ? document.documentMode || 6 : ie_11up && +ie_11up[1],\n  gecko: /gecko\\/\\d/i.test(navigator.userAgent),\n  ios: /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent)\n};\n\n// : (DOMNode, DOMNode) → bool\n// Check whether a DOM node is an ancestor of another DOM node.\nfunction contains(parent, child) {\n  // Android browser and IE will return false if child is a text node.\n  if (child.nodeType != 1) child = child.parentNode;\n  return child && parent.contains(child);\n}\n\nvar accumulatedCSS = \"\",\n    cssNode = null;\n\nfunction insertCSS(css) {\n  if (cssNode) cssNode.textContent += css;else accumulatedCSS += css;\n}\n\n// This is called when a ProseMirror instance is created, to ensure\n// the CSS is in the DOM.\nfunction ensureCSSAdded() {\n  if (!cssNode) {\n    cssNode = document.createElement(\"style\");\n    cssNode.textContent = \"/* ProseMirror CSS */\\n\" + accumulatedCSS;\n    document.head.insertBefore(cssNode, document.head.firstChild);\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/dom/index.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/dom/index.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("(function(mod) {\n  if (true) // CommonJS\n    module.exports = mod()\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod)\n  else // Plain browser env\n    (this || window).browserKeymap = mod()\n})(function() {\n  \"use strict\"\n\n  var mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n  // :: Object<string>\n  // A map from key codes to key names.\n  var keyNames = {\n    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  }\n\n  // Number keys\n  for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i)\n  // Alphabetic keys\n  for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i)\n  // Function keys\n  for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i\n\n  // :: (KeyboardEvent) → ?string\n  // Find a name for the given keydown event. If the keycode in the\n  // event is not known, this will return `null`. Otherwise, it will\n  // return a string like `\"Shift-Cmd-Ctrl-Alt-Home\"`. The parts before\n  // the dashes give the modifiers (always in that order, if present),\n  // and the last word gives the key name, which one of the names in\n  // `keyNames`.\n  //\n  // The convention for keypress events is to use the pressed character\n  // between single quotes. Due to limitations in the browser API,\n  // keypress events can not have modifiers.\n  function keyName(event) {\n    if (event.type == \"keypress\") return \"'\" + String.fromCharCode(event.charCode) + \"'\"\n\n    var base = keyNames[event.keyCode], name = base\n    if (name == null || event.altGraphKey) return null\n\n    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name\n    if (event.ctrlKey && base != \"Ctrl\") name = \"Ctrl-\" + name\n    if (event.metaKey && base != \"Cmd\") name = \"Cmd-\" + name\n    if (event.shiftKey && base != \"Shift\") name = \"Shift-\" + name\n    return name\n  }\n\n  // :: (string) → bool\n  // Test whether the given key name refers to a modifier key.\n  function isModifierKey(name) {\n    name = /[^-]*$/.exec(name)[0]\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  // :: (string) → string\n  // Normalize a sloppy key name, which may have modifiers in the wrong\n  // order or use shorthands for modifiers, to a properly formed key\n  // name. Used to normalize names provided in keymaps.\n  //\n  // Note that the modifier `mod` is a shorthand for `Cmd` on Mac, and\n  // `Ctrl` on other platforms.\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!'?$)/), result = parts[parts.length - 1]\n    var alt, ctrl, shift, cmd\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i]\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true\n      else if (/^a(lt)?$/i.test(mod)) alt = true\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true\n      else if (/^s(hift)$/i.test(mod)) shift = true\n      else if (/^mod$/i.test(mod)) { if (mac) cmd = true; else ctrl = true }\n      else throw new Error(\"Unrecognized modifier name: \" + mod)\n    }\n    if (alt) result = \"Alt-\" + result\n    if (ctrl) result = \"Ctrl-\" + result\n    if (cmd) result = \"Cmd-\" + result\n    if (shift) result = \"Shift-\" + result\n    return result\n  }\n\n  // :: (Object, ?Object)\n  // A keymap binds a set of [key names](#keyName) to commands names\n  // or functions.\n  //\n  // Construct a keymap using the bindings in `keys`, whose properties\n  // should be [key names](#keyName) or space-separated sequences of\n  // key names. In the second case, the binding will be for a\n  // multi-stroke key combination.\n  //\n  // When `options` has a property `call`, this will be a programmatic\n  // keymap, meaning that instead of looking keys up in its set of\n  // bindings, it will pass the key name to `options.call`, and use\n  // the return value of that calls as the resolved binding.\n  //\n  // `options.name` can be used to give the keymap a name, making it\n  // easier to [remove](#ProseMirror.removeKeymap) from an editor.\n  function Keymap(keys, options) {\n    this.options = options || {}\n    this.bindings = Object.create(null)\n    if (keys) for (var keyname in keys) if (Object.prototype.hasOwnProperty.call(keys, keyname))\n      this.addBinding(keyname, keys[keyname])\n  }\n\n  Keymap.prototype = {\n    normalize: function(name) {\n      return this.options.multi !== false ? name.split(/ +(?!\\'$)/).map(normalizeKeyName) : [normalizeKeyName(name)]\n    },\n\n    // :: (string, any)\n    // Add a binding for the given key or key sequence.\n    addBinding: function(keyname, value) {\n      var keys = this.normalize(keyname)\n      for (var i = 0; i < keys.length; i++) {\n        var name = keys.slice(0, i + 1).join(\" \")\n        var val = i == keys.length - 1 ? value : \"...\"\n        var prev = this.bindings[name]\n        if (!prev) this.bindings[name] = val\n        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name)\n      }\n    },\n\n    // :: (string)\n    // Remove the binding for the given key or key sequence.\n    removeBinding: function(keyname) {\n      var keys = this.normalize(keyname)\n      for (var i = keys.length - 1; i >= 0; i--) {\n        var name = keys.slice(0, i).join(\" \")\n        var val = this.bindings[name]\n        if (val == \"...\" && !this.unusedMulti(name))\n          break\n        else if (val)\n          delete this.bindings[name]\n      }\n    },\n\n    unusedMulti: function(name) {\n      for (var binding in this.bindings)\n        if (binding.length > name && binding.indexOf(name) == 0 && binding.charAt(name.length) == \" \")\n          return false\n      return true\n    },\n\n    // :: (string, ?any) → any\n    // Looks up the given key or key sequence in this keymap. Returns\n    // the value the key is bound to (which may be undefined if it is\n    // not bound), or the string `\"...\"` if the key is a prefix of a\n    // multi-key sequence that is bound by this keymap.\n    lookup: function(key, context) {\n      return this.options.call ? this.options.call(key, context) : this.bindings[key]\n    },\n\n    constructor: Keymap\n  }\n\n  Keymap.keyName = keyName\n  Keymap.isModifierKey = isModifierKey\n  Keymap.normalizeKeyName = normalizeKeyName\n\n  return Keymap\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/~/browserkeymap/index.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/~/browserkeymap/index.js?");

/***/ },
/* 12 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sortedInsert;\nfunction sortedInsert(array, elt, compare) {\n  var i = 0;\n  for (; i < array.length; i++) {\n    if (compare(array[i], elt) > 0) break;\n  }array.splice(i, 0, elt);\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/util/sortedinsert.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/util/sortedinsert.js?");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Map = exports.Map = window.Map || function () {\n  function _class() {\n    _classCallCheck(this, _class);\n\n    this.content = [];\n  }\n\n  _createClass(_class, [{\n    key: \"set\",\n    value: function set(key, value) {\n      var found = this.find(key);\n      if (found > -1) this.content[found + 1] = value;else this.content.push(key, value);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var found = this.find(key);\n      return found == -1 ? undefined : this.content[found + 1];\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.find(key) > -1;\n    }\n  }, {\n    key: \"find\",\n    value: function find(key) {\n      for (var i = 0; i < this.content.length; i += 2) {\n        if (this.content[i] === key) return i;\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.content.length = 0;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.content.length / 2;\n    }\n  }]);\n\n  return _class;\n}();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/util/map.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/util/map.js?");

/***/ },
/* 14 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.eventMixin = eventMixin;\n// ;; #path=EventMixin #kind=interface\n// A set of methods for objects that emit events. Added by calling\n// `eventMixin` on a constructor.\n\nvar noHandlers = [];\n\nfunction getHandlers(obj, type) {\n  return obj._handlers && obj._handlers[type] || noHandlers;\n}\n\nvar methods = {\n  // :: (type: string, handler: (...args: [any])) #path=EventMixin.on\n  // Register an event handler for the given event type.\n\n  on: function on(type, handler) {\n    var map = this._handlers || (this._handlers = Object.create(null));\n    map[type] = type in map ? map[type].concat(handler) : [handler];\n  },\n\n\n  // :: (type: string, handler: (...args: [any])) #path=EventMixin.off\n  // Unregister an event handler for the given event type.\n  off: function off(type, handler) {\n    var map = this._handlers,\n        arr = map && map[type];\n    if (arr) for (var i = 0; i < arr.length; ++i) {\n      if (arr[i] == handler) {\n        map[type] = arr.slice(0, i).concat(arr.slice(i + 1));\n        break;\n      }\n    }\n  },\n\n\n  // :: (type: string, ...args: [any]) #path=EventMixin.signal\n  // Signal an event of the given type, passing any number of\n  // arguments. Will call the handlers for the event, passing them the\n  // arguments.\n  signal: function signal(type) {\n    var arr = getHandlers(this, type);\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    for (var i = 0; i < arr.length; ++i) {\n      arr[i].apply(arr, args);\n    }\n  },\n\n\n  // :: (type: string, ...args: [any]) → any\n  // #path=EventMixin.signalHandleable Signal a handleable event of\n  // the given type. All handlers for the event will be called with\n  // the given arguments, until one of them returns something that is\n  // not the value `null` or `undefined`. When that happens, the\n  // return value of that handler is returned. If that does not\n  // happen, `undefined` is returned.\n  signalHandleable: function signalHandleable(type) {\n    var arr = getHandlers(this, type);\n\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    for (var i = 0; i < arr.length; ++i) {\n      var result = arr[i].apply(arr, args);\n      if (result != null) return result;\n    }\n  },\n\n\n  // :: (type: string, value: any) → any #path=EventMixin.signalPipelined\n  // Give all handlers for an event a chance to transform a value. The\n  // value returned from a handler will be passed to the next handler.\n  // The method returns the value returned by the final handler (or\n  // the original value, if there are no handlers).\n  signalPipelined: function signalPipelined(type, value) {\n    var arr = getHandlers(this, type);\n    for (var i = 0; i < arr.length; ++i) {\n      value = arr[i](value);\n    }return value;\n  },\n\n\n  // :: (DOMEvent, ?string) → bool\n  // Fire all handlers for `event.type` (or override the type name\n  // with the `type` parameter), until one of them calls\n  // `preventDefault` on the event or returns `true` to indicate it\n  // handled the event. Return `true` when one of the handlers handled\n  // the event.\n  signalDOM: function signalDOM(event, type) {\n    var arr = getHandlers(this, type || event.type);\n    for (var i = 0; i < arr.length; ++i) {\n      if (arr[i](event) || event.defaultPrevented) return true;\n    }return false;\n  },\n\n\n  // :: (type: string) → bool #path=EventMixin.hasHandler\n  // Query whether there are any handlers for this event type.\n  hasHandler: function hasHandler(type) {\n    return getHandlers(this, type).length > 0;\n  }\n};\n\n// :: (())\n// Add the methods in the `EventMixin` interface to the prototype\n// object of the given constructor.\nfunction eventMixin(ctor) {\n  var proto = ctor.prototype;\n  for (var prop in methods) {\n    if (methods.hasOwnProperty(prop)) proto[prop] = methods[prop];\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/util/event.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/util/event.js?");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _register = __webpack_require__(16);\n\nObject.defineProperty(exports, \"serializeTo\", {\n  enumerable: true,\n  get: function get() {\n    return _register.serializeTo;\n  }\n});\nObject.defineProperty(exports, \"knownTarget\", {\n  enumerable: true,\n  get: function get() {\n    return _register.knownTarget;\n  }\n});\nObject.defineProperty(exports, \"defineTarget\", {\n  enumerable: true,\n  get: function get() {\n    return _register.defineTarget;\n  }\n});\nObject.defineProperty(exports, \"parseFrom\", {\n  enumerable: true,\n  get: function get() {\n    return _register.parseFrom;\n  }\n});\nObject.defineProperty(exports, \"knownSource\", {\n  enumerable: true,\n  get: function get() {\n    return _register.knownSource;\n  }\n});\nObject.defineProperty(exports, \"defineSource\", {\n  enumerable: true,\n  get: function get() {\n    return _register.defineSource;\n  }\n});\n\nvar _from_dom = __webpack_require__(17);\n\nObject.defineProperty(exports, \"fromDOM\", {\n  enumerable: true,\n  get: function get() {\n    return _from_dom.fromDOM;\n  }\n});\nObject.defineProperty(exports, \"fromHTML\", {\n  enumerable: true,\n  get: function get() {\n    return _from_dom.fromHTML;\n  }\n});\n\nvar _to_dom = __webpack_require__(32);\n\nObject.defineProperty(exports, \"toDOM\", {\n  enumerable: true,\n  get: function get() {\n    return _to_dom.toDOM;\n  }\n});\nObject.defineProperty(exports, \"toHTML\", {\n  enumerable: true,\n  get: function get() {\n    return _to_dom.toHTML;\n  }\n});\nObject.defineProperty(exports, \"nodeToDOM\", {\n  enumerable: true,\n  get: function get() {\n    return _to_dom.nodeToDOM;\n  }\n});\n\nvar _from_text = __webpack_require__(33);\n\nObject.defineProperty(exports, \"fromText\", {\n  enumerable: true,\n  get: function get() {\n    return _from_text.fromText;\n  }\n});\n\nvar _to_text = __webpack_require__(34);\n\nObject.defineProperty(exports, \"toText\", {\n  enumerable: true,\n  get: function get() {\n    return _to_text.toText;\n  }\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/format/index.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/format/index.js?");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeTo = serializeTo;\nexports.knownTarget = knownTarget;\nexports.defineTarget = defineTarget;\nexports.parseFrom = parseFrom;\nexports.knownSource = knownSource;\nexports.defineSource = defineSource;\nvar serializers = Object.create(null);\n\n// :: (Node, string, ?Object) → any\n// Serialize the given document to the given format. If `options` is\n// given, it will be passed along to the serializer function.\nfunction serializeTo(doc, format, options) {\n  var converter = serializers[format];\n  if (!converter) throw new RangeError(\"Target format \" + format + \" not defined\");\n  return converter(doc, options);\n}\n\n// :: (string) → bool\n// Query whether a given serialization format has been registered.\nfunction knownTarget(format) {\n  return !!serializers[format];\n}\n\n// :: (string, (Node, ?Object) → any)\n// Register a function as the serializer for `format`.\nfunction defineTarget(format, func) {\n  serializers[format] = func;\n}\n\ndefineTarget(\"json\", function (doc) {\n  return doc.toJSON();\n});\n\nvar parsers = Object.create(null);\n\n// :: (Schema, any, string, ?Object) → Node\n// Parse document `value` from the format named by `format`. If\n// `options` is given, it is passed along to the parser function.\nfunction parseFrom(schema, value, format, options) {\n  var converter = parsers[format];\n  if (!converter) throw new RangeError(\"Source format \" + format + \" not defined\");\n  return converter(schema, value, options);\n}\n\n// :: (string) → bool\n// Query whether a parser for the named format has been registered.\nfunction knownSource(format) {\n  return !!parsers[format];\n}\n\n// :: (string, (Schema, any, ?Object) → Node)\n// Register a parser function for `format`.\nfunction defineSource(format, func) {\n  parsers[format] = func;\n}\n\ndefineSource(\"json\", function (schema, json) {\n  return schema.nodeFromJSON(json);\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/format/register.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/format/register.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.fromDOM = fromDOM;\nexports.fromHTML = fromHTML;\n\nvar _model = __webpack_require__(18);\n\nvar _sortedinsert = __webpack_require__(12);\n\nvar _sortedinsert2 = _interopRequireDefault(_sortedinsert);\n\nvar _register = __webpack_require__(16);\n\nvar _comparedeep = __webpack_require__(22);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// :: (Schema, DOMNode, ?Object) → Node\n// Parse document from the content of a DOM node. To pass an explicit\n// parent document (for example, when not in a browser window\n// environment, where we simply use the global document), pass it as\n// the `document` property of `options`.\nfunction fromDOM(schema, dom, options) {\n  if (!options) options = {};\n  var top = options.topNode;\n  var context = new DOMParseState(schema, top === false ? null : top || schema.node(\"doc\"), options);\n  var start = options.from ? dom.childNodes[options.from] : dom.firstChild;\n  var end = options.to != null && dom.childNodes[options.to] || null;\n  context.addAll(start, end, true);\n  while (context.stack.length > 1) {\n    context.leave();\n  }return context.leave();\n}\n\n// ;; #path=DOMParseSpec #kind=interface\n// To define the way [node](#NodeType) and [mark](#MarkType) types are\n// parsed, you can associate one or more DOM parsing specifications to\n// them using the [`register`](#SchemaItem.register) method with the\n// `\"parseDOM\"` namespace, using the HTML node name (lowercase) as\n// value name. Each of them defines a parsing strategy for a certain\n// type of DOM node. When `\"_\"` is used as name, the parser is\n// activated for all nodes.\n\n// :: ?number #path=DOMParseSpec.rank\n// The precedence of this parsing strategy. Should be a number between\n// 0 and 100, which determines when this parser gets a chance relative\n// to others that apply to the node (low ranks go first). Defaults to\n// 50.\n\n// :: union<string, (dom: DOMNode, state: DOMParseState) → ?bool> #path=DOMParseSpec.parse\n// The function that, given a DOM node, parses it, updating the parse\n// state. It should return (the exact value) `false` when it wants to\n// indicate that it was not able to parse this node. This function is\n// called in such a way that `this` is bound to the type that the\n// parse spec was associated with.\n//\n// When this is set to the string `\"block\"`, the content of the DOM\n// node is parsed as the content in a node of the type that this spec\n// was associated with.\n//\n// When set to the string `\"mark\"`, the content of the DOM node is\n// parsed with an instance of the mark that this spec was associated\n// with added to their marks.\n\n// :: ?string #path=DOMParseSpec.selector\n// A css selector to match against. If present, it will try to match the selector\n// against the dom node prior to calling the parse function.\n\n(0, _register.defineSource)(\"dom\", fromDOM);\n\nvar NodeBuilder = function () {\n  function NodeBuilder(type, attrs) {\n    _classCallCheck(this, NodeBuilder);\n\n    this.type = type;\n    this.pos = type.contentExpr.start(attrs);\n    this.content = [];\n  }\n\n  _createClass(NodeBuilder, [{\n    key: \"add\",\n    value: function add(node) {\n      var _this = this;\n\n      var matched = this.pos.matchNode(node);\n      if (!matched && node.marks.length) {\n        node = node.mark(node.marks.filter(function (mark) {\n          return _this.pos.allowsMark(mark.type);\n        }));\n        matched = this.pos.matchNode(node);\n      }\n      if (!matched) return false;\n      this.content.push(node);\n      this.pos = matched;\n      return true;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var fill = this.pos.fillBefore(_model.Fragment.empty, true);\n      if (!fill) return null;\n      return this.type.create(this.pos.attrs, _model.Fragment.from(this.content).append(fill));\n    }\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.type.isTextblock;\n    }\n  }]);\n\n  return NodeBuilder;\n}();\n\nvar FragmentBuilder = function () {\n  function FragmentBuilder() {\n    _classCallCheck(this, FragmentBuilder);\n\n    this.content = [];\n  }\n\n  _createClass(FragmentBuilder, [{\n    key: \"add\",\n    value: function add(node) {\n      this.content.push(node);return true;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return _model.Fragment.fromArray(this.content);\n    }\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return FragmentBuilder;\n}();\n\n// :: (Schema, string, ?Object) → Node\n// Parses the HTML into a DOM, and then calls through to `fromDOM`.\n\n\nfunction fromHTML(schema, html, options) {\n  var wrap = (options && options.document || window.document).createElement(\"div\");\n  wrap.innerHTML = html;\n  return fromDOM(schema, wrap, options);\n}\n\n(0, _register.defineSource)(\"html\", fromHTML);\n\nvar blockElements = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\n\nvar ignoreElements = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n};\n\nvar listElements = { ol: true, ul: true };\n\nvar noMarks = [];\n\n// ;; A state object used to track context during a parse,\n// and to expose methods to custom parsing functions.\n\nvar DOMParseState = function () {\n  function DOMParseState(schema, topNode, options) {\n    _classCallCheck(this, DOMParseState);\n\n    // :: Object The options passed to this parse.\n    this.options = options || {};\n    // :: Schema The schema that we are parsing into.\n    this.schema = schema;\n    this.stack = [];\n    this.marks = noMarks;\n    this.closing = false;\n    if (topNode) this.enter(topNode.type, topNode.attrs);else this.enterPseudo();\n    var info = schemaInfo(schema);\n    this.tagInfo = info.tags;\n    this.styleInfo = info.styles;\n  }\n\n  _createClass(DOMParseState, [{\n    key: \"addDOM\",\n    value: function addDOM(dom) {\n      if (dom.nodeType == 3) {\n        var value = dom.nodeValue;\n        var top = this.top,\n            last = undefined;\n        if (/\\S/.test(value) || top.isTextblock) {\n          if (!this.options.preserveWhitespace) {\n            value = value.replace(/\\s+/g, \" \");\n            // If this starts with whitespace, and there is either no node\n            // before it or a node that ends with whitespace, strip the\n            // leading space.\n            if (/^\\s/.test(value) && (!(last = top.content[top.content.length - 1]) || last.type.name == \"text\" && /\\s$/.test(last.text))) value = value.slice(1);\n          }\n          if (value) this.insertNode(this.schema.text(value, this.marks));\n        }\n      } else if (dom.nodeType == 1 && !dom.hasAttribute(\"pm-ignore\")) {\n        var style = dom.getAttribute(\"style\");\n        if (style) this.addElementWithStyles(parseStyles(style), dom);else this.addElement(dom);\n      }\n    }\n  }, {\n    key: \"addElement\",\n    value: function addElement(dom) {\n      var name = dom.nodeName.toLowerCase();\n      if (listElements.hasOwnProperty(name)) this.normalizeList(dom);\n      // Ignore trailing BR nodes, which browsers create during editing\n      if (this.options.editableContent && name == \"br\" && !dom.nextSibling) return;\n      if (!this.parseNodeType(name, dom) && !ignoreElements.hasOwnProperty(name)) {\n        this.addAll(dom.firstChild, null);\n        if (blockElements.hasOwnProperty(name)) this.closing = true;\n      }\n    }\n  }, {\n    key: \"addElementWithStyles\",\n    value: function addElementWithStyles(styles, dom) {\n      var _this2 = this;\n\n      var wrappers = [];\n      for (var i = 0; i < styles.length; i += 2) {\n        var parsers = this.styleInfo[styles[i]],\n            value = styles[i + 1];\n        if (parsers) for (var j = 0; j < parsers.length; j++) {\n          wrappers.push(parsers[j], value);\n        }\n      }\n      var next = function next(i) {\n        if (i == wrappers.length) {\n          _this2.addElement(dom);\n        } else {\n          var parser = wrappers[i];\n          parser.parse.call(parser.type, wrappers[i + 1], _this2, next.bind(null, i + 2));\n        }\n      };\n      next(0);\n    }\n  }, {\n    key: \"tryParsers\",\n    value: function tryParsers(parsers, dom) {\n      if (parsers) for (var i = 0; i < parsers.length; i++) {\n        var parser = parsers[i];\n        if ((!parser.selector || matches(dom, parser.selector)) && parser.parse.call(parser.type, dom, this) !== false) return true;\n      }\n    }\n  }, {\n    key: \"parseNodeType\",\n    value: function parseNodeType(name, dom) {\n      return this.tryParsers(this.tagInfo[name], dom) || this.tryParsers(this.tagInfo._, dom);\n    }\n  }, {\n    key: \"addAll\",\n    value: function addAll(from, to, sync) {\n      var stack = sync && this.stack.slice(),\n          needsSync = false;\n      for (var dom = from; dom != to; dom = dom.nextSibling) {\n        this.addDOM(dom);\n        if (sync) {\n          var isBlock = blockElements.hasOwnProperty(dom.nodeName.toLowerCase());\n          if (isBlock) this.sync(stack);\n          needsSync = !isBlock;\n        }\n      }\n      if (needsSync) this.sync(stack);\n    }\n  }, {\n    key: \"doClose\",\n    value: function doClose() {\n      if (!this.closing || this.stack.length < 2) return;\n      var left = this.leave();\n      this.enter(left.type, left.attrs);\n      this.closing = false;\n    }\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node) {\n      var added = this.top.add(node);\n      if (added) return added;\n\n      var found = undefined;\n      for (var i = this.stack.length - 1; i >= 0; i--) {\n        var builder = this.stack[i];\n        var route = builder.pos.findWrapping(node.type, node.attrs);\n        if (!route) continue;\n        if (i == this.stack.length - 1) {\n          this.doClose();\n        } else {\n          while (this.stack.length > i + 1) {\n            this.leave();\n          }\n        }\n        found = route;\n        break;\n      }\n      if (!found) return;\n      for (var i = 0; i < found.length; i++) {\n        this.enter(found[i].type, found[i].attrs);\n      }if (this.marks.length) this.marks = noMarks;\n      return this.top.add(node);\n    }\n\n    // :: (NodeType, ?Object, [Node]) → ?Node\n    // Insert a node of the given type, with the given content, based on\n    // `dom`, at the current position in the document.\n\n  }, {\n    key: \"insert\",\n    value: function insert(type, attrs, content) {\n      var frag = type.fixContent(_model.Fragment.from(content), attrs);\n      if (!frag) return null;\n      return this.insertNode(type.create(attrs, frag, this.marks));\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(type, attrs) {\n      this.stack.push(new NodeBuilder(type, attrs));\n    }\n  }, {\n    key: \"enterPseudo\",\n    value: function enterPseudo() {\n      this.stack.push(new FragmentBuilder());\n    }\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      if (this.marks.length) this.marks = noMarks;\n      var top = this.stack.pop();\n      var last = top.content[top.content.length - 1];\n      if (!this.options.preserveWhitespace && last && last.isText && /\\s$/.test(last.text)) {\n        if (last.text.length == 1) top.content.pop();else top.content[top.content.length - 1] = last.copy(last.text.slice(0, last.text.length - 1));\n      }\n      var node = top.finish();\n      if (node && this.stack.length) this.insertNode(node);\n      return node;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(stack) {\n      while (this.stack.length > stack.length) {\n        this.leave();\n      }for (;;) {\n        var n = this.stack.length - 1,\n            one = this.stack[n],\n            two = stack[n];\n        if (one.type == two.type && (0, _comparedeep.compareDeep)(one.attrs, two.attrs)) break;\n        this.leave();\n      }\n      while (stack.length > this.stack.length) {\n        var add = stack[this.stack.length];\n        this.enter(add.type, add.attrs);\n      }\n      if (this.marks.length) this.marks = noMarks;\n      this.closing = false;\n    }\n\n    // :: (DOMNode, NodeType, ?Object)\n    // Parse the contents of `dom` as children of a node of the given\n    // type.\n\n  }, {\n    key: \"wrapIn\",\n    value: function wrapIn(dom, type, attrs) {\n      this.enter(type, attrs);\n      this.addAll(dom.firstChild, null, true);\n      this.leave();\n    }\n\n    // :: (DOMNode, Mark)\n    // Parse the contents of `dom`, with `mark` added to the set of\n    // current marks.\n\n  }, {\n    key: \"wrapMark\",\n    value: function wrapMark(inner, mark) {\n      var old = this.marks;\n      this.marks = (mark.instance || mark).addToSet(old);\n      if (inner.call) inner();else this.addAll(inner.firstChild, null);\n      this.marks = old;\n    }\n  }, {\n    key: \"normalizeList\",\n    value: function normalizeList(dom) {\n      for (var child = dom.firstChild, prev; child; child = child.nextSibling) {\n        if (child.nodeType == 1 && listElements.hasOwnProperty(child.nodeName.toLowerCase()) && (prev = child.previousSibling)) {\n          prev.appendChild(child);\n          child = prev;\n        }\n      }\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.stack[this.stack.length - 1];\n    }\n  }]);\n\n  return DOMParseState;\n}();\n\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\n\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g,\n      m = undefined,\n      result = [];\n  while (m = re.exec(style)) {\n    result.push(m[1], m[2].trim());\n  }return result;\n}\n\nfunction schemaInfo(schema) {\n  return schema.cached.parseDOMInfo || (schema.cached.parseDOMInfo = summarizeSchemaInfo(schema));\n}\n\nfunction summarizeSchemaInfo(schema) {\n  var tags = Object.create(null),\n      styles = Object.create(null);\n  tags._ = [];\n  schema.registry(\"parseDOM\", function (tag, info, type) {\n    var parse = info.parse;\n    if (parse == \"block\") parse = function parse(dom, state) {\n      state.wrapIn(dom, this);\n    };else if (parse == \"mark\") parse = function parse(dom, state) {\n      state.wrapMark(dom, this);\n    };\n    (0, _sortedinsert2.default)(tags[tag] || (tags[tag] = []), {\n      type: type, parse: parse,\n      selector: info.selector,\n      rank: info.rank == null ? 50 : info.rank\n    }, function (a, b) {\n      return a.rank - b.rank;\n    });\n  });\n  schema.registry(\"parseDOMStyle\", function (style, info, type) {\n    (0, _sortedinsert2.default)(styles[style] || (styles[style] = []), {\n      type: type,\n      parse: info.parse,\n      rank: info.rank == null ? 50 : info.rank\n    }, function (a, b) {\n      return a.rank - b.rank;\n    });\n  });\n  return { tags: tags, styles: styles };\n}\n\n_model.Paragraph.register(\"parseDOM\", \"p\", { parse: \"block\" });\n\n_model.BlockQuote.register(\"parseDOM\", \"blockquote\", { parse: \"block\" });\n\nvar _loop = function _loop(i) {\n  _model.Heading.registerComputed(\"parseDOM\", \"h\" + i, function (type) {\n    if (i <= type.maxLevel) return {\n      parse: function parse(dom, state) {\n        state.wrapIn(dom, this, { level: i });\n      }\n    };\n  });\n};\n\nfor (var i = 1; i <= 6; i++) {\n  _loop(i);\n}_model.HorizontalRule.register(\"parseDOM\", \"hr\", { parse: \"block\" });\n\n_model.CodeBlock.register(\"parseDOM\", \"pre\", {\n  parse: function parse(dom, state) {\n    var params = dom.firstChild && /^code$/i.test(dom.firstChild.nodeName) && dom.firstChild.getAttribute(\"class\");\n    if (params && /fence/.test(params)) {\n      var found = [],\n          re = /(?:^|\\s)lang-(\\S+)/g,\n          m = undefined;\n      while (m = re.exec(params)) {\n        found.push(m[1]);\n      }params = found.join(\" \");\n    } else {\n      params = null;\n    }\n    var text = dom.textContent;\n    state.insert(this, { params: params }, text ? [state.schema.text(text)] : []);\n  }\n});\n\n_model.BulletList.register(\"parseDOM\", \"ul\", { parse: \"block\" });\n\n_model.OrderedList.register(\"parseDOM\", \"ol\", {\n  parse: function parse(dom, state) {\n    var start = dom.getAttribute(\"start\");\n    var attrs = { order: start ? +start : 1 };\n    state.wrapIn(dom, this, attrs);\n  }\n});\n\n_model.ListItem.register(\"parseDOM\", \"li\", { parse: \"block\" });\n\n_model.HardBreak.register(\"parseDOM\", \"br\", {\n  parse: function parse(_, state) {\n    state.insert(this);\n  }\n});\n\n_model.Image.register(\"parseDOM\", \"img\", {\n  parse: function parse(dom, state) {\n    state.insert(this, {\n      src: dom.getAttribute(\"src\"),\n      title: dom.getAttribute(\"title\") || null,\n      alt: dom.getAttribute(\"alt\") || null\n    });\n  }\n});\n\n// Inline style tokens\n\n_model.LinkMark.register(\"parseDOM\", \"a\", {\n  parse: function parse(dom, state) {\n    state.wrapMark(dom, this.create({ href: dom.getAttribute(\"href\"),\n      title: dom.getAttribute(\"title\") }));\n  },\n\n  selector: \"[href]\"\n});\n\n_model.EmMark.register(\"parseDOM\", \"i\", { parse: \"mark\" });\n_model.EmMark.register(\"parseDOM\", \"em\", { parse: \"mark\" });\n_model.EmMark.register(\"parseDOMStyle\", \"font-style\", {\n  parse: function parse(value, state, inner) {\n    if (value == \"italic\") state.wrapMark(inner, this);else inner();\n  }\n});\n\n_model.StrongMark.register(\"parseDOM\", \"b\", { parse: \"mark\" });\n_model.StrongMark.register(\"parseDOM\", \"strong\", { parse: \"mark\" });\n_model.StrongMark.register(\"parseDOMStyle\", \"font-weight\", {\n  parse: function parse(value, state, inner) {\n    if (value == \"bold\" || value == \"bolder\" || !/\\D/.test(value) && +value >= 500) state.wrapMark(inner, this);else inner();\n  }\n});\n\n_model.CodeMark.register(\"parseDOM\", \"code\", { parse: \"mark\" });\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/format/from_dom.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/format/from_dom.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nvar _node = __webpack_require__(19);\n\nObject.defineProperty(exports, \"Node\", {\n        enumerable: true,\n        get: function get() {\n                return _node.Node;\n        }\n});\n\nvar _resolvedpos = __webpack_require__(25);\n\nObject.defineProperty(exports, \"ResolvedPos\", {\n        enumerable: true,\n        get: function get() {\n                return _resolvedpos.ResolvedPos;\n        }\n});\n\nvar _fragment = __webpack_require__(20);\n\nObject.defineProperty(exports, \"Fragment\", {\n        enumerable: true,\n        get: function get() {\n                return _fragment.Fragment;\n        }\n});\n\nvar _replace = __webpack_require__(23);\n\nObject.defineProperty(exports, \"Slice\", {\n        enumerable: true,\n        get: function get() {\n                return _replace.Slice;\n        }\n});\nObject.defineProperty(exports, \"ReplaceError\", {\n        enumerable: true,\n        get: function get() {\n                return _replace.ReplaceError;\n        }\n});\n\nvar _mark = __webpack_require__(21);\n\nObject.defineProperty(exports, \"Mark\", {\n        enumerable: true,\n        get: function get() {\n                return _mark.Mark;\n        }\n});\n\nvar _schema = __webpack_require__(26);\n\nObject.defineProperty(exports, \"SchemaSpec\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.SchemaSpec;\n        }\n});\nObject.defineProperty(exports, \"Schema\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.Schema;\n        }\n});\nObject.defineProperty(exports, \"NodeType\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.NodeType;\n        }\n});\nObject.defineProperty(exports, \"Block\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.Block;\n        }\n});\nObject.defineProperty(exports, \"Textblock\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.Textblock;\n        }\n});\nObject.defineProperty(exports, \"Inline\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.Inline;\n        }\n});\nObject.defineProperty(exports, \"Text\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.Text;\n        }\n});\nObject.defineProperty(exports, \"MarkType\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.MarkType;\n        }\n});\nObject.defineProperty(exports, \"Attribute\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.Attribute;\n        }\n});\nObject.defineProperty(exports, \"NodeKind\", {\n        enumerable: true,\n        get: function get() {\n                return _schema.NodeKind;\n        }\n});\n\nvar _defaultschema = __webpack_require__(30);\n\nObject.defineProperty(exports, \"defaultSchema\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.defaultSchema;\n        }\n});\nObject.defineProperty(exports, \"Doc\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.Doc;\n        }\n});\nObject.defineProperty(exports, \"BlockQuote\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.BlockQuote;\n        }\n});\nObject.defineProperty(exports, \"OrderedList\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.OrderedList;\n        }\n});\nObject.defineProperty(exports, \"BulletList\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.BulletList;\n        }\n});\nObject.defineProperty(exports, \"ListItem\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.ListItem;\n        }\n});\nObject.defineProperty(exports, \"HorizontalRule\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.HorizontalRule;\n        }\n});\nObject.defineProperty(exports, \"Paragraph\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.Paragraph;\n        }\n});\nObject.defineProperty(exports, \"Heading\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.Heading;\n        }\n});\nObject.defineProperty(exports, \"CodeBlock\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.CodeBlock;\n        }\n});\nObject.defineProperty(exports, \"Image\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.Image;\n        }\n});\nObject.defineProperty(exports, \"HardBreak\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.HardBreak;\n        }\n});\nObject.defineProperty(exports, \"CodeMark\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.CodeMark;\n        }\n});\nObject.defineProperty(exports, \"EmMark\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.EmMark;\n        }\n});\nObject.defineProperty(exports, \"StrongMark\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.StrongMark;\n        }\n});\nObject.defineProperty(exports, \"LinkMark\", {\n        enumerable: true,\n        get: function get() {\n                return _defaultschema.LinkMark;\n        }\n});\n\nvar _content = __webpack_require__(27);\n\nObject.defineProperty(exports, \"ContentMatch\", {\n        enumerable: true,\n        get: function get() {\n                return _content.ContentMatch;\n        }\n});\n\nvar _diff = __webpack_require__(31);\n\nObject.defineProperty(exports, \"findDiffStart\", {\n        enumerable: true,\n        get: function get() {\n                return _diff.findDiffStart;\n        }\n});\nObject.defineProperty(exports, \"findDiffEnd\", {\n        enumerable: true,\n        get: function get() {\n                return _diff.findDiffEnd;\n        }\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/index.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/index.js?");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TextNode = exports.Node = undefined;\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _fragment = __webpack_require__(20);\n\nvar _mark = __webpack_require__(21);\n\nvar _replace2 = __webpack_require__(23);\n\nvar _resolvedpos = __webpack_require__(25);\n\nvar _comparedeep = __webpack_require__(22);\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar emptyArray = [],\n    emptyAttrs = Object.create(null);\n\n// ;; This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Never** directly mutate the properties of a `Node` object. See\n// [this guide](guide/doc.html) for more information.\n\nvar Node = exports.Node = function () {\n  function Node(type, attrs, content, marks) {\n    _classCallCheck(this, Node);\n\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type;\n\n    // :: Object\n    // An object mapping attribute names to string values. The kind of\n    // attributes allowed and required are determined by the node\n    // type.\n    this.attrs = attrs;\n\n    // :: Fragment\n    // The node's content.\n    this.content = content || _fragment.Fragment.empty;\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) associated with this node.\n    this.marks = marks || emptyArray;\n  }\n\n  // :: number\n  // The size of this node. For text node, this is the amount of\n  // characters. For leaf nodes, it is one. And for non-leaf nodes, it\n  // is the size of the content plus two (the start and end token).\n\n\n  _createClass(Node, [{\n    key: \"child\",\n\n\n    // :: (number) → Node\n    // Get the child node at the given index. Raise an error when the\n    // index is out of range.\n    value: function child(index) {\n      return this.content.child(index);\n    }\n\n    // :: (number) → ?Node\n    // Get the child node at the given index, if it exists.\n\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content.maybeChild(index);\n    }\n\n    // :: ((node: Node, offset: number))\n    // Call `f` for every child node, passing the node and its offset\n    // into this parent node.\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.content.forEach(f);\n    }\n\n    // :: string\n    // Concatenate all the text nodes found in this fragment and its\n    // children.\n\n  }, {\n    key: \"eq\",\n\n\n    // :: (Node) → bool\n    // Test whether two nodes represent the same content.\n    value: function eq(other) {\n      return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n\n    // :: (Node) → bool\n    // Compare the markup (type, attributes, and marks) of this node to\n    // those of another. Returns `true` if both have the same markup.\n\n  }, {\n    key: \"sameMarkup\",\n    value: function sameMarkup(other) {\n      return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n\n    // :: (NodeType, ?Object, ?[Mark]) → bool\n    // Check whether this node's markup correspond to the given type,\n    // attributes, and marks.\n\n  }, {\n    key: \"hasMarkup\",\n    value: function hasMarkup(type, attrs, marks) {\n      return this.type == type && (0, _comparedeep.compareDeep)(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && _mark.Mark.sameSet(this.marks, marks || emptyArray);\n    }\n\n    // :: (?Fragment) → Node\n    // Create a new node with the same markup as this node, containing\n    // the given content (or empty, if no content is given).\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      var content = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];\n\n      if (content == this.content) return this;\n      return new this.constructor(this.type, this.attrs, content, this.marks);\n    }\n\n    // :: ([Mark]) → Node\n    // Create a copy of this node, with the given set of marks instead\n    // of the node's own marks.\n\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks);\n    }\n\n    // :: (number, ?number) → Node\n    // Create a copy of this node with only the content between the\n    // given offsets. If `to` is not given, it defaults to the end of\n    // the node.\n\n  }, {\n    key: \"cut\",\n    value: function cut(from, to) {\n      if (from == 0 && to == this.content.size) return this;\n      return this.copy(this.content.cut(from, to));\n    }\n\n    // :: (number, ?number) → Slice\n    // Cut out the part of the document between the given positions, and\n    // return it as a `Slice` object.\n\n  }, {\n    key: \"slice\",\n    value: function slice(from) {\n      var to = arguments.length <= 1 || arguments[1] === undefined ? this.content.size : arguments[1];\n\n      if (from == to) return _replace2.Slice.empty;\n\n      var $from = this.resolve(from),\n          $to = this.resolve(to);\n      var depth = $from.sameDepth($to),\n          start = $from.start(depth),\n          node = $from.node(depth);\n      var content = node.content.cut($from.pos - start, $to.pos - start);\n      return new _replace2.Slice(content, $from.depth - depth, $to.depth - depth, node);\n    }\n\n    // :: (number, number, Slice) → Node\n    // Replace the part of the document between the given positions with\n    // the given slice. The slice must 'fit', meaning its open sides\n    // must be able to connect to the surrounding content, and its\n    // content nodes must be valid children for the node they are placed\n    // into. If any of this is violated, an error of type `ReplaceError`\n    // is thrown.\n\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, slice) {\n      return (0, _replace2.replace)(this.resolve(from), this.resolve(to), slice);\n    }\n\n    // :: (number) → ?Node\n    // Find the node after the given position.\n\n  }, {\n    key: \"nodeAt\",\n    value: function nodeAt(pos) {\n      for (var node = this;;) {\n        var _node$content$findInd = node.content.findIndex(pos);\n\n        var index = _node$content$findInd.index;\n        var offset = _node$content$findInd.offset;\n\n        node = node.maybeChild(index);\n        if (!node) return null;\n        if (offset == pos || node.isText) return node;\n        pos -= offset + 1;\n      }\n    }\n\n    // :: (number) → {node: ?Node, index: number, offset: number}\n    // Find the (direct) child node after the given offset, if any,\n    // and return it along with its index and offset relative to this\n    // node.\n\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      var _content$findIndex = this.content.findIndex(pos);\n\n      var index = _content$findIndex.index;\n      var offset = _content$findIndex.offset;\n\n      return { node: this.content.maybeChild(index), index: index, offset: offset };\n    }\n\n    // :: (number) → {node: ?Node, index: number, offset: number}\n    // Find the (direct) child node before the given offset, if any,\n    // and return it along with its index and offset relative to this\n    // node.\n\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      if (pos == 0) return { node: null, index: 0, offset: 0 };\n\n      var _content$findIndex2 = this.content.findIndex(pos);\n\n      var index = _content$findIndex2.index;\n      var offset = _content$findIndex2.offset;\n\n      if (offset < pos) return { node: this.content.child(index), index: index, offset: offset };\n      var node = this.content.child(index - 1);\n      return { node: node, index: index - 1, offset: offset - node.nodeSize };\n    }\n\n    // :: (?number, ?number, (node: Node, pos: number, parent: Node, index: number))\n    // Iterate over all nodes between the given two positions, calling\n    // the callback with the node, its position, its parent\n    // node, and its index in that node.\n\n  }, {\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var pos = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n\n      this.content.nodesBetween(from, to, f, pos, this);\n    }\n\n    // :: ((node: Node, pos: number, parent: Node))\n    // Call the given callback for every descendant node.\n\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.content.size, f);\n    }\n\n    // :: (number) → ResolvedPos\n    // Resolve the given position in the document, returning an object\n    // describing its path through the document.\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      return _resolvedpos.ResolvedPos.resolveCached(this, pos);\n    }\n  }, {\n    key: \"resolveNoCache\",\n    value: function resolveNoCache(pos) {\n      return _resolvedpos.ResolvedPos.resolve(this, pos);\n    }\n\n    // :: (number) → [Mark]\n    // Get the marks at the given position factoring in the surrounding marks'\n    // inclusiveLeft and inclusiveRight properties. If the position is at the\n    // start of a non-empty node, the marks of the node after it are returned.\n\n  }, {\n    key: \"marksAt\",\n    value: function marksAt(pos) {\n      var $pos = this.resolve(pos),\n          parent = $pos.parent,\n          index = $pos.index();\n\n      // In an empty parent, return the empty array\n      if (parent.content.size == 0) return emptyArray;\n      // When inside a text node or at the start of the parent node, return the node's marks\n      if (index == 0 || !$pos.atNodeBoundary) return parent.child(index).marks;\n\n      var marks = parent.child(index - 1).marks;\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].type.inclusiveRight) marks = marks[i--].removeFromSet(marks);\n      }return marks;\n    }\n\n    // :: (?number, ?number, MarkType) → bool\n    // Test whether a mark of the given type occurs in this document\n    // between the two given positions.\n\n  }, {\n    key: \"rangeHasMark\",\n    value: function rangeHasMark(from, to, type) {\n      var found = false;\n      this.nodesBetween(from, to, function (node) {\n        if (type.isInSet(node.marks)) found = true;\n        return !found;\n      });\n      return found;\n    }\n\n    // :: bool\n    // True when this is a block (non-inline node)\n\n  }, {\n    key: \"toString\",\n\n\n    // :: () → string\n    // Return a string representation of this node for debugging\n    // purposes.\n    value: function toString() {\n      var name = this.type.name;\n      if (this.content.size) name += \"(\" + this.content.toStringInner() + \")\";\n      return wrapMarks(this.marks, name);\n    }\n\n    // :: (number) → ContentMatch\n    // Get the content match in this node at the given index.\n\n  }, {\n    key: \"contentMatchAt\",\n    value: function contentMatchAt(index) {\n      return this.type.contentExpr.getMatchAt(this.attrs, this.content, index);\n    }\n\n    // :: (number, number, ?Fragment, ?number, ?number) → bool\n    // Test whether replacing the range `from` to `to` (by index) with\n    // the given replacement fragment (which defaults to the empty\n    // fragment) would leave the node's content valid. You can\n    // optionally pass `start` and `end` indices into the replacement\n    // fragment.\n\n  }, {\n    key: \"canReplace\",\n    value: function canReplace(from, to, replacement, start, end) {\n      return this.type.contentExpr.checkReplace(this.attrs, this.content, from, to, replacement, start, end);\n    }\n\n    // :: (number, number, NodeType, ?[Mark]) → bool\n    // Test whether replacing the range `from` to `to` (by index) with a\n    // node of the given type and marks would be valid.\n\n  }, {\n    key: \"canReplaceWith\",\n    value: function canReplaceWith(from, to, type, attrs, marks) {\n      return this.type.contentExpr.checkReplaceWith(this.attrs, this.content, from, to, type, attrs, marks || emptyArray);\n    }\n\n    // :: (Node) → bool\n    // Test whether the given node's content could be appended to this\n    // node. If that node is empty, this will only return true if there\n    // is at least one node type that can appear in both nodes (to avoid\n    // merging completely incompatible nodes).\n\n  }, {\n    key: \"canAppend\",\n    value: function canAppend(other) {\n      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);\n    }\n  }, {\n    key: \"defaultContentType\",\n    value: function defaultContentType(at) {\n      return this.contentMatchAt(at).element.defaultType();\n    }\n\n    // :: () → Object\n    // Return a JSON-serializeable representation of this node.\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = { type: this.type.name };\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      if (this.content.size) obj.content = this.content.toJSON();\n      if (this.marks.length) obj.marks = this.marks.map(function (n) {\n        return n.toJSON();\n      });\n      return obj;\n    }\n\n    // :: (Schema, Object) → Node\n    // Deserialize a node from its JSON representation.\n\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.type.isLeaf ? 1 : 2 + this.content.size;\n    }\n\n    // :: number\n    // The number of children that the node has.\n\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.childCount;\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.content.textContent;\n    }\n\n    // :: ?Node\n    // Returns this node's first child, or `null` if there are no\n    // children.\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.firstChild;\n    }\n\n    // :: ?Node\n    // Returns this node's last child, or `null` if there are no\n    // children.\n\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.lastChild;\n    }\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      return this.type.isBlock;\n    }\n\n    // :: bool\n    // True when this is a textblock node, a block node with inline\n    // content.\n\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.type.isTextblock;\n    }\n\n    // :: bool\n    // True when this is an inline node (a text node or a node that can\n    // appear among text).\n\n  }, {\n    key: \"isInline\",\n    get: function get() {\n      return this.type.isInline;\n    }\n\n    // :: bool\n    // True when this is a text node.\n\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type.isText;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      var type = schema.nodeType(json.type);\n      var content = json.text != null ? json.text : _fragment.Fragment.fromJSON(schema, json.content);\n      return type.create(json.attrs, content, json.marks && json.marks.map(schema.markFromJSON));\n    }\n  }]);\n\n  return Node;\n}();\n\n// ;; #forward=Node\n\n\nvar TextNode = exports.TextNode = function (_Node) {\n  _inherits(TextNode, _Node);\n\n  function TextNode(type, attrs, content, marks) {\n    _classCallCheck(this, TextNode);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TextNode).call(this, type, attrs, null, marks));\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\");\n\n    // :: ?string\n    // For text nodes, this contains the node's text content.\n    _this.text = content;\n    return _this;\n  }\n\n  _createClass(TextNode, [{\n    key: \"toString\",\n    value: function toString() {\n      return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return new TextNode(this.type, this.attrs, this.text, marks);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut() {\n      var from = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n      var to = arguments.length <= 1 || arguments[1] === undefined ? this.text.length : arguments[1];\n\n      if (from == 0 && to == this.text.length) return this;\n      return this.copy(this.text.slice(from, to));\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.sameMarkup(other) && this.text == other.text;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var base = _get(Object.getPrototypeOf(TextNode.prototype), \"toJSON\", this).call(this);\n      base.text = this.text;\n      return base;\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.text;\n    }\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.text.length;\n    }\n  }]);\n\n  return TextNode;\n}(Node);\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--) {\n    str = marks[i].type.name + \"(\" + str + \")\";\n  }return str;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/node.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/node.js?");

/***/ },
/* 20 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; Fragment is the type used to represent a node's collection of\n// child nodes.\n//\n// Fragments are persistent data structures. That means you should\n// _not_ mutate them or their content, but create new instances\n// whenever needed. The API tries to make this easy.\n\nvar Fragment = exports.Fragment = function () {\n  function Fragment(content, size) {\n    _classCallCheck(this, Fragment);\n\n    this.content = content;\n    this.size = size || 0;\n    if (size == null) for (var i = 0; i < content.length; i++) {\n      this.size += content[i].nodeSize;\n    }\n  }\n\n  // :: string\n  // Concatenate all the text nodes found in this fragment and its\n  // children.\n\n\n  _createClass(Fragment, [{\n    key: \"toString\",\n\n\n    // :: () → string\n    // Return a debugging string that describes this fragment.\n    value: function toString() {\n      return \"<\" + this.toStringInner() + \">\";\n    }\n  }, {\n    key: \"toStringInner\",\n    value: function toStringInner() {\n      return this.content.join(\", \");\n    }\n  }, {\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f, nodeStart, parent) {\n      for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n            end = pos + child.nodeSize;\n        if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n          var start = pos + 1;\n          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n        }\n        pos = end;\n      }\n    }\n\n    // :: (number, ?number) → Fragment\n    // Cut out the sub-fragment between the two given positions.\n\n  }, {\n    key: \"cut\",\n    value: function cut(from, to) {\n      if (to == null) to = this.size;\n      if (from == 0 && to == this.size) return this;\n      var result = [],\n          size = 0;\n      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n            end = pos + child.nodeSize;\n        if (end > from) {\n          if (pos < from || end > to) {\n            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n          result.push(child);\n          size += child.nodeSize;\n        }\n        pos = end;\n      }\n      return new Fragment(result, size);\n    }\n  }, {\n    key: \"cutByIndex\",\n    value: function cutByIndex(from, to) {\n      if (from == to) return Fragment.empty;\n      if (from == 0 && to == this.content.length) return this;\n      return new Fragment(this.content.slice(from, to));\n    }\n\n    // :: (Fragment) → Fragment\n    // Create a new fragment containing the content of this fragment and\n    // `other`.\n\n  }, {\n    key: \"append\",\n    value: function append(other) {\n      if (!other.size) return this;\n      if (!this.size) return other;\n      var last = this.lastChild,\n          first = other.firstChild,\n          content = this.content.slice(),\n          i = 0;\n      if (last.isText && last.sameMarkup(first)) {\n        content[content.length - 1] = last.copy(last.text + first.text);\n        i = 1;\n      }\n      for (; i < other.content.length; i++) {\n        content.push(other.content[i]);\n      }return new Fragment(content, this.size + other.size);\n    }\n\n    // :: (number, Node) → Fragment\n    // Create a new fragment in which the node at the given index is\n    // replaced by the given node.\n\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(index, node) {\n      var current = this.content[index];\n      if (current == node) return this;\n      var copy = this.content.slice();\n      var size = this.size + node.nodeSize - current.nodeSize;\n      copy[index] = node;\n      return new Fragment(copy, size);\n    }\n\n    // (Node) → Fragment\n    // Create a new fragment by prepending the given node to this\n    // fragment.\n\n  }, {\n    key: \"addToStart\",\n    value: function addToStart(node) {\n      return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n\n    // (Node) → Fragment\n    // Create a new fragment by appending the given node to this\n    // fragment.\n\n  }, {\n    key: \"addToEnd\",\n    value: function addToEnd(node) {\n      return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n\n    // :: () → ?Object\n    // Create a JSON-serializeable representation of this fragment.\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.content.length ? this.content.map(function (n) {\n        return n.toJSON();\n      }) : null;\n    }\n\n    // :: (Schema, ?Object) → Fragment\n    // Deserialize a fragment from its JSON representation.\n\n  }, {\n    key: \"eq\",\n\n\n    // :: (Fragment) → bool\n    // Compare this fragment to another one.\n    value: function eq(other) {\n      if (this.content.length != other.content.length) return false;\n      for (var i = 0; i < this.content.length; i++) {\n        if (!this.content[i].eq(other.content[i])) return false;\n      }return true;\n    }\n\n    // :: (?union<Fragment, Node, [Node]>) → Fragment\n    // Create a fragment from something that can be interpreted as a set\n    // of nodes. For `null`, it returns the empty fragment. For a\n    // fragment, the fragment itself. For a node or array of nodes, a\n    // fragment containing those nodes.\n\n  }, {\n    key: \"child\",\n\n\n    // :: (number) → Node\n    // Get the child node at the given index. Raise an error when the\n    // index is out of range.\n    value: function child(index) {\n      var found = this.content[index];\n      if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n      return found;\n    }\n\n    // :: (number) → ?Node\n    // Get the child node at the given index, if it exists.\n\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content[index];\n    }\n\n    // :: ((node: Node, offset: number))\n    // Call `f` for every child node, passing the node and its offset\n    // into this parent node.\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var i = 0, p = 0; i < this.content.length; i++) {\n        var child = this.content[i];\n        f(child, p);\n        p += child.nodeSize;\n      }\n    }\n\n    // : (number, ?number) → {index: number, offset: number}\n    // Find the index and inner offset corresponding to a given relative\n    // position in this fragment. The result object will be reused\n    // (overwritten) the next time the function is called. (Not public.)\n\n  }, {\n    key: \"findIndex\",\n    value: function findIndex(pos) {\n      var round = arguments.length <= 1 || arguments[1] === undefined ? -1 : arguments[1];\n\n      if (pos == 0) return retIndex(0, pos);\n      if (pos == this.size) return retIndex(this.content.length, pos);\n      if (pos > this.size || pos < 0) throw new RangeError(\"Position \" + pos + \" outside of fragment (\" + this + \")\");\n      for (var i = 0, curPos = 0;; i++) {\n        var cur = this.child(i),\n            end = curPos + cur.nodeSize;\n        if (end >= pos) {\n          if (end == pos || round > 0) return retIndex(i + 1, end);\n          return retIndex(i, curPos);\n        }\n        curPos = end;\n      }\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      var text = \"\";\n      this.content.forEach(function (n) {\n        return text += n.textContent;\n      });\n      return text;\n    }\n  }, {\n    key: \"firstChild\",\n\n\n    // :: ?Node\n    // The first child of the fragment, or `null` if it is empty.\n    get: function get() {\n      return this.content.length ? this.content[0] : null;\n    }\n\n    // :: ?Node\n    // The last child of the fragment, or `null` if it is empty.\n\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n\n    // :: number\n    // The number of child nodes in this fragment.\n\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.length;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, value) {\n      return value ? new Fragment(value.map(schema.nodeFromJSON)) : Fragment.empty;\n    }\n\n    // :: ([Node]) → Fragment\n    // Build a fragment from an array of nodes. Ensures that adjacent\n    // text nodes with the same style are joined together.\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      if (!array.length) return Fragment.empty;\n      var joined = undefined,\n          size = 0;\n      for (var i = 0; i < array.length; i++) {\n        var node = array[i];\n        size += node.nodeSize;\n        if (i && node.isText && array[i - 1].sameMarkup(node)) {\n          if (!joined) joined = array.slice(0, i);\n          joined[joined.length - 1] = node.copy(joined[joined.length - 1].text + node.text);\n        } else if (joined) {\n          joined.push(node);\n        }\n      }\n      return new Fragment(joined || array, size);\n    }\n  }, {\n    key: \"from\",\n    value: function from(nodes) {\n      if (!nodes) return Fragment.empty;\n      if (nodes instanceof Fragment) return nodes;\n      if (Array.isArray(nodes)) return this.fromArray(nodes);\n      return new Fragment([nodes], nodes.nodeSize);\n    }\n  }]);\n\n  return Fragment;\n}();\n\nvar found = { index: 0, offset: 0 };\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/fragment.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/fragment.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Mark = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _comparedeep = __webpack_require__(22);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\n\nvar Mark = exports.Mark = function () {\n  function Mark(type, attrs) {\n    _classCallCheck(this, Mark);\n\n    // :: MarkType\n    // The type of this mark.\n    this.type = type;\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs;\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n\n\n  _createClass(Mark, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = { _: this.type.name };\n      for (var attr in this.attrs) {\n        obj[attr] = this.attrs[attr];\n      }return obj;\n    }\n\n    // :: ([Mark]) → [Mark]\n    // Given a set of marks, create a new set which contains this one as\n    // well, in the right position. If this mark or another of its type\n    // is already in the set, the set itself is returned.\n\n  }, {\n    key: \"addToSet\",\n    value: function addToSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        var other = set[i];\n        if (other.type == this.type) {\n          if (this.eq(other)) return set;\n          var copy = set.slice();\n          copy[i] = this;\n          return copy;\n        }\n        if (other.type.rank > this.type.rank) return set.slice(0, i).concat(this).concat(set.slice(i));\n      }\n      return set.concat(this);\n    }\n\n    // :: ([Mark]) → [Mark]\n    // Remove this mark from the given set, returning a new set. If this\n    // mark is not in the set, the set itself is returned.\n\n  }, {\n    key: \"removeFromSet\",\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));\n      }return set;\n    }\n\n    // :: ([Mark]) → bool\n    // Test whether this mark is in the given set of marks.\n\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        if (this.eq(set[i])) return true;\n      }return false;\n    }\n\n    // :: (Mark) → bool\n    // Test whether this mark has the same type and attributes as\n    // another mark.\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (this == other) return true;\n      if (this.type != other.type) return false;\n      if (!(0, _comparedeep.compareDeep)(other.attrs, this.attrs)) return false;\n      return true;\n    }\n\n    // :: ([Mark], [Mark]) → bool\n    // Test whether two sets of marks are identical.\n\n  }], [{\n    key: \"sameSet\",\n    value: function sameSet(a, b) {\n      if (a == b) return true;\n      if (a.length != b.length) return false;\n      for (var i = 0; i < a.length; i++) {\n        if (!a[i].eq(b[i])) return false;\n      }return true;\n    }\n\n    // :: (?union<Mark, [Mark]>) → [Mark]\n    // Create a properly sorted mark set from null, a single mark, or an\n    // unsorted array of marks.\n\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(marks) {\n      if (!marks || marks.length == 0) return empty;\n      if (marks instanceof Mark) return [marks];\n      var copy = marks.slice();\n      copy.sort(function (a, b) {\n        return a.type.rank - b.type.rank;\n      });\n      return copy;\n    }\n  }]);\n\n  return Mark;\n}();\n\nvar empty = [];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/mark.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/mark.js?");

/***/ },
/* 22 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.compareDeep = compareDeep;\nfunction compareDeep(a, b) {\n  if (a === b) return true;\n  if (!(a && (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) == \"object\") || !(b && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) == \"object\")) return false;\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) return false;\n  if (array) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++) {\n      if (!compareDeep(a[i], b[i])) return false;\n    }\n  } else {\n    for (var p in a) {\n      if (!(p in b) || !compareDeep(a[p], b[p])) return false;\n    }for (var p in b) {\n      if (!(p in a)) return false;\n    }\n  }\n  return true;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/util/comparedeep.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/util/comparedeep.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Slice = exports.ReplaceError = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.replace = replace;\n\nvar _error = __webpack_require__(24);\n\nvar _fragment = __webpack_require__(20);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// ;; Error type raised by `Node.replace` when given an invalid\n// replacement.\n\nvar ReplaceError = exports.ReplaceError = function (_ProseMirrorError) {\n  _inherits(ReplaceError, _ProseMirrorError);\n\n  function ReplaceError() {\n    _classCallCheck(this, ReplaceError);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(ReplaceError).apply(this, arguments));\n  }\n\n  return ReplaceError;\n}(_error.ProseMirrorError);\n\n// ;; A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are 'open' / cut through.\n\n\nvar Slice = exports.Slice = function () {\n  // :: (Fragment, number, number, ?Node)\n\n  function Slice(content, openLeft, openRight, possibleParent) {\n    _classCallCheck(this, Slice);\n\n    // :: Fragment The slice's content nodes.\n    this.content = content;\n    // :: number The open depth at the start.\n    this.openLeft = openLeft;\n    // :: number The open depth at the end.\n    this.openRight = openRight;\n    this.possibleParent = possibleParent;\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n\n\n  _createClass(Slice, [{\n    key: \"insertAt\",\n    value: function insertAt(pos, fragment) {\n      function insertInto(content, dist, insert) {\n        var _content$findIndex = content.findIndex(dist);\n\n        var index = _content$findIndex.index;\n        var offset = _content$findIndex.offset;var child = content.maybeChild(index);\n        if (offset == dist || child.isText) return content.cut(0, dist).append(insert).append(content.cut(dist));\n        var inner = insertInto(child.content, dist - offset - 1, insert);\n        if (!inner || offset + child.nodeSize > dist && !child.type.contentExpr.matches(child.attrs, inner)) return null;\n        return content.replaceChild(index, child.copy(inner));\n      }\n      var content = insertInto(this.content, pos + this.openLeft, fragment);\n      return content && new Slice(content, this.openLeft, this.openRight);\n    }\n  }, {\n    key: \"removeBetween\",\n    value: function removeBetween(from, to) {\n      function removeRange(content, from, to) {\n        var _content$findIndex2 = content.findIndex(from);\n\n        var index = _content$findIndex2.index;\n        var offset = _content$findIndex2.offset;var child = content.maybeChild(index);\n\n        var _content$findIndex3 = content.findIndex(to);\n\n        var indexTo = _content$findIndex3.index;\n        var offsetTo = _content$findIndex3.offset;\n\n        if (offset == from || child.isText) {\n          if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\");\n          return content.cut(0, from).append(content.cut(to));\n        }\n        if (index != indexTo) throw new RangeError(\"Removing non-flat range\");\n        return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n      }\n      return new Slice(removeRange(this.content, from + this.openLeft, to + this.openLeft), this.openLeft, this.openRight);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.content + \"(\" + this.openLeft + \",\" + this.openRight + \")\";\n    }\n\n    // :: () → ?Object\n    // Convert a slice to a JSON-serializable representation.\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (!this.content.size) return null;\n      return { content: this.content.toJSON(),\n        openLeft: this.openLeft,\n        openRight: this.openRight };\n    }\n\n    // :: (Schema, ?Object) → Slice\n    // Deserialize a slice from its JSON representation.\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.content.size - this.openLeft - this.openRight;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) return Slice.empty;\n      return new Slice(_fragment.Fragment.fromJSON(schema, json.content), json.openLeft, json.openRight);\n    }\n  }]);\n\n  return Slice;\n}();\n\n// :: Slice\n// The empty slice.\n\n\nSlice.empty = new Slice(_fragment.Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openLeft > $from.depth) throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  if ($from.depth - slice.openLeft != $to.depth - slice.openRight) throw new ReplaceError(\"Inconsistent open depths\");\n  return replaceOuter($from, $to, slice, 0);\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth),\n      node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openLeft) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (slice.content.size) {\n    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from);\n\n    var start = _prepareSliceForRepla.start;\n    var end = _prepareSliceForRepla.end;\n\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  } else {\n    return close(node, replaceTwoWay($from, $to, depth));\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.copy(target[last].text + child.text);else target.push(child);\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0,\n      endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if (!$start.atNodeBoundary) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) {\n    addNode(node.child(i), target);\n  }if ($end && $end.depth == depth && !$end.atNodeBoundary) addNode($end.nodeBefore, target);\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content, node.attrs)) throw new ReplaceError(\"Invalid content for node \" + node.type.name);\n  return node.copy(content);\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openLeft = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openRight = $to.depth > depth && joinable($end, $to, depth + 1);\n\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openLeft && openRight && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openLeft, openRight);\n    addNode(close(openLeft, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openLeft) addNode(close(openLeft, replaceTwoWay($from, $start, depth + 1)), content);\n    addRange($start, $end, depth, content);\n    if (openRight) addNode(close(openRight, replaceTwoWay($end, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new _fragment.Fragment(content);\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new _fragment.Fragment(content);\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openLeft,\n      parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--) {\n    node = $along.node(i).copy(_fragment.Fragment.from(node));\n  }return { start: node.resolveNoCache(slice.openLeft + extra),\n    end: node.resolveNoCache(node.content.size - slice.openRight - extra) };\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/replace.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/replace.js?");

/***/ },
/* 24 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProseMirrorError = ProseMirrorError;\n// ;; Superclass for ProseMirror-related errors. Does some magic to\n// make it safely subclassable even on ES5 runtimes.\nfunction ProseMirrorError(message) {\n  Error.call(this, message);\n  if (this.message != message) {\n    this.message = message;\n    if (Error.captureStackTrace) Error.captureStackTrace(this, this.name);else this.stack = new Error(message).stack;\n  }\n}\n\nProseMirrorError.prototype = Object.create(Error.prototype);\n\nProseMirrorError.prototype.constructor = ProseMirrorError;\n\nObject.defineProperty(ProseMirrorError.prototype, \"name\", {\n  get: function get() {\n    return this.constructor.name || functionName(this.constructor) || \"ProseMirrorError\";\n  }\n});\n\nfunction functionName(f) {\n  var match = /^function (\\w+)/.exec(f.toString());\n  return match && match[1];\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/util/error.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/util/error.js?");

/***/ },
/* 25 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; The usual way to represent positions in a document is with a\n// plain integer. Since those tell you very little about the context\n// of that position, you'll often have to 'resolve' a position to get\n// the context you need. Objects of this class represent such a\n// resolved position, providing various pieces of context information\n// and helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\n\nvar ResolvedPos = exports.ResolvedPos = function () {\n  function ResolvedPos(pos, path, parentOffset) {\n    _classCallCheck(this, ResolvedPos);\n\n    // :: number The position that was resolved.\n    this.pos = pos;\n    this.path = path;\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root, it is 0. If it points\n    // into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1;\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset;\n  }\n\n  _createClass(ResolvedPos, [{\n    key: \"resolveDepth\",\n    value: function resolveDepth(val) {\n      if (val == null) return this.depth;\n      if (val < 0) return this.depth + val;\n      return val;\n    }\n\n    // :: Node\n    // The parent node that the position points into. Note that even if\n    // a position points into a text node, that node is not considered\n    // the parent—text nodes are 'flat' in this model.\n\n  }, {\n    key: \"node\",\n\n\n    // :: (?number) → Node\n    // The ancestor node at the given level. `p.node(p.depth)` is the\n    // same as `p.parent`.\n    value: function node(depth) {\n      return this.path[this.resolveDepth(depth) * 3];\n    }\n\n    // :: (?number) → number\n    // The index into the ancestor at the given level. If this points at\n    // the 3rd node in the 2nd paragraph on the top level, for example,\n    // `p.index(0)` is 2 and `p.index(1)` is 3.\n\n  }, {\n    key: \"index\",\n    value: function index(depth) {\n      return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n\n    // :: (?number) → number\n    // The index pointing after this position into the ancestor at the\n    // given level.\n\n  }, {\n    key: \"indexAfter\",\n    value: function indexAfter(depth) {\n      depth = this.resolveDepth(depth);\n      return this.index(depth) + (depth == this.depth && this.atNodeBoundary ? 0 : 1);\n    }\n\n    // :: (?number) → number\n    // The (absolute) position at the start of the node at the given\n    // level.\n\n  }, {\n    key: \"start\",\n    value: function start(depth) {\n      depth = this.resolveDepth(depth);\n      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n\n    // :: (?number) → number\n    // The (absolute) position at the end of the node at the given\n    // level.\n\n  }, {\n    key: \"end\",\n    value: function end(depth) {\n      depth = this.resolveDepth(depth);\n      return this.start(depth) + this.node(depth).content.size;\n    }\n\n    // :: (?number) → number\n    // The (absolute) position directly before the node at the given\n    // level, or, when `level` is `this.level + 1`, the original\n    // position.\n\n  }, {\n    key: \"before\",\n    value: function before(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position before the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n\n    // :: (?number) → number\n    // The (absolute) position directly after the node at the given\n    // level, or, when `level` is `this.level + 1`, the original\n    // position.\n\n  }, {\n    key: \"after\",\n    value: function after(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position after the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n\n    // :: bool\n    // True if this position points at a node boundary, false if it\n    // points into a text node.\n\n  }, {\n    key: \"sameDepth\",\n\n\n    // :: (ResolvedPos) → number\n    // The depth up to which this position and the other share the same\n    // parent nodes.\n    value: function sameDepth(other) {\n      var depth = 0,\n          max = Math.min(this.depth, other.depth);\n      while (depth < max && this.index(depth) == other.index(depth)) {\n        ++depth;\n      }return depth;\n    }\n\n    // :: (ResolvedPos) → bool\n    // Query whether the given position shares the same parent node.\n\n  }, {\n    key: \"sameParent\",\n    value: function sameParent(other) {\n      return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var str = \"\";\n      for (var i = 1; i <= this.depth; i++) {\n        str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n      }return str + \":\" + this.parentOffset;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.node(this.depth);\n    }\n  }, {\n    key: \"atNodeBoundary\",\n    get: function get() {\n      return this.path[this.path.length - 1] == this.pos;\n    }\n\n    // :: ?Node\n    // Get the node directly after the position, if any. If the position\n    // points into a text node, only the part of that node after the\n    // position is returned.\n\n  }, {\n    key: \"nodeAfter\",\n    get: function get() {\n      var parent = this.parent,\n          index = this.index(this.depth);\n      if (index == parent.childCount) return null;\n      var dOff = this.pos - this.path[this.path.length - 1],\n          child = parent.child(index);\n      return dOff ? parent.child(index).cut(dOff) : child;\n    }\n\n    // :: ?Node\n    // Get the node directly before the position, if any. If the\n    // position points into a text node, only the part of that node\n    // before the position is returned.\n\n  }, {\n    key: \"nodeBefore\",\n    get: function get() {\n      var index = this.index(this.depth);\n      var dOff = this.pos - this.path[this.path.length - 1];\n      if (dOff) return this.parent.child(index).cut(0, dOff);\n      return index == 0 ? null : this.parent.child(index - 1);\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(doc, pos) {\n      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\");\n      var path = [];\n      var start = 0,\n          parentOffset = pos;\n      for (var node = doc;;) {\n        var _node$content$findInd = node.content.findIndex(parentOffset);\n\n        var index = _node$content$findInd.index;\n        var offset = _node$content$findInd.offset;\n\n        var rem = parentOffset - offset;\n        path.push(node, index, start + offset);\n        if (!rem) break;\n        node = node.child(index);\n        if (node.isText) break;\n        parentOffset = rem - 1;\n        start += offset + 1;\n      }\n      return new ResolvedPos(pos, path, parentOffset);\n    }\n  }, {\n    key: \"resolveCached\",\n    value: function resolveCached(doc, pos) {\n      for (var i = 0; i < resolveCache.length; i++) {\n        var cached = resolveCache[i];\n        if (cached.pos == pos && cached.node(0) == doc) return cached;\n      }\n      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n      return result;\n    }\n  }]);\n\n  return ResolvedPos;\n}();\n\nvar resolveCache = [],\n    resolveCachePos = 0,\n    resolveCacheSize = 6;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/resolvedpos.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/resolvedpos.js?");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Schema = exports.MarkType = exports.Attribute = exports.Text = exports.Inline = exports.Textblock = exports.Block = exports.NodeType = undefined;\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _node = __webpack_require__(19);\n\nvar _fragment = __webpack_require__(20);\n\nvar _mark = __webpack_require__(21);\n\nvar _content = __webpack_require__(27);\n\nvar _obj = __webpack_require__(28);\n\nvar _orderedmap = __webpack_require__(29);\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; The [node](#NodeType) and [mark](#MarkType) types\n// that make up a schema have several things in common—they support\n// attributes, and you can [register](#SchemaItem.register) values\n// with them. This class implements this functionality, and acts as a\n// superclass to those `NodeType` and `MarkType`.\n\nvar SchemaItem = function () {\n  function SchemaItem() {\n    _classCallCheck(this, SchemaItem);\n  }\n\n  _createClass(SchemaItem, [{\n    key: \"getDefaultAttrs\",\n\n\n    // For node types where all attrs have a default value (or which don't\n    // have any attributes), build up a single reusable default attribute\n    // object, and use it for all nodes that don't specify specific\n    // attributes.\n    value: function getDefaultAttrs() {\n      var defaults = Object.create(null);\n      for (var attrName in this.attrs) {\n        var attr = this.attrs[attrName];\n        if (attr.default === undefined) return null;\n        defaults[attrName] = attr.default;\n      }\n      return defaults;\n    }\n  }, {\n    key: \"computeAttrs\",\n    value: function computeAttrs(attrs) {\n      var built = Object.create(null);\n      for (var name in this.attrs) {\n        var value = attrs && attrs[name];\n        if (value == null) {\n          var attr = this.attrs[name];\n          if (attr.default !== undefined) value = attr.default;else if (attr.compute) value = attr.compute(this);else throw new RangeError(\"No value supplied for attribute \" + name);\n        }\n        built[name] = value;\n      }\n      return built;\n    }\n  }, {\n    key: \"freezeAttrs\",\n    value: function freezeAttrs() {\n      var frozen = Object.create(null);\n      for (var name in this.attrs) {\n        frozen[name] = this.attrs[name];\n      }Object.defineProperty(this, \"attrs\", { value: frozen });\n    }\n  }, {\n    key: \"attrs\",\n\n    // :: Object<Attribute>\n    // The set of attributes to associate with each node or mark of this\n    // type.\n    get: function get() {\n      return {};\n    }\n\n    // :: (Object<?Attribute>)\n    // Add or remove attributes from this type. Expects an object\n    // mapping names to either attributes (to add) or null (to remove\n    // the attribute by that name).\n\n  }], [{\n    key: \"updateAttrs\",\n    value: function updateAttrs(attrs) {\n      Object.defineProperty(this.prototype, \"attrs\", { value: overlayObj(this.prototype.attrs, attrs) });\n    }\n  }, {\n    key: \"getRegistry\",\n    value: function getRegistry() {\n      if (this == SchemaItem) return null;\n      if (!this.prototype.hasOwnProperty(\"registry\")) this.prototype.registry = Object.create(Object.getPrototypeOf(this).getRegistry());\n      return this.prototype.registry;\n    }\n  }, {\n    key: \"getNamespace\",\n    value: function getNamespace(name) {\n      if (this == SchemaItem) return null;\n      var reg = this.getRegistry();\n      if (!Object.prototype.hasOwnProperty.call(reg, name)) reg[name] = Object.create(Object.getPrototypeOf(this).getNamespace(name));\n      return reg[name];\n    }\n\n    // :: (string, string, *)\n    // Register a value in this type's registry. Various components use\n    // `Schema.registry` to query values from the marks and nodes that\n    // make up the schema. The `namespace`, for example\n    // [`\"command\"`](#commands), determines which component will see\n    // this value. `name` is a name specific to this value. Its meaning\n    // differs per namespace.\n    //\n    // Subtypes inherit the registered values from their supertypes.\n    // They can override individual values by calling this method to\n    // overwrite them with a new value, or with `null` to disable them.\n\n  }, {\n    key: \"register\",\n    value: function register(namespace, name, value) {\n      this.getNamespace(namespace)[name] = function () {\n        return value;\n      };\n    }\n\n    // :: (string, string, (SchemaItem) → *)\n    // Register a value in this types's registry, like\n    // [`register`](#SchemaItem.register), but providing a function that\n    // will be called with the actual node or mark type, whose return\n    // value will be treated as the effective value (or will be ignored,\n    // if `null`).\n\n  }, {\n    key: \"registerComputed\",\n    value: function registerComputed(namespace, name, f) {\n      this.getNamespace(namespace)[name] = f;\n    }\n\n    // :: (string)\n    // By default, schema items inherit the\n    // [registered](#SchemaItem.register) items from their superclasses.\n    // Call this to disable that behavior for the given namespace.\n\n  }, {\n    key: \"cleanNamespace\",\n    value: function cleanNamespace(namespace) {\n      this.getNamespace(namespace).__proto__ = null;\n    }\n  }]);\n\n  return SchemaItem;\n}();\n\nfunction overlayObj(base, update) {\n  var copy = (0, _obj.copyObj)(base);\n  for (var name in update) {\n    var value = update[name];\n    if (value == null) delete copy[name];else copy[name] = value;\n  }\n  return copy;\n}\n\n// ;; Node types are objects allocated once per `Schema`\n// and used to tag `Node` instances with a type. They are\n// instances of sub-types of this class, and contain information about\n// the node type (its name, its allowed attributes, methods for\n// serializing it to various formats, information to guide\n// deserialization, and so on).\n\nvar NodeType = exports.NodeType = function (_SchemaItem) {\n  _inherits(NodeType, _SchemaItem);\n\n  function NodeType(name, schema) {\n    _classCallCheck(this, NodeType);\n\n    // :: string\n    // The name the node type has in this schema.\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NodeType).call(this));\n\n    _this.name = name;\n    // Freeze the attributes, to avoid calling a potentially expensive\n    // getter all the time.\n    _this.freezeAttrs();\n    _this.defaultAttrs = _this.getDefaultAttrs();\n    _this.contentExpr = null;\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    _this.schema = schema;\n    return _this;\n  }\n\n  // :: bool\n  // True if this is a block type.\n\n\n  _createClass(NodeType, [{\n    key: \"hasRequiredAttrs\",\n    value: function hasRequiredAttrs(ignore) {\n      for (var n in this.attrs) {\n        if (this.attrs[n].isRequired && (!ignore || !(n in ignore))) return true;\n      }return false;\n    }\n  }, {\n    key: \"compatibleContent\",\n    value: function compatibleContent(other) {\n      return this == other || this.contentExpr.compatible(other.contentExpr);\n    }\n  }, {\n    key: \"computeAttrs\",\n    value: function computeAttrs(attrs) {\n      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _get(Object.getPrototypeOf(NodeType.prototype), \"computeAttrs\", this).call(this, attrs);\n    }\n\n    // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n    // Create a `Node` of this type. The given attributes are\n    // checked and defaulted (you can pass `null` to use the type's\n    // defaults entirely, if no required attributes exist). `content`\n    // may be a `Fragment`, a node, an array of nodes, or\n    // `null`. Similarly `marks` may be `null` to default to the empty\n    // set of marks.\n\n  }, {\n    key: \"create\",\n    value: function create(attrs, content, marks) {\n      return new _node.Node(this, this.computeAttrs(attrs), _fragment.Fragment.from(content), _mark.Mark.setFrom(marks));\n    }\n\n    // :: (Fragment, ?Object) → bool\n    // Returns true if the given fragment is valid content for this node\n    // type.\n\n  }, {\n    key: \"validContent\",\n    value: function validContent(content, attrs) {\n      return this.contentExpr.matches(attrs, content);\n    }\n\n    // :: (Fragment, ?Object) → ?Fragment\n    // Verify whether the given fragment would be valid content for this\n    // node type, and if not, try to insert content before and/or after\n    // it to make it valid. Returns null if no valid fragment could be\n    // created.\n\n  }, {\n    key: \"fixContent\",\n    value: function fixContent(content, attrs) {\n      var before = this.contentExpr.start(attrs).fillBefore(content);\n      if (!before) return null;\n      content = before.append(content);\n      var after = this.contentExpr.getMatchAt(attrs, content).fillBefore(_fragment.Fragment.empty, true);\n      if (!after) return;\n      return content.append(after);\n    }\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      return false;\n    }\n\n    // :: bool\n    // True if this is a textblock type, a block that contains inline\n    // content.\n\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return false;\n    }\n\n    // :: bool\n    // True if this is an inline type.\n\n  }, {\n    key: \"isInline\",\n    get: function get() {\n      return false;\n    }\n\n    // :: bool\n    // True if this is the text node type.\n\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return false;\n    }\n\n    // :: bool\n    // Controls whether nodes of this type can be selected (as a user\n    // node selection).\n\n  }, {\n    key: \"selectable\",\n    get: function get() {\n      return true;\n    }\n\n    // :: bool\n    // Determines whether nodes of this type can be dragged. Enabling it\n    // causes ProseMirror to set a `draggable` attribute on its DOM\n    // representation, and to put its HTML serialization into the drag\n    // event's [data\n    // transfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)\n    // when dragged.\n\n  }, {\n    key: \"draggable\",\n    get: function get() {\n      return false;\n    }\n\n    // :: bool\n    // Controls whether this node type is locked.\n\n  }, {\n    key: \"locked\",\n    get: function get() {\n      return false;\n    }\n\n    // :: bool\n    // True for node types that allow no content.\n\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.contentExpr.isLeaf;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(nodes, schema) {\n      var result = Object.create(null);\n      nodes.forEach(function (name, spec) {\n        return result[name] = new spec.type(name, schema);\n      });\n\n      if (!result.doc) throw new RangeError(\"Every schema needs a 'doc' type\");\n      if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\");\n\n      return result;\n    }\n  }]);\n\n  return NodeType;\n}(SchemaItem);\n\n// ;; Base type for block nodetypes.\n\n\nvar Block = exports.Block = function (_NodeType) {\n  _inherits(Block, _NodeType);\n\n  function Block() {\n    _classCallCheck(this, Block);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(Block).apply(this, arguments));\n  }\n\n  _createClass(Block, [{\n    key: \"isBlock\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Block;\n}(NodeType);\n\n// ;; Base type for textblock node types.\n\n\nvar Textblock = exports.Textblock = function (_Block) {\n  _inherits(Textblock, _Block);\n\n  function Textblock() {\n    _classCallCheck(this, Textblock);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(Textblock).apply(this, arguments));\n  }\n\n  _createClass(Textblock, [{\n    key: \"isTextblock\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Textblock;\n}(Block);\n\n// ;; Base type for inline node types.\n\n\nvar Inline = exports.Inline = function (_NodeType2) {\n  _inherits(Inline, _NodeType2);\n\n  function Inline() {\n    _classCallCheck(this, Inline);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(Inline).apply(this, arguments));\n  }\n\n  _createClass(Inline, [{\n    key: \"isInline\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Inline;\n}(NodeType);\n\n// ;; The text node type.\n\n\nvar Text = exports.Text = function (_Inline) {\n  _inherits(Text, _Inline);\n\n  function Text() {\n    _classCallCheck(this, Text);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(Text).apply(this, arguments));\n  }\n\n  _createClass(Text, [{\n    key: \"create\",\n    value: function create(attrs, content, marks) {\n      return new _node.TextNode(this, this.computeAttrs(attrs), content, marks);\n    }\n  }, {\n    key: \"selectable\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Text;\n}(Inline);\n\n// Attribute descriptors\n\n// ;; Attributes are named values associated with nodes and marks.\n// Each node type or mark type has a fixed set of attributes, which\n// instances of this class are used to control. Attribute values must\n// be JSON-serializable.\n\n\nvar Attribute = exports.Attribute = function () {\n  // :: (Object)\n  // Create an attribute. `options` is an object containing the\n  // settings for the attributes. The following settings are\n  // supported:\n  //\n  // **`default`**`: ?any`\n  //   : The default value for this attribute, to choose when no\n  //     explicit value is provided.\n  //\n  // **`compute`**`: ?(Fragment) → any`\n  //   : A function that computes a default value for the attribute from\n  //     the node's content.\n  //\n  // **`label`**`: ?string`\n  //   : A user-readable text label associated with the attribute.\n  //\n  // Attributes that have no default or compute property must be\n  // provided whenever a node or mark of a type that has them is\n  // created.\n\n  function Attribute() {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Attribute);\n\n    this.default = options.default;\n    this.compute = options.compute;\n    this.label = options.label;\n  }\n\n  _createClass(Attribute, [{\n    key: \"isRequired\",\n    get: function get() {\n      return this.default === undefined && !this.compute;\n    }\n  }]);\n\n  return Attribute;\n}();\n\n// Marks\n\n// ;; Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are tagged with type\n// objects, which are instantiated once per `Schema`.\n\n\nvar MarkType = exports.MarkType = function (_SchemaItem2) {\n  _inherits(MarkType, _SchemaItem2);\n\n  function MarkType(name, rank, schema) {\n    _classCallCheck(this, MarkType);\n\n    // :: string\n    // The name of the mark type.\n\n    var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(MarkType).call(this));\n\n    _this6.name = name;\n    _this6.freezeAttrs();\n    _this6.rank = rank;\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    _this6.schema = schema;\n    var defaults = _this6.getDefaultAttrs();\n    _this6.instance = defaults && new _mark.Mark(_this6, defaults);\n    return _this6;\n  }\n\n  // :: bool\n  // Whether this mark should be active when the cursor is positioned\n  // at the end of the mark.\n\n\n  _createClass(MarkType, [{\n    key: \"create\",\n\n\n    // :: (?Object) → Mark\n    // Create a mark of this type. `attrs` may be `null` or an object\n    // containing only some of the mark's attributes. The others, if\n    // they have defaults, will be added.\n    value: function create(attrs) {\n      if (!attrs && this.instance) return this.instance;\n      return new _mark.Mark(this, this.computeAttrs(attrs));\n    }\n  }, {\n    key: \"removeFromSet\",\n\n\n    // :: ([Mark]) → [Mark]\n    // When there is a mark of this type in the given set, a new set\n    // without it is returned. Otherwise, the input set is returned.\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        if (set[i].type == this) return set.slice(0, i).concat(set.slice(i + 1));\n      }return set;\n    }\n\n    // :: ([Mark]) → ?Mark\n    // Tests whether there is a mark of this type in the given set.\n\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        if (set[i].type == this) return set[i];\n      }\n    }\n  }, {\n    key: \"inclusiveRight\",\n    get: function get() {\n      return true;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(marks, schema) {\n      var result = Object.create(null),\n          rank = 0;\n      marks.forEach(function (name, markType) {\n        return result[name] = new markType(name, rank++, schema);\n      });\n      return result;\n    }\n  }]);\n\n  return MarkType;\n}(SchemaItem);\n\n// ;; #path=SchemaSpec #kind=interface\n// An object describing a schema, as passed to the `Schema`\n// constructor.\n\n// :: union<Object<NodeSpec>, OrderedMap<NodeSpec>> #path=SchemaSpec.nodes\n// The node types in this schema. Maps names to `NodeSpec` objects\n// describing the node to be associated with that name. Their order is significant\n\n// :: ?union<Object<constructor<MarkType>>, OrderedMap<constructor<MarkType>>> #path=SchemaSpec.marks\n// The mark types that exist in this schema.\n\n// ;; #path=NodeSpec #kind=interface\n\n// :: constructor<NodeType> #path=NodeSpec.type\n// The `NodeType` class to be used for this node.\n\n// :: ?string #path=NodeSpec.content\n// The content expression for this node, as parsed by\n// `ContentExpr.parse`. When not given, the node does not allow any\n// content.\n\n// :: ?string #path=NodeSpec.group\n// The group or space-separated groups to which this node belongs, as\n// referred to in the content expressions for the schema.\n\n// ;; Each document is based on a single schema, which provides the\n// node and mark types that it is made up of (which, in turn,\n// determine the structure it is allowed to have).\n\n\nvar Schema = function () {\n  // :: (SchemaSpec)\n  // Construct a schema from a specification.\n\n  function Schema(spec) {\n    _classCallCheck(this, Schema);\n\n    // :: OrderedMap<NodeSpec> The node specs that the schema is based on.\n    this.nodeSpec = _orderedmap.OrderedMap.from(spec.nodes);\n    // :: OrderedMap<constructor<MarkType>> The mark spec that the schema is based on.\n    this.markSpec = _orderedmap.OrderedMap.from(spec.marks);\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.nodeSpec, this);\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.markSpec, this);\n    for (var prop in this.nodes) {\n      if (prop in this.marks) throw new RangeError(prop + \" can not be both a node and a mark\");\n      var type = this.nodes[prop];\n      type.contentExpr = _content.ContentExpr.parse(type, this.nodeSpec.get(prop).content || \"\", this.nodeSpec);\n    }\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null);\n    this.cached.wrappings = Object.create(null);\n\n    this.node = this.node.bind(this);\n    this.text = this.text.bind(this);\n    this.nodeFromJSON = this.nodeFromJSON.bind(this);\n    this.markFromJSON = this.markFromJSON.bind(this);\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  //\n  // When creating a text node, `content` should be a string and is\n  // interpreted as the node's text.\n  //\n  // This method is bound to the Schema, meaning you don't have to\n  // call it as a method, but can pass it to higher-order functions\n  // and such.\n\n\n  _createClass(Schema, [{\n    key: \"node\",\n    value: function node(type, attrs, content, marks) {\n      if (typeof type == \"string\") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError(\"Invalid node type: \" + type);else if (type.schema != this) throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n\n      return type.create(attrs, content, marks);\n    }\n\n    // :: (string, ?[Mark]) → Node\n    // Create a text node in the schema. This method is bound to the\n    // Schema. Empty text nodes are not allowed.\n\n  }, {\n    key: \"text\",\n    value: function text(_text, marks) {\n      return this.nodes.text.create(null, _text, _mark.Mark.setFrom(marks));\n    }\n\n    // :: (string, ?Object) → Mark\n    // Create a mark with the named type\n\n  }, {\n    key: \"mark\",\n    value: function mark(name, attrs) {\n      var spec = this.marks[name];\n      if (!spec) throw new RangeError(\"No mark named \" + name);\n      return spec.create(attrs);\n    }\n\n    // :: (Object) → Node\n    // Deserialize a node from its JSON representation. This method is\n    // bound.\n\n  }, {\n    key: \"nodeFromJSON\",\n    value: function nodeFromJSON(json) {\n      return _node.Node.fromJSON(this, json);\n    }\n\n    // :: (Object) → Mark\n    // Deserialize a mark from its JSON representation. This method is\n    // bound.\n\n  }, {\n    key: \"markFromJSON\",\n    value: function markFromJSON(json) {\n      var type = this.marks[json._];\n      var attrs = null;\n      for (var prop in json) {\n        if (prop != \"_\") {\n          if (!attrs) attrs = Object.create(null);\n          attrs[prop] = json[prop];\n        }\n      }return attrs ? type.create(attrs) : type.instance;\n    }\n\n    // :: (string) → NodeType\n    // Get the `NodeType` associated with the given name in\n    // this schema, or raise an error if it does not exist.\n\n  }, {\n    key: \"nodeType\",\n    value: function nodeType(name) {\n      var found = this.nodes[name];\n      if (!found) throw new RangeError(\"Unknown node type: \" + name);\n      return found;\n    }\n\n    // :: (string, (name: string, value: *, source: union<NodeType, MarkType>, name: string))\n    // Retrieve all registered items under the given name from this\n    // schema. The given function will be called with the name, each item, the\n    // element—node type or mark type—that it was associated with, and\n    // that element's name in the schema.\n\n  }, {\n    key: \"registry\",\n    value: function registry(namespace, f) {\n      for (var i = 0; i < 2; i++) {\n        var obj = i ? this.marks : this.nodes;\n        for (var tname in obj) {\n          var type = obj[tname],\n              registry = type.registry,\n              ns = registry && registry[namespace];\n          if (ns) for (var prop in ns) {\n            var value = ns[prop](type);\n            if (value != null) f(prop, value, type, tname);\n          }\n        }\n      }\n    }\n  }]);\n\n  return Schema;\n}();\n\nexports.Schema = Schema;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/schema.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/schema.js?");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContentMatch = exports.ContentExpr = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _fragment = __webpack_require__(20);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ContentExpr = exports.ContentExpr = function () {\n  function ContentExpr(nodeType, elements) {\n    _classCallCheck(this, ContentExpr);\n\n    this.nodeType = nodeType;\n    this.elements = elements;\n  }\n\n  _createClass(ContentExpr, [{\n    key: \"start\",\n    value: function start(attrs) {\n      return new ContentMatch(this, attrs, 0, 0);\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(attrs, fragment, from, to) {\n      return this.start(attrs).matchToEnd(fragment, from, to);\n    }\n\n    // Get a position in a known-valid fragment. If this is a simple\n    // (single-element) expression, we don't have to do any matching,\n    // and can simply skip to the position with count `index`.\n\n  }, {\n    key: \"getMatchAt\",\n    value: function getMatchAt(attrs, fragment) {\n      var index = arguments.length <= 2 || arguments[2] === undefined ? fragment.childCount : arguments[2];\n\n      if (this.elements.length == 1) return new ContentMatch(this, attrs, 0, index);else return this.start(attrs).matchFragment(fragment, 0, index);\n    }\n  }, {\n    key: \"checkReplace\",\n    value: function checkReplace(attrs, content, from, to) {\n      var replacement = arguments.length <= 4 || arguments[4] === undefined ? _fragment.Fragment.empty : arguments[4];\n      var start = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n      var end = arguments.length <= 6 || arguments[6] === undefined ? replacement.childCount : arguments[6];\n\n      // Check for simple case, where the expression only has a single element\n      // (Optimization to avoid matching more than we need)\n      if (this.elements.length == 1) {\n        var elt = this.elements[0];\n        if (!checkCount(elt, content.childCount - (to - from) + (end - start), attrs, this)) return false;\n        for (var i = start; i < end; i++) {\n          if (!elt.matches(replacement.child(i), attrs, this)) return false;\n        }return true;\n      }\n\n      var match = this.getMatchAt(attrs, content, from).matchFragment(replacement, start, end);\n      return match ? match.matchToEnd(content, to) : false;\n    }\n  }, {\n    key: \"checkReplaceWith\",\n    value: function checkReplaceWith(attrs, content, from, to, type, typeAttrs, marks) {\n      if (this.elements.length == 1) {\n        var elt = this.elements[0];\n        if (!checkCount(elt, content.childCount - (to - from) + 1, attrs, this)) return false;\n        return elt.matchesType(type, typeAttrs, marks, attrs, this);\n      }\n\n      var match = this.getMatchAt(attrs, content, from).matchType(type, typeAttrs, marks);\n      return match ? match.matchToEnd(content, to) : false;\n    }\n  }, {\n    key: \"compatible\",\n    value: function compatible(other) {\n      for (var i = 0; i < this.elements.length; i++) {\n        var elt = this.elements[i];\n        for (var j = 0; j < other.elements.length; j++) {\n          if (other.elements[j].compatible(elt)) return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"generateContent\",\n    value: function generateContent(attrs) {\n      return this.start(attrs).fillBefore(_fragment.Fragment.empty, true);\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.elements.length == 0;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(nodeType, expr, specs) {\n      var elements = [],\n          pos = 0,\n          inline = null;\n      for (;;) {\n        pos += /^\\s*/.exec(expr.slice(pos))[0].length;\n        if (pos == expr.length) break;\n\n        var types = /^(?:(\\w+)|\\(\\s*(\\w+(?:\\s*\\|\\s*\\w+)*)\\s*\\))/.exec(expr.slice(pos));\n        if (!types) throw new SyntaxError(\"Invalid content expression '\" + expr + \"' at \" + pos);\n        pos += types[0].length;\n        var attrs = /^\\[([^\\]]+)\\]/.exec(expr.slice(pos));\n        if (attrs) pos += attrs[0].length;\n        var marks = /^<(?:(_)|\\s*(\\w+(?:\\s+\\w+)*)\\s*)>/.exec(expr.slice(pos));\n        if (marks) pos += marks[0].length;\n        var repeat = /^(?:([+*?])|\\{\\s*(\\d+|\\.\\w+)\\s*(,\\s*(\\d+|\\.\\w+)?)?\\s*\\})/.exec(expr.slice(pos));\n        if (repeat) pos += repeat[0].length;\n\n        var nodeTypes = expandTypes(nodeType.schema, specs, types[1] ? [types[1]] : types[2].split(/\\s*\\|\\s*/));\n        for (var i = 0; i < nodeTypes.length; i++) {\n          if (inline == null) inline = nodeTypes[i].isInline;else if (inline != nodeTypes[i].isInline) throw new SyntaxError(\"Mixing inline and block content in a single node\");\n        }\n        var attrSet = !attrs ? null : parseAttrs(nodeType, attrs[1]);\n        var markSet = !marks ? false : marks[1] ? true : checkMarks(nodeType.schema, marks[2].split(/\\s+/));\n\n        var _parseRepeat = parseRepeat(nodeType, repeat);\n\n        var min = _parseRepeat.min;\n        var max = _parseRepeat.max;\n\n        if (min != 0 && nodeTypes[0].hasRequiredAttrs(attrSet)) throw new SyntaxError(\"Node type \" + types[0] + \" in type \" + nodeType.name + \" is required, but has non-optional attributes\");\n        var newElt = new ContentElement(nodeTypes, attrSet, markSet, min, max);\n        for (var i = elements.length - 1; i >= 0; i--) {\n          if (elements[i].overlaps(newElt)) throw new SyntaxError(\"Overlapping adjacent content expressions in '\" + expr + \"'\");\n          if (elements[i].min != 0) break;\n        }\n        elements.push(newElt);\n      }\n\n      return new ContentExpr(nodeType, elements);\n    }\n  }]);\n\n  return ContentExpr;\n}();\n\nvar ContentElement = function () {\n  function ContentElement(nodeTypes, attrs, marks, min, max) {\n    _classCallCheck(this, ContentElement);\n\n    this.nodeTypes = nodeTypes;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.min = min;\n    this.max = max;\n  }\n\n  _createClass(ContentElement, [{\n    key: \"matchesType\",\n    value: function matchesType(type, attrs, marks, parentAttrs, parentExpr) {\n      if (this.nodeTypes.indexOf(type) == -1) return false;\n      if (this.attrs) {\n        if (!attrs) return false;\n        for (var prop in this.attrs) {\n          if (attrs[prop] != _resolveValue(this.attrs[prop], parentAttrs, parentExpr)) return false;\n        }\n      }\n      if (this.marks === true) return true;\n      if (this.marks === false) return marks.length == 0;\n      for (var i = 0; i < marks.length; i++) {\n        if (this.marks.indexOf(marks[i].type) == -1) return false;\n      }return true;\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(node, parentAttrs, parentExpr) {\n      return this.matchesType(node.type, node.attrs, node.marks, parentAttrs, parentExpr);\n    }\n  }, {\n    key: \"compatible\",\n    value: function compatible(other) {\n      for (var i = 0; i < this.nodeTypes.length; i++) {\n        if (other.nodeTypes.indexOf(this.nodeTypes[i]) != -1) return true;\n      }return false;\n    }\n  }, {\n    key: \"constrainedAttrs\",\n    value: function constrainedAttrs(parentAttrs, expr) {\n      if (!this.attrs) return null;\n      var attrs = Object.create(null);\n      for (var prop in this.attrs) {\n        attrs[prop] = _resolveValue(this.attrs[prop], parentAttrs, expr);\n      }return attrs;\n    }\n  }, {\n    key: \"createFiller\",\n    value: function createFiller(parentAttrs, expr) {\n      var type = this.nodeTypes[0],\n          attrs = type.computeAttrs(this.constrainedAttrs(parentAttrs, expr));\n      return type.create(attrs, type.contentExpr.generateContent(attrs));\n    }\n  }, {\n    key: \"defaultType\",\n    value: function defaultType() {\n      return this.nodeTypes[0].defaultAttrs && this.nodeTypes[0];\n    }\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(other) {\n      return this.nodeTypes.some(function (t) {\n        return other.nodeTypes.indexOf(t) > -1;\n      });\n    }\n  }, {\n    key: \"allowsMark\",\n    value: function allowsMark(markType) {\n      return this.marks === true || this.marks && this.marks.indexOf(markType) > -1;\n    }\n  }]);\n\n  return ContentElement;\n}();\n\n// ;; Represents a partial match of a node type's [content\n// expression](#SchemaSpec.nodes).\n\n\nvar ContentMatch = exports.ContentMatch = function () {\n  function ContentMatch(expr, attrs, index, count) {\n    _classCallCheck(this, ContentMatch);\n\n    this.expr = expr;\n    this.attrs = attrs;\n    this.index = index;\n    this.count = count;\n  }\n\n  _createClass(ContentMatch, [{\n    key: \"move\",\n    value: function move(index, count) {\n      return new ContentMatch(this.expr, this.attrs, index, count);\n    }\n  }, {\n    key: \"resolveValue\",\n    value: function resolveValue(value) {\n      return value instanceof AttrValue ? _resolveValue(value, this.attrs, this.expr) : value;\n    }\n\n    // :: (Node) → ?ContentMatch\n    // Match a node, returning an updated match if successful.\n\n  }, {\n    key: \"matchNode\",\n    value: function matchNode(node) {\n      return this.matchType(node.type, node.attrs, node.marks);\n    }\n\n    // :: (NodeType, ?Object, [Mark]) → ?ContentMatch\n    // Match a node type and marks, returning an updated match if\n    // successful.\n\n  }, {\n    key: \"matchType\",\n    value: function matchType(type, attrs, marks) {\n      // FIXME `var` to work around Babel bug T7293\n      for (index = this.index, count = this.count, undefined; index < this.expr.elements.length; index++, count = 0) {\n        var index, count;\n\n        var elt = this.expr.elements[index],\n            max = this.resolveValue(elt.max);\n        if (count < max && elt.matchesType(type, attrs, marks, this.attrs, this.expr)) {\n          count++;\n          return this.move(index, count);\n        }\n        if (count < this.resolveValue(elt.min)) return null;\n      }\n    }\n\n    // :: (Fragment, ?number, ?number) → ?union<ContentMatch, bool>\n    // Try to match a fragment. Returns a new match when successful,\n    // `null` when it ran into a required element it couldn't fit, and\n    // `false` if it reached the end of the expression without\n    // matching all nodes.\n\n  }, {\n    key: \"matchFragment\",\n    value: function matchFragment(fragment) {\n      var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n      var to = arguments.length <= 2 || arguments[2] === undefined ? fragment.childCount : arguments[2];\n\n      if (from == to) return this;\n      var fragPos = from,\n          end = this.expr.elements.length;\n      for (index = this.index, count = this.count, undefined; index < end; index++, count = 0) {\n        var index, count;\n\n        var elt = this.expr.elements[index],\n            max = this.resolveValue(elt.max);\n\n        while (count < max) {\n          if (elt.matches(fragment.child(fragPos), this.attrs, this.expr)) {\n            count++;\n            if (++fragPos == to) return this.move(index, count);\n          } else {\n            break;\n          }\n        }\n        if (count < this.resolveValue(elt.min)) return null;\n      }\n      return false;\n    }\n\n    // :: (Fragment, ?number, ?number) → bool\n    // Returns true only if the fragment matches here, and reaches all\n    // the way to the end of the content expression.\n\n  }, {\n    key: \"matchToEnd\",\n    value: function matchToEnd(fragment, start, end) {\n      var matched = this.matchFragment(fragment, start, end);\n      return matched && matched.validEnd() || false;\n    }\n\n    // :: () → bool\n    // Returns true if this position represents a valid end of the\n    // expression (no required content follows after it).\n\n  }, {\n    key: \"validEnd\",\n    value: function validEnd() {\n      for (var i = this.index, count = this.count; i < this.expr.elements.length; i++, count = 0) {\n        if (count < this.resolveValue(this.expr.elements[i].min)) return false;\n      }return true;\n    }\n\n    // :: (Fragment, bool, ?number) → ?Fragment\n    // Try to match the given fragment, and if that fails, see if it can\n    // be made to match by inserting nodes in front of it. When\n    // successful, return a fragment (which may be empty if nothing had\n    // to be inserted). When `toEnd` is true, only return a fragment if\n    // the resulting match goes to the end of the content expression.\n\n  }, {\n    key: \"fillBefore\",\n    value: function fillBefore(after, toEnd, startIndex) {\n      var added = [],\n          match = this,\n          index = startIndex || 0,\n          end = this.expr.elements.length;\n      for (;;) {\n        var fits = match.matchFragment(after, index);\n        if (fits && (!toEnd || fits.validEnd())) return _fragment.Fragment.from(added);\n        if (fits === false) return null; // Matched to end with content remaining\n\n        var elt = match.element;\n        if (match.count < this.resolveValue(elt.min)) {\n          added.push(elt.createFiller(this.attrs, this.expr));\n          match = match.move(match.index, match.count + 1);\n        } else if (match.index < end) {\n          match = match.move(match.index + 1, 0);\n        } else if (after.childCount > index) {\n          return null;\n        } else {\n          return _fragment.Fragment.from(added);\n        }\n      }\n    }\n  }, {\n    key: \"possibleContent\",\n    value: function possibleContent() {\n      var found = [];\n      for (var i = this.index, count = this.count; i < this.expr.elements.length; i++, count = 0) {\n        var elt = this.expr.elements[i],\n            attrs = elt.constrainedAttrs(this.attrs, this.expr);\n        if (count < this.resolveValue(elt.max)) for (var j = 0; j < elt.nodeTypes.length; j++) {\n          var type = elt.nodeTypes[j];\n          if (!type.hasRequiredAttrs(attrs)) found.push({ type: type, attrs: attrs });\n        }\n        if (this.resolveValue(elt.min) > count) break;\n      }\n      return found;\n    }\n\n    // :: (MarkType) → bool\n    // Check whether a node with the given mark type is allowed after\n    // this position.\n\n  }, {\n    key: \"allowsMark\",\n    value: function allowsMark(markType) {\n      return this.element.allowsMark(markType);\n    }\n\n    // :: (NodeType, ?Object) → ?[{type: NodeType, attrs: Object}]\n    // Find a set of wrapping node types that would allow a node of type\n    // `type` to appear at this position. The result may be empty (when\n    // it fits directly) and will be null when no such wrapping exists.\n\n  }, {\n    key: \"findWrapping\",\n    value: function findWrapping(target, targetAttrs) {\n      // FIXME find out how expensive this is. Try to reintroduce caching?\n      var seen = Object.create(null),\n          first = { match: this, via: null },\n          active = [first];\n      while (active.length) {\n        var current = active.shift(),\n            match = current.match;\n        var possible = match.possibleContent();\n        for (var i = 0; i < possible.length; i++) {\n          var _possible$i = possible[i];\n          var type = _possible$i.type;\n          var attrs = _possible$i.attrs;var fullAttrs = type.computeAttrs(attrs);\n          if (type == target) {\n            var fits = match.matchType(type, targetAttrs, []);\n            if (fits && fits.validEnd()) {\n              var result = [];\n              for (var obj = current; obj.via; obj = obj.via) {\n                result.push({ type: obj.match.expr.nodeType, attrs: obj.match.attrs });\n              }return result.reverse();\n            }\n          }\n          if (!type.isLeaf && !(type.name in seen) && (current == first || match.matchType(type, fullAttrs, []).validEnd())) {\n            active.push({ match: type.contentExpr.start(fullAttrs), via: current });\n            seen[type.name] = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.expr.elements[this.index];\n    }\n  }]);\n\n  return ContentMatch;\n}();\n\nvar AttrValue = function AttrValue(attr) {\n  _classCallCheck(this, AttrValue);\n\n  this.attr = attr;\n};\n\nfunction parseValue(nodeType, value) {\n  if (value.charAt(0) == \".\") {\n    var attr = value.slice(1);\n    if (!nodeType.attrs[attr]) throw new SyntaxError(\"Node type \" + nodeType.name + \" has no attribute \" + attr);\n    return new AttrValue(attr);\n  } else {\n    return JSON.parse(value);\n  }\n}\n\nfunction checkMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var mark = schema.marks[marks[i]];\n    if (mark) found.push(mark);else throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n  }\n  return found;\n}\n\nfunction _resolveValue(value, attrs, expr) {\n  if (!(value instanceof AttrValue)) return value;\n  var attrVal = attrs && attrs[value.attr];\n  return attrVal !== undefined ? attrVal : expr.nodeType.defaultAttrs[value.attr];\n}\n\nfunction checkCount(elt, count, attrs, expr) {\n  return count >= _resolveValue(elt.min, attrs, expr) && count <= _resolveValue(elt.max, attrs, expr);\n}\n\nfunction expandTypes(schema, specs, types) {\n  var result = [];\n  types.forEach(function (type) {\n    var found = schema.nodes[type];\n    if (found) {\n      if (result.indexOf(found) == -1) result.push(found);\n    } else {\n      specs.forEach(function (name, spec) {\n        if (spec.group && spec.group.split(\" \").indexOf(type) > -1) {\n          found = schema.nodes[name];\n          if (result.indexOf(found) == -1) result.push(found);\n        }\n      });\n    }\n    if (!found) throw new SyntaxError(\"Node type or group '\" + type + \"' does not exist\");\n  });\n  return result;\n}\n\nvar many = 2e9; // Big number representable as a 32-bit int\n\nfunction parseRepeat(nodeType, match) {\n  var min = 1,\n      max = 1;\n  if (match) {\n    if (match[1] == \"+\") {\n      max = many;\n    } else if (match[1] == \"*\") {\n      min = 0;\n      max = many;\n    } else if (match[1] == \"?\") {\n      min = 0;\n    } else if (match[2]) {\n      min = parseValue(nodeType, match[2]);\n      if (match[3]) max = match[4] ? parseValue(nodeType, match[4]) : many;else max = min;\n    }\n    if (max == 0 || min > max) throw new SyntaxError(\"Invalid repeat count in '\" + match[0] + \"'\");\n  }\n  return { min: min, max: max };\n}\n\nfunction parseAttrs(nodeType, expr) {\n  var parts = expr.split(/\\s*,\\s*/);\n  var attrs = Object.create(null);\n  for (var i = 0; i < parts.length; i++) {\n    var match = /^(\\w+)=(\\w+|\\\"(?:\\\\.|[^\\\\])*\\\"|\\.\\w+)$/.exec(parts[i]);\n    if (!match) throw new SyntaxError(\"Invalid attribute syntax: \" + parts[i]);\n    attrs[match[1]] = parseValue(nodeType, match[2]);\n  }\n  return attrs;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/content.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/content.js?");

/***/ },
/* 28 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.copyObj = copyObj;\nfunction copyObj(obj, base) {\n  var copy = base || Object.create(null);\n  for (var prop in obj) {\n    copy[prop] = obj[prop];\n  }return copy;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/util/obj.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/util/obj.js?");

/***/ },
/* 29 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\n\nvar OrderedMap = exports.OrderedMap = function () {\n  function OrderedMap(content) {\n    _classCallCheck(this, OrderedMap);\n\n    this.content = content;\n  }\n\n  _createClass(OrderedMap, [{\n    key: \"find\",\n    value: function find(key) {\n      for (var i = 0; i < this.content.length; i += 2) {\n        if (this.content[i] == key) return i;\n      }return -1;\n    }\n\n    // :: (string) → ?any\n    // Retrieve the value stored under `key`, or return undefined when\n    // no such key exists.\n\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var found = this.find(key);\n      return found == -1 ? undefined : this.content[found + 1];\n    }\n\n    // :: (string, any, ?string) → OrderedMap\n    // Create a new map by replacing the value of `key` with a new\n    // value, or adding a binding to the end of the map. If `newKey` is\n    // given, the key of the binding will be replaced with that key.\n\n  }, {\n    key: \"update\",\n    value: function update(key, value, newKey) {\n      var self = newKey && newKey != key ? this.remove(newKey) : this;\n      var found = self.find(key),\n          content = self.content.slice();\n      if (found == -1) {\n        content.push(newKey || key, value);\n      } else {\n        content[found + 1] = value;\n        if (newKey) content[found] = newKey;\n      }\n      return new OrderedMap(content);\n    }\n\n    // :: (string) → OrderedMap\n    // Return a map with the given key removed, if it existed.\n\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var found = this.find(key);\n      if (found == -1) return this;\n      var content = this.content.slice();\n      content.splice(found, 2);\n      return new OrderedMap(content);\n    }\n\n    // :: (string, any) → OrderedMap\n    // Add a new key to the start of the map.\n\n  }, {\n    key: \"addToStart\",\n    value: function addToStart(key, value) {\n      return new OrderedMap([key, value].concat(this.remove(key).content));\n    }\n\n    // :: (string, any) → OrderedMap\n    // Add a new key to the end of the map.\n\n  }, {\n    key: \"addToEnd\",\n    value: function addToEnd(key, value) {\n      var content = this.remove(key).content.slice();\n      content.push(key, value);\n      return new OrderedMap(content);\n    }\n\n    // :: ((key: string, value: any))\n    // Call the given function for each key/value pair in the map, in\n    // order.\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var i = 0; i < this.content.length; i += 2) {\n        f(this.content[i], this.content[i + 1]);\n      }\n    }\n\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a new map by prepending the keys in this map that don't\n    // appear in `map` before the keys in `map`.\n\n  }, {\n    key: \"prepend\",\n    value: function prepend(map) {\n      if (!map.size) return this;\n      map = OrderedMap.from(map);\n      return new OrderedMap(map.content.concat(this.subtract(map).content));\n    }\n\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a new map by appending the keys in this map that don't\n    // appear in `map` after the keys in `map`.\n\n  }, {\n    key: \"append\",\n    value: function append(map) {\n      if (!map.size) return this;\n      map = OrderedMap.from(map);\n      return new OrderedMap(this.subtract(map).content.concat(map.content));\n    }\n\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a map containing all the keys in this map that don't\n    // appear in `map`.\n\n  }, {\n    key: \"subtract\",\n    value: function subtract(map) {\n      var result = this;\n      OrderedMap.from(map).forEach(function (key) {\n        return result = result.remove(key);\n      });\n      return result;\n    }\n\n    // :: number\n    // The amount of keys in this map.\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.content.length >> 1;\n    }\n\n    // :: (?union<Object, OrderedMap>) → OrderedMap\n    // Return a map with the given content. If null, create an empty\n    // map. If given an ordered map, return that map itself. If given an\n    // object, create a map from the object's properties.\n\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (value instanceof OrderedMap) return value;\n      var content = [];\n      if (value) for (var prop in value) {\n        content.push(prop, value[prop]);\n      }return new OrderedMap(content);\n    }\n  }]);\n\n  return OrderedMap;\n}();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/util/orderedmap.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/util/orderedmap.js?");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultSchema = exports.CodeMark = exports.LinkMark = exports.StrongMark = exports.EmMark = exports.HardBreak = exports.Image = exports.Paragraph = exports.CodeBlock = exports.Heading = exports.HorizontalRule = exports.ListItem = exports.BulletList = exports.OrderedList = exports.BlockQuote = exports.Doc = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _schema = __webpack_require__(26);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// ;; The default top-level document node type.\n\nvar Doc = exports.Doc = function (_Block) {\n  _inherits(Doc, _Block);\n\n  function Doc() {\n    _classCallCheck(this, Doc);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(Doc).apply(this, arguments));\n  }\n\n  return Doc;\n}(_schema.Block);\n\n// ;; The default blockquote node type.\n\n\nvar BlockQuote = exports.BlockQuote = function (_Block2) {\n  _inherits(BlockQuote, _Block2);\n\n  function BlockQuote() {\n    _classCallCheck(this, BlockQuote);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(BlockQuote).apply(this, arguments));\n  }\n\n  return BlockQuote;\n}(_schema.Block);\n\n// ;; The default ordered list node type. Has a single attribute,\n// `order`, which determines the number at which the list starts\n// counting, and defaults to 1.\n\n\nvar OrderedList = exports.OrderedList = function (_Block3) {\n  _inherits(OrderedList, _Block3);\n\n  function OrderedList() {\n    _classCallCheck(this, OrderedList);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(OrderedList).apply(this, arguments));\n  }\n\n  _createClass(OrderedList, [{\n    key: \"attrs\",\n    get: function get() {\n      return { order: new _schema.Attribute({ default: 1 }) };\n    }\n  }]);\n\n  return OrderedList;\n}(_schema.Block);\n\n// ;; The default bullet list node type.\n\n\nvar BulletList = exports.BulletList = function (_Block4) {\n  _inherits(BulletList, _Block4);\n\n  function BulletList() {\n    _classCallCheck(this, BulletList);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(BulletList).apply(this, arguments));\n  }\n\n  return BulletList;\n}(_schema.Block);\n\n// ;; The default list item node type.\n\n\nvar ListItem = exports.ListItem = function (_Block5) {\n  _inherits(ListItem, _Block5);\n\n  function ListItem() {\n    _classCallCheck(this, ListItem);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(ListItem).apply(this, arguments));\n  }\n\n  return ListItem;\n}(_schema.Block);\n\n// ;; The default horizontal rule node type.\n\n\nvar HorizontalRule = exports.HorizontalRule = function (_Block6) {\n  _inherits(HorizontalRule, _Block6);\n\n  function HorizontalRule() {\n    _classCallCheck(this, HorizontalRule);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(HorizontalRule).apply(this, arguments));\n  }\n\n  return HorizontalRule;\n}(_schema.Block);\n\n// ;; The default heading node type. Has a single attribute\n// `level`, which indicates the heading level, and defaults to 1.\n\n\nvar Heading = exports.Heading = function (_Textblock) {\n  _inherits(Heading, _Textblock);\n\n  function Heading() {\n    _classCallCheck(this, Heading);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(Heading).apply(this, arguments));\n  }\n\n  _createClass(Heading, [{\n    key: \"attrs\",\n    get: function get() {\n      return { level: new _schema.Attribute({ default: 1 }) };\n    }\n    // :: number\n    // Controls the maximum heading level. Has the value 6 in the\n    // `Heading` class, but you can override it in a subclass.\n\n  }, {\n    key: \"maxLevel\",\n    get: function get() {\n      return 6;\n    }\n  }]);\n\n  return Heading;\n}(_schema.Textblock);\n\n// ;; The default code block / listing node type. Only\n// allows unmarked text nodes inside of it.\n\n\nvar CodeBlock = exports.CodeBlock = function (_Textblock2) {\n  _inherits(CodeBlock, _Textblock2);\n\n  function CodeBlock() {\n    _classCallCheck(this, CodeBlock);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(CodeBlock).apply(this, arguments));\n  }\n\n  _createClass(CodeBlock, [{\n    key: \"isCode\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return CodeBlock;\n}(_schema.Textblock);\n\n// ;; The default paragraph node type.\n\n\nvar Paragraph = exports.Paragraph = function (_Textblock3) {\n  _inherits(Paragraph, _Textblock3);\n\n  function Paragraph() {\n    _classCallCheck(this, Paragraph);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(Paragraph).apply(this, arguments));\n  }\n\n  return Paragraph;\n}(_schema.Textblock);\n\n// ;; The default inline image node type. Has these\n// attributes:\n//\n// - **`src`** (required): The URL of the image.\n// - **`alt`**: The alt text.\n// - **`title`**: The title of the image.\n\n\nvar Image = exports.Image = function (_Inline) {\n  _inherits(Image, _Inline);\n\n  function Image() {\n    _classCallCheck(this, Image);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(Image).apply(this, arguments));\n  }\n\n  _createClass(Image, [{\n    key: \"attrs\",\n    get: function get() {\n      return {\n        src: new _schema.Attribute(),\n        alt: new _schema.Attribute({ default: \"\" }),\n        title: new _schema.Attribute({ default: \"\" })\n      };\n    }\n  }, {\n    key: \"draggable\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Image;\n}(_schema.Inline);\n\n// ;; The default hard break node type.\n\n\nvar HardBreak = exports.HardBreak = function (_Inline2) {\n  _inherits(HardBreak, _Inline2);\n\n  function HardBreak() {\n    _classCallCheck(this, HardBreak);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(HardBreak).apply(this, arguments));\n  }\n\n  _createClass(HardBreak, [{\n    key: \"selectable\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"isBR\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return HardBreak;\n}(_schema.Inline);\n\n// ;; The default emphasis mark type.\n\n\nvar EmMark = exports.EmMark = function (_MarkType) {\n  _inherits(EmMark, _MarkType);\n\n  function EmMark() {\n    _classCallCheck(this, EmMark);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(EmMark).apply(this, arguments));\n  }\n\n  return EmMark;\n}(_schema.MarkType);\n\n// ;; The default strong mark type.\n\n\nvar StrongMark = exports.StrongMark = function (_MarkType2) {\n  _inherits(StrongMark, _MarkType2);\n\n  function StrongMark() {\n    _classCallCheck(this, StrongMark);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(StrongMark).apply(this, arguments));\n  }\n\n  return StrongMark;\n}(_schema.MarkType);\n\n// ;; The default link mark type. Has these attributes:\n//\n// - **`href`** (required): The link target.\n// - **`title`**: The link's title.\n\n\nvar LinkMark = exports.LinkMark = function (_MarkType3) {\n  _inherits(LinkMark, _MarkType3);\n\n  function LinkMark() {\n    _classCallCheck(this, LinkMark);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(LinkMark).apply(this, arguments));\n  }\n\n  _createClass(LinkMark, [{\n    key: \"attrs\",\n    get: function get() {\n      return {\n        href: new _schema.Attribute(),\n        title: new _schema.Attribute({ default: \"\" })\n      };\n    }\n  }]);\n\n  return LinkMark;\n}(_schema.MarkType);\n\n// ;; The default code font mark type.\n\n\nvar CodeMark = exports.CodeMark = function (_MarkType4) {\n  _inherits(CodeMark, _MarkType4);\n\n  function CodeMark() {\n    _classCallCheck(this, CodeMark);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(CodeMark).apply(this, arguments));\n  }\n\n  _createClass(CodeMark, [{\n    key: \"isCode\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return CodeMark;\n}(_schema.MarkType);\n\n// :: Schema\n// ProseMirror's default document schema.\n\n\nvar defaultSchema = exports.defaultSchema = new _schema.Schema({\n  nodes: {\n    doc: { type: Doc, content: \"block+\" },\n\n    paragraph: { type: Paragraph, content: \"inline<_>*\", group: \"block\" },\n    blockquote: { type: BlockQuote, content: \"block+\", group: \"block\" },\n    ordered_list: { type: OrderedList, content: \"list_item+\", group: \"block\" },\n    bullet_list: { type: BulletList, content: \"list_item+\", group: \"block\" },\n    horizontal_rule: { type: HorizontalRule, group: \"block\" },\n    heading: { type: Heading, content: \"inline<_>*\", group: \"block\" },\n    code_block: { type: CodeBlock, content: \"text*\", group: \"block\" },\n\n    list_item: { type: ListItem, content: \"block+\" },\n\n    text: { type: _schema.Text, group: \"inline\" },\n    image: { type: Image, group: \"inline\" },\n    hard_break: { type: HardBreak, group: \"inline\" }\n  },\n\n  marks: {\n    em: EmMark,\n    strong: StrongMark,\n    link: LinkMark,\n    code: CodeMark\n  }\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/defaultschema.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/defaultschema.js?");

/***/ },
/* 31 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findDiffStart = findDiffStart;\nexports.findDiffEnd = findDiffEnd;\n// :: (Node, Node) → ?number\n// Find the first position at which nodes `a` and `b` differ, or\n// `null` if they are the same.\nfunction findDiffStart(a, b) {\n  var pos = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;\n\n    var childA = a.child(i),\n        childB = b.child(i);\n    if (childA == childB) {\n      pos += childA.nodeSize;continue;\n    }\n\n    if (!childA.sameMarkup(childB)) return pos;\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++) {\n        pos++;\n      }return pos;\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) return inner;\n    }\n    pos += childA.nodeSize;\n  }\n}\n\n// :: (Node, Node) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which nodes `a`\n// and `b` differ, or `null` if they are the same. Since this position\n// will not be the same in both nodes, an object with two separate\n// positions is returned.\nfunction findDiffEnd(a, b) {\n  var posA = arguments.length <= 2 || arguments[2] === undefined ? a.size : arguments[2];\n  var posB = arguments.length <= 3 || arguments[3] === undefined ? b.size : arguments[3];\n\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0) return iA == iB ? null : { a: posA, b: posB };\n\n    var childA = a.child(--iA),\n        childB = b.child(--iB),\n        size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size;posB -= size;\n      continue;\n    }\n\n    if (!childA.sameMarkup(childB)) return { a: posA, b: posB };\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0,\n          minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;posA--;posB--;\n      }\n      return { a: posA, b: posB };\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) return inner;\n    }\n    posA -= size;posB -= size;\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/model/diff.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/model/diff.js?");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.toDOM = toDOM;\nexports.nodeToDOM = nodeToDOM;\nexports.toHTML = toHTML;\n\nvar _model = __webpack_require__(18);\n\nvar _register = __webpack_require__(16);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; Object used to to expose relevant values and methods\n// to DOM serializer functions.\n\nvar DOMSerializer = function () {\n  function DOMSerializer(options) {\n    _classCallCheck(this, DOMSerializer);\n\n    // :: Object The options passed to the serializer.\n    this.options = options || {};\n    // :: DOMDocument The DOM document in which we are working.\n    this.doc = this.options.document || window.document;\n  }\n\n  // :: (string, ?Object, ...[union<string, DOMNode>]) → DOMNode\n  // Create a DOM node of the given type, with (optionally) the given\n  // attributes and content. Content elements may be strings (for text\n  // nodes) or other DOM nodes.\n\n\n  _createClass(DOMSerializer, [{\n    key: \"elt\",\n    value: function elt(type, attrs) {\n      var result = this.doc.createElement(type);\n      if (attrs) for (var name in attrs) {\n        if (name == \"style\") result.style.cssText = attrs[name];else if (attrs[name]) result.setAttribute(name, attrs[name]);\n      }\n\n      for (var _len = arguments.length, content = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        content[_key - 2] = arguments[_key];\n      }\n\n      for (var i = 0; i < content.length; i++) {\n        result.appendChild(typeof content[i] == \"string\" ? this.doc.createTextNode(content[i]) : content[i]);\n      }return result;\n    }\n  }, {\n    key: \"renderNode\",\n    value: function renderNode(node, offset) {\n      var dom = node.type.serializeDOM(node, this);\n      if (this.options.onRender) dom = this.options.onRender(node, dom, offset) || dom;\n      return dom;\n    }\n  }, {\n    key: \"renderFragment\",\n    value: function renderFragment(fragment, where) {\n      if (!where) where = this.doc.createDocumentFragment();\n      if (fragment.size == 0) return where;\n\n      if (!fragment.firstChild.isInline) this.renderBlocksInto(fragment, where);else if (this.options.renderInlineFlat) this.renderInlineFlatInto(fragment, where);else this.renderInlineInto(fragment, where);\n      return where;\n    }\n  }, {\n    key: \"renderBlocksInto\",\n    value: function renderBlocksInto(fragment, where) {\n      var _this = this;\n\n      fragment.forEach(function (node, offset) {\n        return where.appendChild(_this.renderNode(node, offset));\n      });\n    }\n  }, {\n    key: \"renderInlineInto\",\n    value: function renderInlineInto(fragment, where) {\n      var _this2 = this;\n\n      var top = where;\n      var active = [];\n      fragment.forEach(function (node, offset) {\n        var keep = 0;\n        for (; keep < Math.min(active.length, node.marks.length); ++keep) {\n          if (!node.marks[keep].eq(active[keep])) break;\n        }while (keep < active.length) {\n          active.pop();\n          top = top.parentNode;\n        }\n        while (active.length < node.marks.length) {\n          var add = node.marks[active.length];\n          active.push(add);\n          top = top.appendChild(_this2.renderMark(add));\n        }\n        top.appendChild(_this2.renderNode(node, offset));\n      });\n    }\n  }, {\n    key: \"renderInlineFlatInto\",\n    value: function renderInlineFlatInto(fragment, where) {\n      var _this3 = this;\n\n      fragment.forEach(function (node, offset) {\n        var dom = _this3.renderNode(node, offset);\n        dom = _this3.wrapInlineFlat(dom, node.marks);\n        dom = _this3.options.renderInlineFlat(node, dom, offset) || dom;\n        where.appendChild(dom);\n      });\n    }\n  }, {\n    key: \"renderMark\",\n    value: function renderMark(mark) {\n      return mark.type.serializeDOM(mark, this);\n    }\n  }, {\n    key: \"wrapInlineFlat\",\n    value: function wrapInlineFlat(dom, marks) {\n      for (var i = marks.length - 1; i >= 0; i--) {\n        var wrap = this.renderMark(marks[i]);\n        wrap.appendChild(dom);\n        dom = wrap;\n      }\n      return dom;\n    }\n\n    // :: (Node, string, ?Object) → DOMNode\n    // Render the content of ProseMirror node into a DOM node with the\n    // given tag name and attributes.\n\n  }, {\n    key: \"renderAs\",\n    value: function renderAs(node, tagName, tagAttrs) {\n      if (this.options.preRenderContent) this.options.preRenderContent(node);\n\n      var dom = this.renderFragment(node.content, this.elt(tagName, tagAttrs));\n      if (this.options.onContainer) this.options.onContainer(dom);\n\n      if (this.options.postRenderContent) this.options.postRenderContent(node);\n      return dom;\n    }\n  }]);\n\n  return DOMSerializer;\n}();\n\n// :: (union<Node, Fragment>, ?Object) → DOMFragment\n// Serialize the given content to a DOM fragment. When not\n// in the browser, the `document` option, containing a DOM document,\n// should be passed so that the serialize can create nodes.\n//\n// To define rendering behavior for your own [node](#NodeType) and\n// [mark](#MarkType) types, give them a `serializeDOM` method. This\n// method is passed a `Node` and a `DOMSerializer`, and should return\n// the [DOM\n// node](https://developer.mozilla.org/en-US/docs/Web/API/Node) that\n// represents this node and its content. For marks, that should be an\n// inline wrapping node like `<a>` or `<strong>`.\n//\n// Individual attributes can also define serialization behavior. If an\n// `Attribute` object has a `serializeDOM` method, that will be called\n// with the DOM node representing the node that the attribute applies\n// to and the atttribute's value, so that it can set additional DOM\n// attributes on the DOM node.\n\n\nfunction toDOM(content, options) {\n  return new DOMSerializer(options).renderFragment(content instanceof _model.Node ? content.content : content);\n}\n\n(0, _register.defineTarget)(\"dom\", toDOM);\n\n// :: (Node, ?Object) → DOMNode\n// Serialize a given node to a DOM node. This is useful when you need\n// to serialize a part of a document, as opposed to the whole\n// document.\nfunction nodeToDOM(node, options, offset) {\n  var serializer = new DOMSerializer(options);\n  var dom = serializer.renderNode(node, offset);\n  if (node.isInline) {\n    dom = serializer.wrapInlineFlat(dom, node.marks);\n    if (serializer.options.renderInlineFlat) dom = options.renderInlineFlat(node, dom, offset) || dom;\n  }\n  return dom;\n}\n\n// :: (union<Node, Fragment>, ?Object) → string\n// Serialize a node as an HTML string. Goes through `toDOM` and then\n// serializes the result. Again, you must pass a `document` option\n// when not in the browser.\nfunction toHTML(content, options) {\n  var serializer = new DOMSerializer(options);\n  var wrap = serializer.elt(\"div\");\n  wrap.appendChild(serializer.renderFragment(content instanceof _model.Node ? content.content : content));\n  return wrap.innerHTML;\n}\n\n(0, _register.defineTarget)(\"html\", toHTML);\n\n// Block nodes\n\nfunction def(cls, method) {\n  cls.prototype.serializeDOM = method;\n}\n\ndef(_model.BlockQuote, function (node, s) {\n  return s.renderAs(node, \"blockquote\");\n});\n\n_model.BlockQuote.prototype.countCoordsAsChild = function (_, pos, dom, coords) {\n  var childBox = dom.firstChild.getBoundingClientRect();\n  if (coords.left < childBox.left - 2) return pos;\n};\n\ndef(_model.BulletList, function (node, s) {\n  return s.renderAs(node, \"ul\");\n});\n\ndef(_model.OrderedList, function (node, s) {\n  return s.renderAs(node, \"ol\", { start: node.attrs.order != 1 && node.attrs.order });\n});\n\n_model.OrderedList.prototype.countCoordsAsChild = _model.BulletList.prototype.countCoordsAsChild = function (_, pos, dom, coords) {\n  for (var child = dom.firstChild; child; child = child.nextSibling) {\n    var off = child.getAttribute(\"pm-offset\");\n    if (!off) continue;\n    var childBox = child.getBoundingClientRect();\n    if (coords.left > childBox.left - 2) return null;\n    if (childBox.top <= coords.top && childBox.bottom >= coords.top) return pos + 1 + +off;\n  }\n};\n\ndef(_model.ListItem, function (node, s) {\n  return s.renderAs(node, \"li\");\n});\n\ndef(_model.HorizontalRule, function (_, s) {\n  return s.elt(\"div\", null, s.elt(\"hr\"));\n});\n\ndef(_model.Paragraph, function (node, s) {\n  return s.renderAs(node, \"p\");\n});\n\ndef(_model.Heading, function (node, s) {\n  return s.renderAs(node, \"h\" + node.attrs.level);\n});\n\ndef(_model.CodeBlock, function (node, s) {\n  var code = s.renderAs(node, \"code\");\n  if (node.attrs.params != null) code.className = \"fence \" + node.attrs.params.replace(/(^|\\s+)/g, \"$&lang-\");\n  return s.elt(\"pre\", null, code);\n});\n\n// Inline content\n\ndef(_model.Text, function (node, s) {\n  return s.doc.createTextNode(node.text);\n});\n\ndef(_model.Image, function (node, s) {\n  return s.elt(\"img\", {\n    src: node.attrs.src,\n    alt: node.attrs.alt,\n    title: node.attrs.title\n  });\n});\n\ndef(_model.HardBreak, function (_, s) {\n  return s.elt(\"br\");\n});\n\n// Inline styles\n\ndef(_model.EmMark, function (_, s) {\n  return s.elt(\"em\");\n});\n\ndef(_model.StrongMark, function (_, s) {\n  return s.elt(\"strong\");\n});\n\ndef(_model.CodeMark, function (_, s) {\n  return s.elt(\"code\");\n});\n\ndef(_model.LinkMark, function (mark, s) {\n  return s.elt(\"a\", { href: mark.attrs.href,\n    title: mark.attrs.title });\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/format/to_dom.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/format/to_dom.js?");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromText = fromText;\n\nvar _register = __webpack_require__(16);\n\n// FIXME is it meaningful to try and attach text-parsing information\n// to node types?\n\n// :: (Schema, string) → Node\n// Convert a string into a simple ProseMirror document.\nfunction fromText(schema, text) {\n  var blocks = text.trim().split(/\\n{2,}/);\n  var nodes = [];\n  for (var i = 0; i < blocks.length; i++) {\n    var spans = [];\n    var parts = blocks[i].split(\"\\n\");\n    for (var j = 0; j < parts.length; j++) {\n      if (j) spans.push(schema.node(\"hard_break\"));\n      if (parts[j]) spans.push(schema.text(parts[j]));\n    }\n    nodes.push(schema.node(\"paragraph\", null, spans));\n  }\n  if (!nodes.length) nodes.push(schema.node(\"paragraph\"));\n  return schema.node(\"doc\", null, nodes);\n}\n\n(0, _register.defineSource)(\"text\", fromText);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/format/from_text.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/format/from_text.js?");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toText = toText;\n\nvar _model = __webpack_require__(18);\n\nvar _register = __webpack_require__(16);\n\nfunction serializeFragment(fragment) {\n  var accum = \"\";\n  fragment.forEach(function (child) {\n    return accum += child.type.serializeText(child);\n  });\n  return accum;\n}\n\n_model.Block.prototype.serializeText = function (node) {\n  return serializeFragment(node.content);\n};\n\n_model.Textblock.prototype.serializeText = function (node) {\n  var text = _model.Block.prototype.serializeText(node);\n  return text && text + \"\\n\\n\";\n};\n\n_model.Inline.prototype.serializeText = function () {\n  return \"\";\n};\n\n_model.HardBreak.prototype.serializeText = function () {\n  return \"\\n\";\n};\n\n_model.Text.prototype.serializeText = function (node) {\n  return node.text;\n};\n\n// :: (union<Node, Fragment>) → string\n// Serialize content as a plain text string.\nfunction toText(content) {\n  return serializeFragment(content).trim();\n}\n\n(0, _register.defineTarget)(\"text\", toText);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/format/to_text.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/format/to_text.js?");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defineOption = defineOption;\nexports.parseOptions = parseOptions;\nexports.initOptions = initOptions;\nexports.setOption = setOption;\n\nvar _model = __webpack_require__(18);\n\nvar _prompt = __webpack_require__(36);\n\nvar _command = __webpack_require__(37);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// An option encapsulates functionality for an editor instance,\n// e.g. the amount of history events that the editor should hold\n// onto or the document's schema.\n\nvar Option = function Option(defaultValue, update, updateOnInit) {\n  _classCallCheck(this, Option);\n\n  this.defaultValue = defaultValue;\n  // A function that will be invoked with the option's old and new\n  // value every time the option is [set](#ProseMirror.setOption).\n  // This function should bootstrap option functionality.\n  this.update = update;\n  this.updateOnInit = updateOnInit !== false;\n};\n\nvar options = Object.create(null);\n\n// :: (string, any, ?(pm: ProseMirror, newValue: any, oldValue: any, init: bool), bool)\n// Define a new option. The `update` handler will be called with the\n// option's old and new value every time the option is\n// [changed](#ProseMirror.setOption). When `updateOnInit` is false, it\n// will not be called on editor init, otherwise it is called with null as the old value,\n// and a fourth argument of true.\nfunction defineOption(name, defaultValue, update, updateOnInit) {\n  options[name] = new Option(defaultValue, update, updateOnInit);\n}\n\n// :: Schema #path=schema #kind=option\n// The [schema](#Schema) that the editor's document should use.\ndefineOption(\"schema\", _model.defaultSchema);\n\n// :: any #path=doc #kind=option\n// The starting document. Usually a `Node`, but can be in another\n// format when the `docFormat` option is also specified.\ndefineOption(\"doc\", null, function (pm, value) {\n  return pm.setDoc(value);\n}, false);\n\n// :: ?string #path=docFormat #kind=option\n// The format in which the `doc` option is given. Defaults to `null`\n// (a raw `Node`).\ndefineOption(\"docFormat\", null);\n\n// :: ?union<DOMNode, (DOMNode)> #path=place #kind=option\n// Determines the placement of the editor in the page. When `null`,\n// the editor is not placed. When a DOM node is given, the editor is\n// appended to that node. When a function is given, it is called\n// with the editor's wrapping DOM node, and is expected to place it\n// into the document.\ndefineOption(\"place\", null);\n\n// :: number #path=historyDepth #kind=option\n// The amount of history events that are collected before the oldest\n// events are discarded. Defaults to 100.\ndefineOption(\"historyDepth\", 100);\n\n// :: number #path=historyEventDelay #kind=option\n// The amount of milliseconds that must pass between changes to\n// start a new history event. Defaults to 500.\ndefineOption(\"historyEventDelay\", 500);\n\n// :: number #path=scrollThreshold #kind=option\n// The minimum distance to keep between the position of document\n// changes and the editor bounding rectangle before scrolling the view.\n// Defaults to 0.\ndefineOption(\"scrollThreshold\", 0);\n\n// :: number #path=scrollMargin #kind=option\n// Determines how far to scroll when the scroll threshold is\n// surpassed. Defaults to 5.\ndefineOption(\"scrollMargin\", 5);\n\n// :: CommandSet #path=commands #kind=option\n// Specifies the set of [commands](#Command) available in the editor\n// (which in turn determines the base key bindings and items available\n// in the menus). Defaults to `CommandSet.default`.\ndefineOption(\"commands\", _command.CommandSet.default, _command.updateCommands);\n\n// :: ParamPrompt #path=commandParamPrompt #kind=option\n// A default [parameter prompting](#ui/prompt) class to use when a\n// command is [executed](#ProseMirror.execCommand) without providing\n// parameters.\ndefineOption(\"commandParamPrompt\", _prompt.ParamPrompt);\n\n// :: ?string #path=label #kind=option\n// The label of the editor. When set, the editable DOM node gets an\n// `aria-label` attribute with this value.\ndefineOption(\"label\", null);\n\n// :: ?(string) → string #path=translate #kind=option\n// Optional function to translate strings such as menu labels and prompts.\n// When set, should be a function that takes a string as argument and returns\n// a string, i.e. :: (string) → string\ndefineOption(\"translate\", null); // FIXME create a way to explicitly force a menu redraw\n\nfunction parseOptions(obj) {\n  var result = Object.create(null);\n  var given = obj ? [obj].concat(obj.use || []) : [];\n  outer: for (var opt in options) {\n    for (var i = 0; i < given.length; i++) {\n      if (opt in given[i]) {\n        result[opt] = given[i][opt];\n        continue outer;\n      }\n    }\n    result[opt] = options[opt].defaultValue;\n  }\n  return result;\n}\n\nfunction initOptions(pm) {\n  for (var opt in options) {\n    var desc = options[opt];\n    if (desc.update && desc.updateOnInit) desc.update(pm, pm.options[opt], null, true);\n  }\n}\n\nfunction setOption(pm, name, value) {\n  var desc = options[name];\n  if (desc === undefined) throw new RangeError(\"Option '\" + name + \"' is not defined\");\n  if (desc.update === false) throw new RangeError(\"Option '\" + name + \"' can not be changed\");\n  var old = pm.options[name];\n  pm.options[name] = value;\n  if (desc.update) desc.update(pm, value, old, false);\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/options.js\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/options.js?");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParamPrompt = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.openPrompt = openPrompt;\n\nvar _dom = __webpack_require__(10);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// !! The `ui/prompt` module implements functionality for prompting\n// the user for [command parameters](#CommandSpec.params).\n//\n// The default implementation gets the job done, roughly, but you'll\n// probably want to customize it in your own system (or submit patches\n// to improve this implementation).\n\n// ;; This class represents a dialog that prompts for [command\n// parameters](#CommandSpec.params). It is the default value of the\n// `commandParamPrompt` option. You can set this option to a subclass\n// (or a complete reimplementation) to customize the way in which\n// parameters are read.\n\nvar ParamPrompt = exports.ParamPrompt = function () {\n  // :: (ProseMirror, Command)\n  // Construct a prompt. Note that this does not\n  // [open](#ParamPrompt.open) it yet.\n\n  function ParamPrompt(pm, command) {\n    var _this = this;\n\n    _classCallCheck(this, ParamPrompt);\n\n    // :: ProseMirror\n    this.pm = pm;\n    // :: Command\n    this.command = command;\n    this.doClose = null;\n    // :: [DOMNode]\n    // An array of fields, as created by `ParamTypeSpec.render`, for\n    // the command's parameters.\n    this.fields = command.params.map(function (param) {\n      if (!(param.type in _this.paramTypes)) throw new RangeError(\"Unsupported parameter type: \" + param.type);\n      return _this.paramTypes[param.type].render.call(_this.pm, param, _this.defaultValue(param));\n    });\n    var promptTitle = (0, _dom.elt)(\"h5\", {}, command.spec && command.spec.label ? pm.translate(command.spec.label) : \"\");\n    var submitButton = (0, _dom.elt)(\"button\", { type: \"submit\", class: \"ProseMirror-prompt-submit\" }, \"Ok\");\n    var cancelButton = (0, _dom.elt)(\"button\", { type: \"button\", class: \"ProseMirror-prompt-cancel\" }, \"Cancel\");\n    cancelButton.addEventListener(\"click\", function () {\n      return _this.close();\n    });\n    // :: DOMNode\n    // An HTML form wrapping the fields.\n    this.form = (0, _dom.elt)(\"form\", null, promptTitle, this.fields.map(function (f) {\n      return (0, _dom.elt)(\"div\", null, f);\n    }), (0, _dom.elt)(\"div\", { class: \"ProseMirror-prompt-buttons\" }, submitButton, \" \", cancelButton));\n  }\n\n  // :: ()\n  // Close the prompt.\n\n\n  _createClass(ParamPrompt, [{\n    key: \"close\",\n    value: function close() {\n      if (this.doClose) {\n        this.doClose();\n        this.doClose = null;\n      }\n    }\n\n    // :: ()\n    // Open the prompt's dialog.\n\n  }, {\n    key: \"open\",\n    value: function open() {\n      var _this2 = this;\n\n      this.close();\n      var prompt = this.prompt();\n      var hadFocus = this.pm.hasFocus();\n      this.doClose = function () {\n        prompt.close();\n        if (hadFocus) setTimeout(function () {\n          return _this2.pm.focus();\n        }, 50);\n      };\n\n      var submit = function submit() {\n        var params = _this2.values();\n        if (params) {\n          _this2.close();\n          _this2.command.exec(_this2.pm, params);\n        }\n      };\n\n      this.form.addEventListener(\"submit\", function (e) {\n        e.preventDefault();\n        submit();\n      });\n\n      this.form.addEventListener(\"keydown\", function (e) {\n        if (e.keyCode == 27) {\n          e.preventDefault();\n          prompt.close();\n        } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {\n          e.preventDefault();\n          submit();\n        }\n      });\n\n      var input = this.form.querySelector(\"input, textarea\");\n      if (input) input.focus();\n    }\n\n    // :: () → ?[any]\n    // Read the values from the form's field. Validate them, and when\n    // one isn't valid (either has a validate function that produced an\n    // error message, or has no validate function, no value, and no\n    // default value), show the problem to the user and return `null`.\n\n  }, {\n    key: \"values\",\n    value: function values() {\n      var result = [];\n      for (var i = 0; i < this.command.params.length; i++) {\n        var param = this.command.params[i],\n            dom = this.fields[i];\n        var type = this.paramTypes[param.type],\n            value = undefined,\n            bad = undefined;\n        if (type.validate) bad = type.validate(dom);\n        if (!bad) {\n          value = type.read.call(this.pm, dom);\n          if (param.validate) bad = param.validate(value);else if (!value && param.default == null) bad = \"No default value available\";\n        }\n\n        if (bad) {\n          if (type.reportInvalid) type.reportInvalid.call(this.pm, dom, bad);else this.reportInvalid(dom, bad);\n          return null;\n        }\n        result.push(value);\n      }\n      return result;\n    }\n\n    // :: (CommandParam) → ?any\n    // Get a parameter's default value, if any.\n\n  }, {\n    key: \"defaultValue\",\n    value: function defaultValue(param) {\n      if (param.prefill) {\n        var prefill = param.prefill.call(this.command.self, this.pm);\n        if (prefill != null) return prefill;\n      }\n      return param.default;\n    }\n\n    // :: () → {close: ()}\n    // Open a prompt with the parameter form in it. The default\n    // implementation calls `openPrompt`.\n\n  }, {\n    key: \"prompt\",\n    value: function prompt() {\n      var _this3 = this;\n\n      return openPrompt(this.pm, this.form, { onClose: function onClose() {\n          return _this3.close();\n        } });\n    }\n\n    // :: (DOMNode, string)\n    // Report a field as invalid, showing the given message to the user.\n\n  }, {\n    key: \"reportInvalid\",\n    value: function reportInvalid(dom, message) {\n      // FIXME this is awful and needs a lot more work\n      var parent = dom.parentNode;\n      var style = \"left: \" + (dom.offsetLeft + dom.offsetWidth + 2) + \"px; top: \" + (dom.offsetTop - 5) + \"px\";\n      var msg = parent.appendChild((0, _dom.elt)(\"div\", { class: \"ProseMirror-invalid\", style: style }, message));\n      setTimeout(function () {\n        return parent.removeChild(msg);\n      }, 1500);\n    }\n  }]);\n\n  return ParamPrompt;\n}();\n\n// ;; #path=ParamTypeSpec #kind=interface\n// By default, the prompting interface only knows how to prompt for\n// parameters of type `text` and `select`. You can change the way\n// those are prompted for, and define new types, by writing to\n// `ParamPrompt.paramTypes`. All methods on these specs will be called\n// with `this` bound to the relevant `ProseMirror` instance.\n\n// :: (param: CommandParam, value: ?any) → DOMNode #path=ParamTypeSpec.render\n// Create the DOM structure for a parameter field of this type, and\n// pre-fill it with `value`, if given.\n\n// :: (field: DOMNode) → any #path=ParamTypeSpec.read\n// Read the value from the DOM field created by\n// [`render`](#ParamTypeSpec.render).\n\n// :: (field: DOMNode) → ?string #path=ParamTypeSpec.validate\n// Optional. Validate the value in the given field, and return a\n// string message if it is not a valid input for this type.\n\n// :: (field: DOMNode, message: string) #path=ParamTypeSpec.reportInvalid\n// Report the value in the given field as invalid, showing the given\n// error message. This property is optional, and the prompt\n// implementation will fall back to its own method of showing the\n// message when it is not provided.\n\n// :: Object<ParamTypeSpec>\n// A collection of default renderers and readers for [parameter\n// types](#CommandParam.type), which [parameter\n// handlers](#commandParamHandler) can optionally use to prompt for\n// parameters. `render` should create a form field for the parameter,\n// and `read` should, given that field, return its value.\n\n\nParamPrompt.prototype.paramTypes = Object.create(null);\n\nParamPrompt.prototype.paramTypes.text = {\n  render: function render(param, value) {\n    return (0, _dom.elt)(\"input\", { type: \"text\",\n      placeholder: this.translate(param.label),\n      value: value,\n      autocomplete: \"off\" });\n  },\n  read: function read(dom) {\n    return dom.value;\n  }\n};\n\nParamPrompt.prototype.paramTypes.select = {\n  render: function render(param, value) {\n    var _this4 = this;\n\n    var options = param.options.call ? param.options(this) : param.options;\n    return (0, _dom.elt)(\"select\", null, options.map(function (o) {\n      return (0, _dom.elt)(\"option\", { value: o.value, selected: o.value == value ? \"true\" : null }, _this4.translate(o.label));\n    }));\n  },\n  read: function read(dom) {\n    return dom.value;\n  }\n};\n\n// :: (ProseMirror, DOMNode, ?Object) → {close: ()}\n// Open a dialog box for the given editor, putting `content` inside of\n// it. The `close` method on the return value can be used to\n// explicitly close the dialog again. The following options are\n// supported:\n//\n// **`pos`**`: {left: number, top: number}`\n//   : Provide an explicit position for the element. By default, it'll\n//     be placed in the center of the editor.\n//\n// **`onClose`**`: fn()`\n//   : A function to be called when the dialog is closed.\nfunction openPrompt(pm, content, options) {\n  var button = (0, _dom.elt)(\"button\", { class: \"ProseMirror-prompt-close\" });\n  var wrapper = (0, _dom.elt)(\"div\", { class: \"ProseMirror-prompt\" }, content, button);\n  var outerBox = pm.wrapper.getBoundingClientRect();\n\n  pm.wrapper.appendChild(wrapper);\n  if (options && options.pos) {\n    wrapper.style.left = options.pos.left - outerBox.left + \"px\";\n    wrapper.style.top = options.pos.top - outerBox.top + \"px\";\n  } else {\n    var blockBox = wrapper.getBoundingClientRect();\n    var cX = Math.max(0, outerBox.left) + Math.min(window.innerWidth, outerBox.right) - blockBox.width;\n    var cY = Math.max(0, outerBox.top) + Math.min(window.innerHeight, outerBox.bottom) - blockBox.height;\n    wrapper.style.left = cX / 2 - outerBox.left + \"px\";\n    wrapper.style.top = cY / 2 - outerBox.top + \"px\";\n  }\n\n  var close = function close() {\n    pm.off(\"interaction\", close);\n    if (wrapper.parentNode) {\n      wrapper.parentNode.removeChild(wrapper);\n      if (options && options.onClose) options.onClose();\n    }\n  };\n  button.addEventListener(\"click\", close);\n  pm.on(\"interaction\", close);\n  return { close: close };\n}\n\n(0, _dom.insertCSS)(\"\\n.ProseMirror-prompt {\\n  background: white;\\n  padding: 2px 6px 2px 15px;\\n  border: 1px solid silver;\\n  position: absolute;\\n  border-radius: 3px;\\n  z-index: 11;\\n}\\n\\n.ProseMirror-prompt h5 {\\n  margin: 0;\\n  font-weight: normal;\\n  font-size: 100%;\\n  color: #444;\\n}\\n\\n.ProseMirror-prompt input[type=\\\"text\\\"],\\n.ProseMirror-prompt textarea {\\n  background: #eee;\\n  border: none;\\n  outline: none;\\n}\\n\\n.ProseMirror-prompt input[type=\\\"text\\\"] {\\n  padding: 0 4px;\\n}\\n\\n.ProseMirror-prompt-close {\\n  position: absolute;\\n  left: 2px; top: 1px;\\n  color: #666;\\n  border: none; background: transparent; padding: 0;\\n}\\n\\n.ProseMirror-prompt-close:after {\\n  content: \\\"✕\\\";\\n  font-size: 12px;\\n}\\n\\n.ProseMirror-invalid {\\n  background: #ffc;\\n  border: 1px solid #cc7;\\n  border-radius: 4px;\\n  padding: 5px 10px;\\n  position: absolute;\\n  min-width: 10em;\\n}\\n\\n.ProseMirror-prompt-buttons {\\n  margin-top: 5px;\\n  display: none;\\n}\\n\\n\");\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/ui/prompt.js\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/ui/prompt.js?");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommandSet = exports.Command = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.updateCommands = updateCommands;\nexports.selectedNodeAttr = selectedNodeAttr;\n\nvar _browserkeymap = __webpack_require__(11);\n\nvar _browserkeymap2 = _interopRequireDefault(_browserkeymap);\n\nvar _model = __webpack_require__(18);\n\nvar _transform = __webpack_require__(38);\n\nvar _dom = __webpack_require__(10);\n\nvar _sortedinsert = __webpack_require__(12);\n\nvar _sortedinsert2 = _interopRequireDefault(_sortedinsert);\n\nvar _obj = __webpack_require__(28);\n\nvar _base_commands = __webpack_require__(47);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; A command is a named piece of functionality that can be bound to\n// a key, shown in the menu, or otherwise exposed to the user.\n//\n// The commands available in a given editor are determined by the\n// `commands` option. By default, they come from the `baseCommands`\n// object and the commands [registered](#SchemaItem.register) with\n// schema items. Registering a `CommandSpec` on a [node](#NodeType) or\n// [mark](#MarkType) type will cause that command to come into scope\n// in editors whose schema includes that item.\n\nvar Command = exports.Command = function () {\n  function Command(spec, self, name) {\n    _classCallCheck(this, Command);\n\n    // :: string The name of the command.\n    this.name = name;\n    if (!this.name) throw new RangeError(\"Trying to define a command without a name\");\n    // :: CommandSpec The command's specifying object.\n    this.spec = spec;\n    this.self = self;\n  }\n\n  // :: (ProseMirror, ?[any]) → ?bool\n  // Execute this command. If the command takes\n  // [parameters](#Command.params), they can be passed as second\n  // argument here, or otherwise the user will be prompted for them\n  // using the value of the `commandParamPrompt` option.\n  //\n  // Returns the value returned by the command spec's [`run`\n  // method](#CommandSpec.run), or a `ParamPrompt` instance if the\n  // command is ran asynchronously through a prompt.\n\n\n  _createClass(Command, [{\n    key: \"exec\",\n    value: function exec(pm, params) {\n      var run = this.spec.run;\n      if (!params) {\n        if (!this.params.length) return run.call(this.self, pm);\n        return new pm.options.commandParamPrompt(pm, this).open();\n      } else {\n        if (this.params.length != (params ? params.length : 0)) throw new RangeError(\"Invalid amount of parameters for command \" + this.name);\n        return run.call.apply(run, [this.self, pm].concat(_toConsumableArray(params)));\n      }\n    }\n\n    // :: (ProseMirror) → bool\n    // Ask this command whether it is currently relevant, given the\n    // editor's document and selection. If the command does not define a\n    // [`select`](#CommandSpec.select) method, this always returns true.\n\n  }, {\n    key: \"select\",\n    value: function select(pm) {\n      var f = this.spec.select;\n      return f ? f.call(this.self, pm) : true;\n    }\n\n    // :: (ProseMirror) → bool\n    // Ask this command whether it is “active”. This is mostly used to\n    // style inline mark icons (such as strong) differently when the\n    // selection contains such marks.\n\n  }, {\n    key: \"active\",\n    value: function active(pm) {\n      var f = this.spec.active;\n      return f ? f.call(this.self, pm) : false;\n    }\n\n    // :: [CommandParam]\n    // Get the list of parameters that this command expects.\n\n  }, {\n    key: \"params\",\n    get: function get() {\n      return this.spec.params || empty;\n    }\n\n    // :: string\n    // Get the label for this command.\n\n  }, {\n    key: \"label\",\n    get: function get() {\n      return this.spec.label || this.name;\n    }\n  }]);\n\n  return Command;\n}();\n\nvar empty = [];\n\nfunction deriveCommandSpec(type, spec, name) {\n  if (!spec.derive) return spec;\n  var conf = _typeof(spec.derive) == \"object\" ? spec.derive : {};\n  var dname = conf.name || name;\n  var derive = type.constructor.derivableCommands[dname];\n  if (!derive) throw new RangeError(\"Don't know how to derive command \" + dname);\n  var derived = derive.call(type, conf);\n  for (var prop in spec) {\n    if (prop != \"derive\") derived[prop] = spec[prop];\n  }return derived;\n}\n\n// ;; The type used as the value of the `commands` option. Allows you\n// to specify the set of commands that are available in the editor by\n// adding and modifying command specs.\n\nvar CommandSet = function () {\n  function CommandSet(base, op) {\n    _classCallCheck(this, CommandSet);\n\n    this.base = base;\n    this.op = op;\n  }\n\n  // :: (union<Object<CommandSpec>, \"schema\">, ?(string, CommandSpec) → bool) → CommandSet\n  // Add a set of commands, creating a new command set. If `set` is\n  // the string `\"schema\"`, the commands are retrieved from the\n  // editor's schema's [registry](#Schema.registry), otherwise, it\n  // should be an object mapping command names to command specs.\n  //\n  // A filter function can be given to add only the commands for which\n  // the filter returns true.\n\n\n  _createClass(CommandSet, [{\n    key: \"add\",\n    value: function add(set, filter) {\n      return new CommandSet(this, function (commands, schema) {\n        function add(name, spec, self) {\n          if (!filter || filter(name, spec)) {\n            if (commands[name]) throw new RangeError(\"Duplicate definition of command \" + name);\n            commands[name] = new Command(spec, self, name);\n          }\n        }\n\n        if (set === \"schema\") {\n          schema.registry(\"command\", function (name, spec, type, typeName) {\n            add(typeName + \":\" + name, deriveCommandSpec(type, spec, name), type);\n          });\n        } else {\n          for (var name in set) {\n            add(name, set[name]);\n          }\n        }\n      });\n    }\n\n    // :: (Object<?CommandSpec>) → CommandSet\n    // Create a new command set by adding, modifying, or deleting\n    // commands. The `update` object can map a command name to `null` to\n    // delete it, to a full `CommandSpec` (containing a `run` property)\n    // to add it, or to a partial `CommandSpec` (without a `run`\n    // property) to update some properties in the command by that name.\n\n  }, {\n    key: \"update\",\n    value: function update(_update) {\n      return new CommandSet(this, function (commands) {\n        for (var name in _update) {\n          var spec = _update[name];\n          if (!spec) {\n            delete commands[name];\n          } else if (spec.run) {\n            commands[name] = new Command(spec, null, name);\n          } else {\n            var known = commands[name];\n            if (known) commands[name] = new Command((0, _obj.copyObj)(spec, (0, _obj.copyObj)(known.spec)), known.self, name);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"derive\",\n    value: function derive(schema) {\n      var commands = this.base ? this.base.derive(schema) : Object.create(null);\n      this.op(commands, schema);\n      return commands;\n    }\n  }]);\n\n  return CommandSet;\n}();\n\n// :: CommandSet\n// A set without any commands.\n\n\nexports.CommandSet = CommandSet;\nCommandSet.empty = new CommandSet(null, function () {\n  return null;\n});\n\n// :: CommandSet\n// The default value of the `commands` option. Includes the [base\n// commands](#baseCommands) and the commands defined by the schema.\nCommandSet.default = CommandSet.empty.add(\"schema\").add(_base_commands.baseCommands);\n\n// ;; #path=CommandSpec #kind=interface\n// Commands are defined using objects that specify various aspects of\n// the command. The only property that _must_ appear in a command spec\n// is [`run`](#CommandSpec.run). You should probably also give your\n// commands a `label`.\n\n// :: string #path=CommandSpec.label\n// A user-facing label for the command. This will be used, among other\n// things. as the tooltip title for the command's menu item. If there\n// is no `label`, the command's `name` will be used instead.\n\n// :: (pm: ProseMirror, ...params: [any]) → ?bool #path=CommandSpec.run\n// The function that executes the command. If the command has\n// [parameters](#CommandSpec.params), their values are passed as\n// arguments. For commands [registered](#SchemaItem.register) on node or\n// mark types, `this` will be bound to the node or mark type when this\n// function is ran. Should return `false` when the command could not\n// be executed.\n\n// :: [CommandParam] #path=CommandSpec.params\n// The parameters that this command expects.\n\n// :: (pm: ProseMirror) → bool #path=CommandSpec.select\n// The function used to [select](#Command.select) the command. `this`\n// will again be bound to a node or mark type, when available.\n\n// :: (pm: ProseMirror) → bool #path=CommandSpec.active\n// The function used to determine whether the command is\n// [active](#Command.active). `this` refers to the associated node or\n// mark type.\n\n// :: union<Object<[string]>, [string]> #path=CommandSpec.keys\n// The default key bindings for this command. May either be an array\n// of strings containing [key\n// names](https://github.com/marijnh/browserkeymap#a-string-notation-for-key-events),\n// or an object with optional `all`, `mac`, and `pc` properties,\n// specifying arrays of keys for different platforms.\n\n// :: union<bool, Object> #path=CommandSpec.derive\n// [Mark](#MarkType) and [node](#NodeType) types often need to define\n// boilerplate commands. To reduce the amount of duplicated code, you\n// can derive such commands by setting the `derive` property to either\n// `true` or an object which is passed to the deriving function. If\n// this object has a `name` property, that is used, instead of the\n// command name, to pick a deriving function.\n//\n// For node types, you can derive `\"insert\"`, `\"make\"`, and `\"wrap\"`.\n//\n// For mark types, you can derive `\"set\"`, `\"unset\"`, and `\"toggle\"`.\n\n// ;; #path=CommandParam #kind=interface\n// The parameters that a command can take are specified using objects\n// with the following properties:\n\n// :: string #path=CommandParam.label\n// The user-facing name of the parameter. Shown to the user when\n// prompting for this parameter.\n\n// :: string #path=CommandParam.type\n// The type of the parameter. Supported types are `\"text\"` and `\"select\"`.\n\n// :: any #path=CommandParam.default\n// A default value for the parameter.\n\n// :: (ProseMirror) → ?any #path=CommandParam.prefill\n// A function that, given an editor instance (and a `this` bound to\n// the command's source item), tries to derive an initial value for\n// the parameter, or return null if it can't.\n\n// :: (any) → ?string #path=CommandParam.validate\n// An optional function that is called to validate values provided for\n// this parameter. Should return a falsy value when the value is\n// valid, and an error message when it is not.\n\nfunction deriveKeymap(pm) {\n  var bindings = {},\n      platform = _dom.browser.mac ? \"mac\" : \"pc\";\n  function add(command, keys) {\n    for (var i = 0; i < keys.length; i++) {\n      var _$exec = /^(.+?)(?:\\((\\d+)\\))?$/.exec(keys[i]);\n\n      var _$exec2 = _slicedToArray(_$exec, 3);\n\n      var _ = _$exec2[0];\n      var name = _$exec2[1];\n      var _$exec2$ = _$exec2[2];\n      var rank = _$exec2$ === undefined ? 50 : _$exec2$;\n\n      (0, _sortedinsert2.default)(bindings[name] || (bindings[name] = []), { command: command, rank: rank }, function (a, b) {\n        return a.rank - b.rank;\n      });\n    }\n  }\n  for (var name in pm.commands) {\n    var cmd = pm.commands[name],\n        keys = cmd.spec.keys;\n    if (!keys) continue;\n    if (Array.isArray(keys)) {\n      add(cmd, keys);\n    } else {\n      if (keys.all) add(cmd, keys.all);\n      if (keys[platform]) add(cmd, keys[platform]);\n    }\n  }\n\n  for (var key in bindings) {\n    bindings[key] = bindings[key].map(function (b) {\n      return b.command.name;\n    });\n  }return new _browserkeymap2.default(bindings);\n}\n\nfunction updateCommands(pm, set) {\n  // :: () #path=ProseMirror#events#commandsChanging\n  // Fired before the set of commands for the editor is updated.\n  pm.signal(\"commandsChanging\");\n  pm.commands = set.derive(pm.schema);\n  pm.input.baseKeymap = deriveKeymap(pm);\n  pm.commandKeys = Object.create(null);\n  // :: () #path=ProseMirror#events#commandsChanged\n  // Fired when the set of commands for the editor is updated.\n  pm.signal(\"commandsChanged\");\n}\n\nfunction markActive(pm, type) {\n  var sel = pm.selection;\n  if (sel.empty) return type.isInSet(pm.activeMarks());else return pm.doc.rangeHasMark(sel.from, sel.to, type);\n}\n\nfunction canAddMark(pm, type) {\n  var _pm$selection = pm.selection;\n  var from = _pm$selection.from;\n  var to = _pm$selection.to;\n  var empty = _pm$selection.empty;var $from = undefined;\n  if (empty) return !type.isInSet(pm.activeMarks()) && ($from = pm.doc.resolve(from)) && $from.parent.contentMatchAt($from.index()).allowsMark(type);\n  var can = false;\n  pm.doc.nodesBetween(from, to, function (node, _, parent, i) {\n    if (can) return false;\n    can = node.isInline && !type.isInSet(node.marks) && parent.contentMatchAt(i + 1).allowsMark(type);\n  });\n  return can;\n}\n\nfunction markApplies(pm, type) {\n  var _pm$selection2 = pm.selection;\n  var from = _pm$selection2.from;\n  var to = _pm$selection2.to;\n\n  var relevant = false;\n  pm.doc.nodesBetween(from, to, function (node, _, parent, i) {\n    if (relevant) return false;\n    relevant = node.isTextblock && node.contentMatchAt(0).allowsMark(type) || node.isInline && parent.contentMatchAt(i + 1).allowsMark(type);\n  });\n  return relevant;\n}\n\nfunction selectedMarkAttr(pm, type, attr) {\n  var _pm$selection3 = pm.selection;\n  var from = _pm$selection3.from;\n  var to = _pm$selection3.to;\n  var empty = _pm$selection3.empty;\n\n  var start = undefined,\n      end = undefined;\n  if (empty) {\n    start = end = type.isInSet(pm.activeMarks());\n  } else {\n    var startChunk = pm.doc.resolve(from).nodeAfter;\n    start = startChunk ? type.isInSet(startChunk.marks) : null;\n    end = type.isInSet(pm.doc.marksAt(to));\n  }\n  if (start && end && start.attrs[attr] == end.attrs[attr]) return start.attrs[attr];\n}\n\nfunction selectedNodeAttr(pm, type, name) {\n  var node = pm.selection.node;\n\n  if (node && node.type == type) return node.attrs[name];\n}\n\nfunction deriveParams(type, params) {\n  return params && params.map(function (param) {\n    var attr = type.attrs[param.attr];\n    var obj = { type: \"text\",\n      default: attr.default,\n      prefill: type instanceof _model.NodeType ? function (pm) {\n        return selectedNodeAttr(pm, this, param.attr);\n      } : function (pm) {\n        return selectedMarkAttr(pm, this, param.attr);\n      } };\n    for (var prop in param) {\n      obj[prop] = param[prop];\n    }return obj;\n  });\n}\n\nfunction fillAttrs(conf, givenParams) {\n  var attrs = conf.attrs;\n  if (conf.params) {\n    (function () {\n      var filled = Object.create(null);\n      if (attrs) for (var name in attrs) {\n        filled[name] = attrs[name];\n      }conf.params.forEach(function (param, i) {\n        return filled[param.attr] = givenParams[i];\n      });\n      attrs = filled;\n    })();\n  }\n  return attrs;\n}\n\n_model.NodeType.derivableCommands = Object.create(null);\n_model.MarkType.derivableCommands = Object.create(null);\n\n_model.MarkType.derivableCommands.set = function (conf) {\n  return {\n    run: function run(pm) {\n      for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        params[_key - 1] = arguments[_key];\n      }\n\n      pm.setMark(this, true, fillAttrs(conf, params));\n    },\n    select: function select(pm) {\n      return conf.inverseSelect ? markApplies(pm, this) && !markActive(pm, this) : canAddMark(pm, this);\n    },\n\n    params: deriveParams(this, conf.params)\n  };\n};\n\n_model.MarkType.derivableCommands.unset = function () {\n  return {\n    run: function run(pm) {\n      pm.setMark(this, false);\n    },\n    select: function select(pm) {\n      return markActive(pm, this);\n    }\n  };\n};\n\n_model.MarkType.derivableCommands.toggle = function () {\n  return {\n    run: function run(pm) {\n      pm.setMark(this, null);\n    },\n    active: function active(pm) {\n      return markActive(pm, this);\n    },\n    select: function select(pm) {\n      return markApplies(pm, this);\n    }\n  };\n};\n\nfunction isAtTopOfListItem(doc, from, to, listType) {\n  var $from = doc.resolve(from);\n  return $from.sameParent(doc.resolve(to)) && $from.depth >= 2 && $from.index(-1) == 0 && $from.node(-2).type.compatibleContent(listType);\n}\n\n_model.NodeType.derivableCommands.wrap = function (conf) {\n  return {\n    run: function run(pm) {\n      var _pm$selection4 = pm.selection;\n      var from = _pm$selection4.from;\n      var to = _pm$selection4.to;\n      var head = _pm$selection4.head;var doJoin = false;\n      var $from = pm.doc.resolve(from);\n      if (conf.list && head && isAtTopOfListItem(pm.doc, from, to, this)) {\n        // Don't do anything if this is the top of the list\n        if ($from.index(-2) == 0) return false;\n        doJoin = true;\n      }\n\n      for (var _len2 = arguments.length, params = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      var tr = pm.tr.wrap(from, to, this, fillAttrs(conf, params));\n      if (doJoin) tr.join($from.before(-1));\n      return tr.apply(pm.apply.scroll);\n    },\n    select: function select(pm) {\n      var _pm$selection5 = pm.selection;\n      var from = _pm$selection5.from;\n      var to = _pm$selection5.to;\n      var head = _pm$selection5.head;\n\n      if (conf.list && head && isAtTopOfListItem(pm.doc, from, to, this) && pm.doc.resolve(from).index(-2) == 0) return false;\n      return (0, _transform.canWrap)(pm.doc, from, to, this);\n    },\n\n    params: deriveParams(this, conf.params)\n  };\n};\n\nfunction alreadyHasBlockType(doc, from, to, type, attrs) {\n  var found = false;\n  if (!attrs) attrs = {};\n  doc.nodesBetween(from, to || from, function (node) {\n    if (node.isTextblock) {\n      if (node.hasMarkup(type, attrs)) found = true;\n      return false;\n    }\n  });\n  return found;\n}\n\nfunction activeTextblockIs(pm, type, attrs) {\n  var _pm$selection6 = pm.selection;\n  var from = _pm$selection6.from;\n  var to = _pm$selection6.to;\n  var node = _pm$selection6.node;\n\n  if (!node || node.isInline) {\n    var $from = pm.doc.resolve(from);\n    if (!$from.sameParent(pm.doc.resolve(to))) return false;\n    node = $from.parent;\n  } else if (!node.isTextblock) {\n    return false;\n  }\n  return node.hasMarkup(type, attrs);\n}\n\n_model.NodeType.derivableCommands.make = function (conf) {\n  return {\n    run: function run(pm) {\n      var _pm$selection7 = pm.selection;\n      var from = _pm$selection7.from;\n      var to = _pm$selection7.to;\n\n      return pm.tr.setBlockType(from, to, this, conf.attrs).apply(pm.apply.scroll);\n    },\n    select: function select(pm) {\n      var _pm$selection8 = pm.selection;\n      var from = _pm$selection8.from;\n      var to = _pm$selection8.to;\n      var node = _pm$selection8.node;var depth = undefined;\n      if (node) {\n        if (!node.isTextblock || node.hasMarkup(this, conf.attrs)) return false;\n        depth = 0;\n      } else {\n        if (alreadyHasBlockType(pm.doc, from, to, this, conf.attrs)) return false;\n        depth = 1;\n      }\n      var $from = pm.doc.resolve(from),\n          parentDepth = $from.depth - depth,\n          index = $from.index(parentDepth);\n      return $from.node(parentDepth).canReplaceWith(index, index + 1, this, conf.attrs);\n    },\n    active: function active(pm) {\n      return activeTextblockIs(pm, this, conf.attrs);\n    }\n  };\n};\n\n_model.NodeType.derivableCommands.insert = function (conf) {\n  return {\n    run: function run(pm) {\n      for (var _len3 = arguments.length, params = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        params[_key3 - 1] = arguments[_key3];\n      }\n\n      return pm.tr.replaceSelection(this.create(fillAttrs(conf, params))).apply(pm.apply.scroll);\n    },\n\n    select: this.isInline ? function (pm) {\n      var $from = pm.doc.resolve(pm.selection.from),\n          index = $from.index();\n      return $from.parent.canReplaceWith(index, index, this);\n    } : null,\n    params: deriveParams(this, conf.params)\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/command.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/command.js?");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReplaceAroundStep = exports.ReplaceStep = exports.RemoveMarkStep = exports.AddMarkStep = exports.Remapping = exports.MapResult = exports.PosMap = exports.canSplit = exports.joinable = exports.joinPoint = exports.canLift = exports.canWrap = exports.StepResult = exports.Step = exports.TransformError = exports.Transform = undefined;\n\nvar _transform = __webpack_require__(39);\n\nObject.defineProperty(exports, \"Transform\", {\n  enumerable: true,\n  get: function get() {\n    return _transform.Transform;\n  }\n});\nObject.defineProperty(exports, \"TransformError\", {\n  enumerable: true,\n  get: function get() {\n    return _transform.TransformError;\n  }\n});\n\nvar _step = __webpack_require__(41);\n\nObject.defineProperty(exports, \"Step\", {\n  enumerable: true,\n  get: function get() {\n    return _step.Step;\n  }\n});\nObject.defineProperty(exports, \"StepResult\", {\n  enumerable: true,\n  get: function get() {\n    return _step.StepResult;\n  }\n});\n\nvar _structure = __webpack_require__(42);\n\nObject.defineProperty(exports, \"canWrap\", {\n  enumerable: true,\n  get: function get() {\n    return _structure.canWrap;\n  }\n});\nObject.defineProperty(exports, \"canLift\", {\n  enumerable: true,\n  get: function get() {\n    return _structure.canLift;\n  }\n});\nObject.defineProperty(exports, \"joinPoint\", {\n  enumerable: true,\n  get: function get() {\n    return _structure.joinPoint;\n  }\n});\nObject.defineProperty(exports, \"joinable\", {\n  enumerable: true,\n  get: function get() {\n    return _structure.joinable;\n  }\n});\nObject.defineProperty(exports, \"canSplit\", {\n  enumerable: true,\n  get: function get() {\n    return _structure.canSplit;\n  }\n});\n\nvar _map = __webpack_require__(40);\n\nObject.defineProperty(exports, \"PosMap\", {\n  enumerable: true,\n  get: function get() {\n    return _map.PosMap;\n  }\n});\nObject.defineProperty(exports, \"MapResult\", {\n  enumerable: true,\n  get: function get() {\n    return _map.MapResult;\n  }\n});\nObject.defineProperty(exports, \"Remapping\", {\n  enumerable: true,\n  get: function get() {\n    return _map.Remapping;\n  }\n});\n\nvar _mark_step = __webpack_require__(44);\n\nObject.defineProperty(exports, \"AddMarkStep\", {\n  enumerable: true,\n  get: function get() {\n    return _mark_step.AddMarkStep;\n  }\n});\nObject.defineProperty(exports, \"RemoveMarkStep\", {\n  enumerable: true,\n  get: function get() {\n    return _mark_step.RemoveMarkStep;\n  }\n});\n\nvar _replace_step = __webpack_require__(43);\n\nObject.defineProperty(exports, \"ReplaceStep\", {\n  enumerable: true,\n  get: function get() {\n    return _replace_step.ReplaceStep;\n  }\n});\nObject.defineProperty(exports, \"ReplaceAroundStep\", {\n  enumerable: true,\n  get: function get() {\n    return _replace_step.ReplaceAroundStep;\n  }\n});\n\n__webpack_require__(45);\n\n__webpack_require__(46);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/index.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/index.js?");

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transform = exports.TransformError = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _error = __webpack_require__(24);\n\nvar _map = __webpack_require__(40);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TransformError = exports.TransformError = function (_ProseMirrorError) {\n  _inherits(TransformError, _ProseMirrorError);\n\n  function TransformError() {\n    _classCallCheck(this, TransformError);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(TransformError).apply(this, arguments));\n  }\n\n  return TransformError;\n}(_error.ProseMirrorError);\n\n// ;; A change to a document often consists of a series of\n// [steps](#Step). This class provides a convenience abstraction to\n// build up and track such an array of steps. A `Transform` object\n// implements `Mappable`.\n//\n// The high-level transforming methods return the `Transform` object\n// itself, so that they can be chained.\n\n\nvar Transform = function () {\n  // :: (Node)\n  // Create a transformation that starts with the given document.\n\n  function Transform(doc) {\n    _classCallCheck(this, Transform);\n\n    this.doc = doc;\n    this.docs = [];\n    this.steps = [];\n    this.maps = [];\n  }\n\n  // :: Node The document at the start of the transformation.\n\n\n  _createClass(Transform, [{\n    key: \"step\",\n\n\n    // :: (Step) → Transform\n    // Apply a new step in this transformation, saving the result.\n    // Throws an error when the step fails.\n    value: function step(_step) {\n      var result = this.maybeStep(_step);\n      if (result.failed) throw new TransformError(result.failed);\n      return this;\n    }\n\n    // :: (Step) → StepResult\n    // Apply a new step in this transformation, returning the step\n    // result.\n\n  }, {\n    key: \"maybeStep\",\n    value: function maybeStep(step) {\n      var result = step.apply(this.doc);\n      if (!result.failed) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.maps.push(step.posMap());\n        this.doc = result.doc;\n      }\n      return result;\n    }\n\n    // :: (number, ?number) → MapResult\n    // Map a position through the whole transformation (all the position\n    // maps in [`maps`](#Transform.maps)), and return the result.\n\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos, bias, start) {\n      return (0, _map.mapThroughResult)(this.maps, pos, bias, start);\n    }\n\n    // :: (number, ?number) → number\n    // Map a position through the whole transformation, and return the\n    // mapped position.\n\n  }, {\n    key: \"map\",\n    value: function map(pos, bias, start) {\n      return (0, _map.mapThrough)(this.maps, pos, bias, start);\n    }\n  }, {\n    key: \"before\",\n    get: function get() {\n      return this.docs.length ? this.docs[0] : this.doc;\n    }\n  }]);\n\n  return Transform;\n}();\n\nexports.Transform = Transform;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/transform.js\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/transform.js?");

/***/ },
/* 40 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.mapThrough = mapThrough;\nexports.mapThroughResult = mapThroughResult;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; #path=Mappable #kind=interface\n// There are various things that positions can be mapped through.\n// We'll denote those as 'mappable'. This is not an actual class in\n// the codebase, only an agreed-on interface.\n\n// :: (pos: number, bias: ?number) → number #path=Mappable.map\n// Map a position through this object. When given, the `bias`\n// determines in which direction to move when a chunk of content is\n// inserted at or around the mapped position.\n\n// :: (pos: number, bias: ?number) → MapResult #path=Mappable.mapResult\n// Map a position, and return an object containing additional\n// information about the mapping. The result's `deleted` field tells\n// you whether the position was deleted (completely enclosed in a\n// replaced range) during the mapping.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of marked ranges. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) {\n  return index + offset * factor16;\n}\nfunction recoverIndex(value) {\n  return value & lower16;\n}\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n}\n\n// ;; The return value of mapping a position.\n\nvar MapResult = exports.MapResult = function MapResult(pos) {\n  var deleted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n  var recover = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n  _classCallCheck(this, MapResult);\n\n  // :: number The mapped version of the position.\n  this.pos = pos;\n  // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n  this.deleted = deleted;\n  this.recover = recover;\n};\n\n// ;; A position map, holding information about the way positions in\n// the pre-step version of a document correspond to positions in the\n// post-step version. This class implements `Mappable`.\n\n\nvar PosMap = exports.PosMap = function () {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents an [start, oldSize, newSize] chunk.\n\n  function PosMap(ranges) {\n    var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n    _classCallCheck(this, PosMap);\n\n    this.ranges = ranges;\n    this.inverted = inverted;\n  }\n\n  _createClass(PosMap, [{\n    key: \"recover\",\n    value: function recover(value) {\n      var diff = 0,\n          index = recoverIndex(value);\n      if (!this.inverted) for (var i = 0; i < index; i++) {\n        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n      }return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n\n    // :: (number, ?number) → MapResult\n    // Map the given position through this map. The `bias` parameter can\n    // be used to control what happens when the transform inserted\n    // content at (or around) this position—if `bias` is negative, the a\n    // position before the inserted content will be returned, if it is\n    // positive, a position after the insertion is returned.\n\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos, bias) {\n      return this._map(pos, bias, false);\n    }\n\n    // :: (number, ?number) → number\n    // Map the given position through this map, returning only the\n    // mapped position.\n\n  }, {\n    key: \"map\",\n    value: function map(pos, bias) {\n      return this._map(pos, bias, true);\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(pos, bias, simple) {\n      var diff = 0,\n          oldIndex = this.inverted ? 2 : 1,\n          newIndex = this.inverted ? 1 : 2;\n      for (var i = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos) break;\n        var oldSize = this.ranges[i + oldIndex],\n            newSize = this.ranges[i + newIndex],\n            end = start + oldSize;\n        if (pos <= end) {\n          var side = !oldSize ? bias : pos == start ? -1 : pos == end ? 1 : bias;\n          var result = start + diff + (side < 0 ? 0 : newSize);\n          if (simple) return result;\n          var recover = makeRecover(i / 3, pos - start);\n          return new MapResult(result, pos != start && pos != end, recover);\n        }\n        diff += newSize - oldSize;\n      }\n      return simple ? pos + diff : new MapResult(pos + diff);\n    }\n  }, {\n    key: \"touches\",\n    value: function touches(pos, recover) {\n      var diff = 0,\n          index = recoverIndex(recover);\n      var oldIndex = this.inverted ? 2 : 1,\n          newIndex = this.inverted ? 1 : 2;\n      for (var i = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos) break;\n        var oldSize = this.ranges[i + oldIndex],\n            end = start + oldSize;\n        if (pos <= end && i == index * 3) return true;\n        diff += this.ranges[i + newIndex] - oldSize;\n      }\n      return false;\n    }\n\n    // :: () → PosMap\n    // Create an inverted version of this map. The result can be used to\n    // map positions in the post-step document to the pre-step document.\n\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new PosMap(this.ranges, !this.inverted);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n  }]);\n\n  return PosMap;\n}();\n\nPosMap.empty = new PosMap([]);\n\n// ;; A remapping represents a pipeline of zero or more mappings. It\n// is a specialized data structured used to manage mapping through a\n// series of steps, typically including inverted and non-inverted\n// versions of the same step. (This comes up when ‘rebasing’ steps for\n// collaboration or history management.) This class implements\n// `Mappable`.\n\nvar Remapping = exports.Remapping = function () {\n  // :: (?[PosMap], ?[PosMap])\n\n  function Remapping() {\n    var head = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n    var tail = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n    _classCallCheck(this, Remapping);\n\n    // :: [PosMap]\n    // The maps in the head of the mapping are applied to input\n    // positions first, back-to-front. So the map at the end of this\n    // array (if any) is the very first one applied.\n    this.head = head;\n    // The maps in the tail are applied last, front-to-back.\n    this.tail = tail;\n    this.mirror = Object.create(null);\n  }\n\n  // :: (PosMap, ?number) → number\n  // Add a map to the mapping's front. If this map is the mirror image\n  // (produced by an inverted step) of another map in this mapping,\n  // that map's id (as returned by this method or\n  // [`addToBack`](#Remapping.addToBack)) should be passed as a second\n  // parameter to register the correspondence.\n\n\n  _createClass(Remapping, [{\n    key: \"addToFront\",\n    value: function addToFront(map, corr) {\n      this.head.push(map);\n      var id = -this.head.length;\n      if (corr != null) this.mirror[id] = corr;\n      return id;\n    }\n\n    // :: (PosMap, ?number) → number\n    // Add a map to the mapping's back. If the map is the mirror image\n    // of another mapping in this object, the id of that map should be\n    // passed to register the correspondence.\n\n  }, {\n    key: \"addToBack\",\n    value: function addToBack(map, corr) {\n      this.tail.push(map);\n      var id = this.tail.length - 1;\n      if (corr != null) this.mirror[corr] = id;\n      return id;\n    }\n  }, {\n    key: \"get\",\n    value: function get(id) {\n      return id < 0 ? this.head[-id - 1] : this.tail[id];\n    }\n\n    // :: (number, ?number) → MapResult\n    // Map a position through this remapping, returning a mapping\n    // result.\n\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos, bias) {\n      return this._map(pos, bias, false);\n    }\n\n    // :: (number, ?number) → number\n    // Map a position through this remapping.\n\n  }, {\n    key: \"map\",\n    value: function map(pos, bias) {\n      return this._map(pos, bias, true);\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(pos, bias, simple) {\n      var deleted = false,\n          recoverables = null;\n\n      for (var i = -this.head.length; i < this.tail.length; i++) {\n        var map = this.get(i),\n            rec = undefined;\n\n        if ((rec = recoverables && recoverables[i]) != null && map.touches(pos, rec)) {\n          pos = map.recover(rec);\n          continue;\n        }\n\n        var result = map.mapResult(pos, bias);\n        if (result.recover != null) {\n          var corr = this.mirror[i];\n          if (corr != null) {\n            if (result.deleted) {\n              i = corr;\n              pos = this.get(corr).recover(result.recover);\n              continue;\n            } else {\n              ;(recoverables || (recoverables = Object.create(null)))[corr] = result.recover;\n            }\n          }\n        }\n\n        if (result.deleted) deleted = true;\n        pos = result.pos;\n      }\n\n      return simple ? pos : new MapResult(pos, deleted);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var maps = [];\n      for (var i = -this.head.length; i < this.tail.length; i++) {\n        maps.push(i + \":\" + this.get(i) + (this.mirror[i] != null ? \"->\" + this.mirror[i] : \"\"));\n      }return maps.join(\"\\n\");\n    }\n  }]);\n\n  return Remapping;\n}();\n\nfunction mapThrough(mappables, pos, bias, start) {\n  for (var i = start || 0; i < mappables.length; i++) {\n    pos = mappables[i].map(pos, bias);\n  }return pos;\n}\n\nfunction mapThroughResult(mappables, pos, bias) {\n  var deleted = false;\n  for (var i = 0; i < mappables.length; i++) {\n    var result = mappables[i].mapResult(pos, bias);\n    pos = result.pos;\n    if (result.deleted) deleted = true;\n  }\n  return new MapResult(pos, deleted);\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/map.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/map.js?");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StepResult = exports.Step = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _model = __webpack_require__(18);\n\nvar _map = __webpack_require__(40);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction mustOverride() {\n  throw new Error(\"Override me\");\n}\n\nvar stepsByID = Object.create(null);\n\n// ;; A step object wraps an atomic operation. It generally applies\n// only to the document it was created for, since the positions\n// associated with it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `posMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using `Step.register`.\n\nvar Step = exports.Step = function () {\n  function Step() {\n    _classCallCheck(this, Step);\n  }\n\n  _createClass(Step, [{\n    key: \"apply\",\n\n    // :: (doc: Node) → ?StepResult\n    // Applies this step to the given document, returning a result\n    // containing the transformed document (the input document is not\n    // changed) and a `PosMap`. If the step could not meaningfully be\n    // applied to the given document, this returns `null`.\n    value: function apply(_doc) {\n      return mustOverride();\n    }\n\n    // :: () → PosMap\n    // Get the position map that represents the changes made by this\n    // step.\n\n  }, {\n    key: \"posMap\",\n    value: function posMap() {\n      return _map.PosMap.empty;\n    }\n\n    // :: (doc: Node) → Step\n    // Create an inverted version of this step. Needs the document as it\n    // was before the step as input.\n\n  }, {\n    key: \"invert\",\n    value: function invert(_doc) {\n      return mustOverride();\n    }\n\n    // :: (mapping: Mappable) → ?Step\n    // Map this step through a mappable thing, returning either a\n    // version of that step with its positions adjusted, or `null` if\n    // the step was entirely deleted by the mapping.\n\n  }, {\n    key: \"map\",\n    value: function map(_mapping) {\n      return mustOverride();\n    }\n\n    // :: () → Object\n    // Create a JSON-serializeable representation of this step. By\n    // default, it'll create an object with the step's [JSON\n    // id](#Step.register), and each of the steps's own properties,\n    // automatically calling `toJSON` on the property values that have\n    // such a method.\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = { stepType: this.jsonID };\n      for (var prop in this) {\n        if (this.hasOwnProperty(prop)) {\n          var val = this[prop];\n          obj[prop] = val && val.toJSON ? val.toJSON() : val;\n        }\n      }return obj;\n    }\n\n    // :: (Schema, Object) → Step\n    // Deserialize a step from its JSON representation. Will call\n    // through to the step class' own implementation of this method.\n\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      return stepsByID[json.stepType].fromJSON(schema, json);\n    }\n\n    // :: (string, constructor<Step>)\n    // To be able to serialize steps to JSON, each step needs a string\n    // ID to attach to its JSON representation. Use this method to\n    // register an ID for your step classes.\n\n  }, {\n    key: \"register\",\n    value: function register(id, stepClass) {\n      if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n      stepsByID[id] = stepClass;\n      stepClass.prototype.jsonID = id;\n      return stepClass;\n    }\n  }]);\n\n  return Step;\n}();\n\n// ;; The result of [applying](#Step.apply) a step. Contains either a\n// new document or a failure value.\n\n\nvar StepResult = exports.StepResult = function () {\n  // :: (?Node, ?string)\n\n  function StepResult(doc, failed) {\n    _classCallCheck(this, StepResult);\n\n    // :: ?Node The transformed document.\n    this.doc = doc;\n    // :: ?string A text providing information about a failed step.\n    this.failed = failed;\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n\n\n  _createClass(StepResult, null, [{\n    key: \"ok\",\n    value: function ok(doc) {\n      return new StepResult(doc, null);\n    }\n\n    // :: (string) → StepResult\n    // Create a failed step result.\n\n  }, {\n    key: \"fail\",\n    value: function fail(val) {\n      return new StepResult(null, val);\n    }\n\n    // :: (Node, number, number, Slice) → StepResult\n    // Run `Node.replace`, create a successful result if it succeeds,\n    // and a failed one if it throws a `ReplaceError`.\n\n  }, {\n    key: \"fromReplace\",\n    value: function fromReplace(doc, from, to, slice) {\n      try {\n        return StepResult.ok(doc.replace(from, to, slice));\n      } catch (e) {\n        if (e instanceof _model.ReplaceError) return StepResult.fail(e.message);\n        throw e;\n      }\n    }\n  }]);\n\n  return StepResult;\n}();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/step.js\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/step.js?");

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.canLift = canLift;\nexports.canWrap = canWrap;\nexports.canSplit = canSplit;\nexports.joinable = joinable;\nexports.joinPoint = joinPoint;\n\nvar _model = __webpack_require__(18);\n\nvar _transform = __webpack_require__(39);\n\nvar _replace_step = __webpack_require__(43);\n\n// :: (Node, number, ?number) → bool\n// Tells you whether the range in the given positions' shared\n// ancestor, or any of _its_ ancestor nodes, can be lifted out of a\n// parent.\nfunction canLift(doc, from, to) {\n  return !!findLiftable(doc.resolve(from), doc.resolve(to == null ? from : to));\n}\n\nfunction rangeDepth($from, $to) {\n  var shared = $from.sameDepth($to);\n  if ($from.node(shared).isTextblock || $from.pos == $to.pos) --shared;\n  if (shared < 0 || $from.pos > $to.pos) return null;\n  return shared;\n}\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, start));\n}\n\nfunction findLiftable($from, $to) {\n  var shared = rangeDepth($from, $to);\n  if (!shared) return null;\n  var parent = $from.node(shared),\n      content = parent.content.cutByIndex($from.index(shared), $to.indexAfter(shared));\n  for (var depth = shared;; --depth) {\n    var node = $from.node(depth),\n        index = $from.index(depth);\n    if (depth < shared && node.canReplace(index, index + 1, content)) return { depth: depth, shared: shared, unwrap: false };\n    if (depth == 0 || !canCut(node, index, index + 1)) break;\n  }\n\n  if (parent.isBlock) {\n    var _ret = function () {\n      var joined = _model.Fragment.empty;\n      content.forEach(function (node) {\n        return joined = joined.append(node.content);\n      });\n      for (var depth = shared;; --depth) {\n        var node = $from.node(depth),\n            index = $from.index(depth);\n        if (depth < shared && node.canReplace(index, index + 1, joined)) return {\n            v: { depth: depth, shared: shared, unwrap: true }\n          };\n        if (depth == 0 || !canCut(node, index, index + 1)) break;\n      }\n    }();\n\n    if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n}\n\n// :: (number, ?number, ?bool) → Transform\n// Lift the nearest liftable ancestor of the [sibling\n// range](#Node.siblingRange) of the given positions out of its parent\n// (or do nothing if no such node exists). When `silent` is true, this\n// won't raise an error when the lift is impossible.\n_transform.Transform.prototype.lift = function (from) {\n  var to = arguments.length <= 1 || arguments[1] === undefined ? from : arguments[1];\n  var silent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n  var $from = this.doc.resolve(from),\n      $to = this.doc.resolve(to);\n  var liftable = findLiftable($from, $to);\n  if (!liftable) {\n    if (!silent) throw new RangeError(\"No valid lift target\");\n    return this;\n  }\n\n  var depth = liftable.depth;\n  var shared = liftable.shared;\n  var unwrap = liftable.unwrap;\n\n\n  var gapStart = $from.before(shared + 1),\n      gapEnd = $to.after(shared + 1);\n  var start = gapStart,\n      end = gapEnd;\n\n  var before = _model.Fragment.empty,\n      beforeDepth = 0;\n  for (var d = shared, splitting = false; d > depth; d--) {\n    if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = _model.Fragment.from($from.node(d).copy(before));\n      beforeDepth++;\n    } else {\n      start--;\n    }\n  }var after = _model.Fragment.empty,\n      afterDepth = 0;\n  for (var d = shared, splitting = false; d > depth; d--) {\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true;\n      after = _model.Fragment.from($to.node(d).copy(after));\n      afterDepth++;\n    } else {\n      end++;\n    }\n  }if (unwrap) {\n    var joinPos = gapStart,\n        parent = $from.node(shared);\n    for (var i = $from.index(shared), e = $to.index(shared) + 1, first = true; i < e; i++, first = false) {\n      if (!first) {\n        this.join(joinPos);\n        end -= 2;\n        gapEnd -= 2;\n      }\n      joinPos += parent.child(i).nodeSize - (first ? 0 : 2);\n    }\n    ++gapStart;\n    --gapEnd;\n  }\n\n  return this.step(new _replace_step.ReplaceAroundStep(start, end, gapStart, gapEnd, new _model.Slice(before.append(after), beforeDepth, afterDepth), before.size - beforeDepth, true));\n};\n\n// :: (Node, number, ?number, NodeType, ?Object) → bool\n// Determines whether the [sibling range](#Node.siblingRange) of the\n// given positions can be wrapped in the given node type.\nfunction canWrap(doc, from, to, type, attrs) {\n  return !!checkWrap(doc.resolve(from), doc.resolve(to == null ? from : to), type, attrs);\n}\n\nfunction checkWrap($from, $to, type, attrs) {\n  var shared = rangeDepth($from, $to);\n  if (shared == null) return null;\n  var parent = $from.node(shared);\n  var around = parent.contentMatchAt($from.index(shared)).findWrapping(type, attrs);\n  if (!around) return null;\n  if (!parent.canReplaceWith($from.index(shared), $to.indexAfter(shared), around.length ? around[0].type : type, around.length ? around[0].attrs : attrs)) return null;\n  var inner = parent.child($from.index(shared));\n  var inside = type.contentExpr.start(attrs || type.defaultAttrs).findWrapping(inner.type, inner.attrs);\n  if (around && inside) return { shared: shared, around: around, inside: inside };\n}\n\n// :: (number, ?number, NodeType, ?Object) → Transform\n// Wrap the [sibling range](#Node.siblingRange) of the given positions\n// in a node of the given type, with the given attributes (if\n// possible).\n_transform.Transform.prototype.wrap = function (from) {\n  var to = arguments.length <= 1 || arguments[1] === undefined ? from : arguments[1];\n  var type = arguments[2];\n  var wrapAttrs = arguments[3];\n\n  var $from = this.doc.resolve(from),\n      $to = this.doc.resolve(to);\n  var check = checkWrap($from, $to, type, wrapAttrs);\n  if (!check) throw new RangeError(\"Wrap not possible\");\n  var shared = check.shared;\n  var around = check.around;\n  var inside = check.inside;\n\n\n  var content = _model.Fragment.empty,\n      open = inside.length + 1 + around.length;\n  for (var i = inside.length - 1; i >= 0; i--) {\n    content = _model.Fragment.from(inside[i].type.create(inside[i].attrs, content));\n  }content = _model.Fragment.from(type.create(wrapAttrs, content));\n  for (var i = around.length - 1; i >= 0; i--) {\n    content = _model.Fragment.from(around[i].type.create(around[i].attrs, content));\n  }var start = $from.before(shared + 1),\n      end = $to.after(shared + 1);\n  this.step(new _replace_step.ReplaceAroundStep(start, end, start, end, new _model.Slice(content, 0, 0), open, true));\n\n  if (inside.length) {\n    var splitPos = start + open,\n        parent = $from.node(shared);\n    for (var i = $from.index(shared), e = $to.index(shared) + 1, first = true; i < e; i++, first = false) {\n      if (!first) this.split(splitPos, inside.length);\n      splitPos += parent.child(i).nodeSize + (first ? 0 : 2 * inside.length);\n    }\n  }\n  return this;\n};\n\n// :: (number, ?number, NodeType, ?Object) → Transform\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\n_transform.Transform.prototype.setBlockType = function (from) {\n  var to = arguments.length <= 1 || arguments[1] === undefined ? from : arguments[1];\n\n  var _this = this;\n\n  var type = arguments[2];\n  var attrs = arguments[3];\n\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\");\n  var mapFrom = this.steps.length;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      _this.clearMarkupFor(_this.map(pos, 1, mapFrom), type, attrs);\n      var startM = _this.map(pos, 1, mapFrom),\n          endM = _this.map(pos + node.nodeSize, 1, mapFrom);\n      _this.step(new _replace_step.ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new _model.Slice(_model.Fragment.from(type.create(attrs)), 0, 0), 1, true));\n      return false;\n    }\n  });\n  return this;\n};\n\n// :: (number, ?NodeType, ?Object) → Transform\n// Change the type and attributes of the node after `pos`.\n_transform.Transform.prototype.setNodeType = function (pos, type, attrs) {\n  var node = this.doc.nodeAt(pos);\n  if (!node) throw new RangeError(\"No node at given position\");\n  if (!type) type = node.type;\n  if (node.type.isLeaf) return this.replaceWith(pos, pos + node.nodeSize, type.create(attrs, null, node.marks));\n\n  if (!type.validContent(node.content, attrs)) throw new RangeError(\"Invalid content for node type \" + type.name);\n\n  return this.step(new _replace_step.ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new _model.Slice(_model.Fragment.from(type.create(attrs)), 0, 0), 1, true));\n};\n\n// :: (Node, number, ?NodeType, ?Object) → bool\n// Check whether splitting at the given position is allowed.\nfunction canSplit(doc, pos) {\n  var depth = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n  var typeAfter = arguments[3];\n  var attrsAfter = arguments[4];\n\n  var $pos = doc.resolve(pos),\n      base = $pos.depth - depth;\n  if (base < 0 || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !$pos.parent.canReplace(0, $pos.indexAfter())) return false;\n  for (var d = $pos.depth - 1; d > base; d--) {\n    var node = $pos.node(d),\n        _index = $pos.index(d);\n    if (!node.canReplace(0, _index) || !node.canReplaceWith(_index, node.childCount, typeAfter || $pos.node(d + 1).type, typeAfter ? attrsAfter : $pos.node(d + 1).attrs)) return false;\n    typeAfter = null;\n  }\n  var index = $pos.indexAfter(base);\n  return $pos.node(base).canReplaceWith(index, index, typeAfter || $pos.node(base + 1).type, typeAfter ? attrsAfter : $pos.node(base + 1).attrs);\n}\n\n// :: (number, ?number, ?NodeType, ?Object) → Transform\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the part\n// split off will inherit the node type of the original node. This can\n// be changed by passing `typeAfter` and `attrsAfter`.\n_transform.Transform.prototype.split = function (pos) {\n  var depth = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n  var typeAfter = arguments[2];\n  var attrsAfter = arguments[3];\n\n  var $pos = this.doc.resolve(pos),\n      before = _model.Fragment.empty,\n      after = _model.Fragment.empty;\n  for (var d = $pos.depth, e = $pos.depth - depth; d > e; d--) {\n    before = _model.Fragment.from($pos.node(d).copy(before));\n    after = _model.Fragment.from(typeAfter ? typeAfter.create(attrsAfter, after) : $pos.node(d).copy(after));\n    typeAfter = null;\n  }\n  return this.step(new _replace_step.ReplaceStep(pos, pos, new _model.Slice(before.append(after), depth, depth, true)));\n};\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nfunction joinable(doc, pos) {\n  var $pos = doc.resolve(pos),\n      index = $pos.index();\n  return canJoin($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\n\nfunction canJoin(a, b) {\n  return a && b && !a.isText && a.canAppend(b);\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nfunction joinPoint(doc, pos) {\n  var dir = arguments.length <= 2 || arguments[2] === undefined ? -1 : arguments[2];\n\n  var $pos = doc.resolve(pos);\n  for (var d = $pos.depth;; d--) {\n    var before = undefined,\n        after = undefined;\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      after = $pos.node(d).maybeChild($pos.index(d) + 1);\n    } else {\n      before = $pos.node(d).maybeChild($pos.index(d) - 1);\n      after = $pos.node(d + 1);\n    }\n    if (before && !before.isTextblock && canJoin(before, after)) return pos;\n    if (d == 0) break;\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\n\n// :: (number, ?number, ?bool) → Transform\n// Join the blocks around the given position. When `silent` is true,\n// the method will return without raising an error if the position\n// isn't a valid place to join.\n_transform.Transform.prototype.join = function (pos) {\n  var depth = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n  var silent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n  if (silent && (pos < depth || pos + depth > this.doc.content.size)) return this;\n  var step = new _replace_step.ReplaceStep(pos - depth, pos + depth, _model.Slice.empty, true);\n  if (silent) this.maybeStep(step);else this.step(step);\n  return this;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/structure.js\n ** module id = 42\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/structure.js?");

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReplaceAroundStep = exports.ReplaceStep = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _model = __webpack_require__(18);\n\nvar _step = __webpack_require__(41);\n\nvar _map = __webpack_require__(40);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// ;; Replace a part of the document with a slice of new content.\n\nvar ReplaceStep = exports.ReplaceStep = function (_Step) {\n  _inherits(ReplaceStep, _Step);\n\n  // :: (number, number, Slice, bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n\n  function ReplaceStep(from, to, slice, structure) {\n    _classCallCheck(this, ReplaceStep);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ReplaceStep).call(this));\n\n    _this.from = from;\n    _this.to = to;\n    _this.slice = slice;\n    _this.structure = !!structure;\n    return _this;\n  }\n\n  _createClass(ReplaceStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.structure && contentBetween(doc, this.from, this.to)) return _step.StepResult.fail(\"Structure replace would overwrite content\");\n      return _step.StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n  }, {\n    key: \"posMap\",\n    value: function posMap() {\n      return new _map.PosMap([this.from, this.to - this.from, this.slice.size]);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n          to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted) return null;\n      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      return new ReplaceStep(json.from, json.to, _model.Slice.fromJSON(schema, json.slice));\n    }\n  }]);\n\n  return ReplaceStep;\n}(_step.Step);\n\n_step.Step.register(\"replace\", ReplaceStep);\n\n// ;; Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\n\nvar ReplaceAroundStep = exports.ReplaceAroundStep = function (_Step2) {\n  _inherits(ReplaceAroundStep, _Step2);\n\n  // :: (number, number, number, number, Slice, number, bool)\n  // Create a replace-wrap step with the given range and gap. `inset`\n  // should be the point in the slice into which the gap should be\n  // moved. `structure` has the same meaning as it has in the\n  // `Replace` step.\n\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    _classCallCheck(this, ReplaceAroundStep);\n\n    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(ReplaceAroundStep).call(this));\n\n    _this2.from = from;\n    _this2.to = to;\n    _this2.gapFrom = gapFrom;\n    _this2.gapTo = gapTo;\n    _this2.slice = slice;\n    _this2.insert = insert;\n    _this2.structure = !!structure;\n    return _this2;\n  }\n\n  _createClass(ReplaceAroundStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return _step.StepResult.fail(\"Structure gap-replace would overwrite content\");\n\n      var gap = doc.slice(this.gapFrom, this.gapTo);\n      if (gap.openLeft || gap.openRight) return _step.StepResult.fail(\"Gap is not a flat range\");\n      var inserted = this.slice.insertAt(this.insert, gap.content);\n      if (!inserted) return _step.StepResult.fail(\"Content does not fit in gap\");\n      return _step.StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n  }, {\n    key: \"posMap\",\n    value: function posMap() {\n      return new _map.PosMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var gap = this.gapTo - this.gapFrom;\n      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n          to = mapping.mapResult(this.to, -1);\n      var gapFrom = mapping.map(this.gapFrom, -1),\n          gapTo = mapping.map(this.gapTo, 1);\n      if (from.deleted && to.deleted || gapFrom < from.pos || gapTo > to.pos) return null;\n      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, _model.Slice.fromJSON(schema, json.slice), json.insert, json.structure);\n    }\n  }]);\n\n  return ReplaceAroundStep;\n}(_step.Step);\n\n_step.Step.register(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from),\n      dist = to - from,\n      depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.type.isLeaf) return true;\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/replace_step.js\n ** module id = 43\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/replace_step.js?");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoveMarkStep = exports.AddMarkStep = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _model = __webpack_require__(18);\n\nvar _step = __webpack_require__(41);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));\n    if (child.isInline) child = f(child, parent, i);\n    mapped.push(child);\n  }\n  return _model.Fragment.fromArray(mapped);\n}\n\n// ;; Add a mark to all inline content between two positions.\n\nvar AddMarkStep = exports.AddMarkStep = function (_Step) {\n  _inherits(AddMarkStep, _Step);\n\n  // :: (number, number, Mark)\n\n  function AddMarkStep(from, to, mark) {\n    _classCallCheck(this, AddMarkStep);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AddMarkStep).call(this));\n\n    _this.from = from;\n    _this.to = to;\n    _this.mark = mark;\n    return _this;\n  }\n\n  _createClass(AddMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var _this2 = this;\n\n      var oldSlice = doc.slice(this.from, this.to);\n      var slice = new _model.Slice(mapFragment(oldSlice.content, function (node, parent, index) {\n        if (!parent.contentMatchAt(index + 1).allowsMark(_this2.mark.type)) return node;\n        return node.mark(_this2.mark.addToSet(node.marks));\n      }, oldSlice.possibleParent), oldSlice.openLeft, oldSlice.openRight);\n      return _step.StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n          to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n      return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n  }]);\n\n  return AddMarkStep;\n}(_step.Step);\n\n_step.Step.register(\"addMark\", AddMarkStep);\n\n// ;; Remove a mark from all inline content between two positions.\n\nvar RemoveMarkStep = exports.RemoveMarkStep = function (_Step2) {\n  _inherits(RemoveMarkStep, _Step2);\n\n  // :: (number, number, Mark)\n\n  function RemoveMarkStep(from, to, mark) {\n    _classCallCheck(this, RemoveMarkStep);\n\n    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(RemoveMarkStep).call(this));\n\n    _this3.from = from;\n    _this3.to = to;\n    _this3.mark = mark;\n    return _this3;\n  }\n\n  _createClass(RemoveMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var _this4 = this;\n\n      var oldSlice = doc.slice(this.from, this.to);\n      var slice = new _model.Slice(mapFragment(oldSlice.content, function (node) {\n        return node.mark(_this4.mark.removeFromSet(node.marks));\n      }), oldSlice.openLeft, oldSlice.openRight);\n      return _step.StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new AddMarkStep(this.from, this.to, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n          to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n      return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n  }]);\n\n  return RemoveMarkStep;\n}(_step.Step);\n\n_step.Step.register(\"removeMark\", RemoveMarkStep);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/mark_step.js\n ** module id = 44\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/mark_step.js?");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _model = __webpack_require__(18);\n\nvar _replace_step = __webpack_require__(43);\n\nvar _transform = __webpack_require__(39);\n\n// :: (number, number) → Transform\n// Delete the content between the given positions.\n_transform.Transform.prototype.delete = function (from, to) {\n  return this.replace(from, to, _model.Slice.empty);\n};\n\n// :: (number, ?number, ?Slice) → Transform\n// Replace the part of the document between `from` and `to` with the\n// part of the `source` between `start` and `end`.\n_transform.Transform.prototype.replace = function (from) {\n  var to = arguments.length <= 1 || arguments[1] === undefined ? from : arguments[1];\n  var slice = arguments.length <= 2 || arguments[2] === undefined ? _model.Slice.empty : arguments[2];\n\n  if (from == to && !slice.size) return this;\n\n  var $from = this.doc.resolve(from),\n      $to = this.doc.resolve(to);\n  var placed = placeSlice($from, slice);\n\n  var fittedLeft = fitLeft($from, placed);\n  var fitted = fitRight($from, $to, fittedLeft);\n  if (!fitted) return this;\n  if (fittedLeft.size != fitted.size && canMoveText($from, $to, fittedLeft)) {\n    var d = $to.depth,\n        after = $to.after(d);\n    while (d > 1 && after == $to.end(--d)) {\n      ++after;\n    }var fittedAfter = fitRight($from, this.doc.resolve(after), fittedLeft);\n    if (fittedAfter) return this.step(new _replace_step.ReplaceAroundStep(from, after, to, $to.end(), fittedAfter, fittedLeft.size));\n  }\n  return this.step(new _replace_step.ReplaceStep(from, to, fitted));\n};\n\n// :: (number, number, union<Fragment, Node, [Node]>) → Transform\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\n_transform.Transform.prototype.replaceWith = function (from, to, content) {\n  return this.replace(from, to, new _model.Slice(_model.Fragment.from(content), 0, 0));\n};\n\n// :: (number, union<Fragment, Node, [Node]>) → Transform\n// Insert the given content at the given position.\n_transform.Transform.prototype.insert = function (pos, content) {\n  return this.replaceWith(pos, pos, content);\n};\n\n// :: (number, string) → Transform\n// Insert the given text at `pos`, inheriting the marks of the\n// existing content at that position.\n_transform.Transform.prototype.insertText = function (pos, text) {\n  return this.insert(pos, this.doc.type.schema.text(text, this.doc.marksAt(pos)));\n};\n\n// :: (number, Node) → Transform\n// Insert the given node at `pos`, inheriting the marks of the\n// existing content at that position.\n_transform.Transform.prototype.insertInline = function (pos, node) {\n  return this.insert(pos, node.mark(this.doc.marksAt(pos)));\n};\n\nfunction fitLeftInner($from, depth, placed, placedBelow) {\n  var content = _model.Fragment.empty,\n      openRight = 0,\n      placedHere = placed[depth];\n  if ($from.depth > depth) {\n    var inner = fitLeftInner($from, depth + 1, placed, placedBelow || placedHere);\n    openRight = inner.openRight + 1;\n    content = _model.Fragment.from($from.node(depth + 1).copy(inner.content));\n  }\n\n  if (placedHere) {\n    content = content.append(placedHere.content);\n    openRight = placedHere.openRight;\n  }\n  if (placedBelow) {\n    content = content.append($from.node(depth).contentMatchAt($from.indexAfter(depth)).fillBefore(_model.Fragment.empty, true));\n    openRight = 0;\n  }\n\n  return { content: content, openRight: openRight };\n}\n\nfunction fitLeft($from, placed) {\n  var _fitLeftInner = fitLeftInner($from, 0, placed, false);\n\n  var content = _fitLeftInner.content;\n  var openRight = _fitLeftInner.openRight;\n\n  return new _model.Slice(content, $from.depth, openRight || 0);\n}\n\nfunction fitRightJoin(content, parent, $from, $to, depth, openLeft, openRight) {\n  var match = undefined,\n      count = content.childCount,\n      matchCount = count - (openRight > 0 ? 1 : 0);\n  if (openLeft < 0) match = parent.contentMatchAt(matchCount);else if (count == 1 && openRight > 0) match = $from.node(depth).contentMatchAt(openLeft ? $from.index(depth) : $from.indexAfter(depth));else match = $from.node(depth).contentMatchAt($from.indexAfter(depth)).matchFragment(content, count > 0 && openLeft ? 1 : 0, matchCount);\n\n  var toNode = $to.node(depth);\n  if (openRight > 0 && depth < $to.depth) {\n    // FIXME find a less allocaty approach\n    var after = toNode.content.cutByIndex($to.indexAfter(depth)).addToStart(content.lastChild);\n    var _joinable = match.fillBefore(after, true);\n    // Can't insert content if there's a single node stretched across this gap\n    if (_joinable && _joinable.size && openLeft > 0 && count == 1) _joinable = null;\n\n    if (_joinable) {\n      var inner = fitRightJoin(content.lastChild.content, content.lastChild, $from, $to, depth + 1, count == 1 ? openLeft - 1 : -1, openRight - 1);\n      if (inner) {\n        var last = content.lastChild.copy(inner);\n        if (_joinable.size) return content.sliceByIndex(0, count - 1).append(_joinable).addToEnd(last);else return content.replaceChild(count - 1, last);\n      }\n    }\n  }\n  if (openRight > 0) match = match.matchNode(count == 1 && openLeft > 0 ? $from.node(depth + 1) : content.lastChild);\n\n  // If we're here, the next level can't be joined, so we see what\n  // happens if we leave it open.\n  var toIndex = $to.index(depth);\n  if (toIndex == toNode.childCount && !toNode.type.compatibleContent(parent.type)) return null;\n  var joinable = match.fillBefore(toNode.content, true, toIndex);\n  if (!joinable) return null;\n\n  if (openRight > 0) {\n    var closed = fitRightClosed(content.lastChild, openRight - 1, $from, depth + 1, count == 1 ? openLeft - 1 : -1);\n    content = content.replaceChild(count - 1, closed);\n  }\n  content = content.append(joinable);\n  if ($to.depth > depth) content = content.addToEnd(fitRightSeparate($to, depth + 1));\n  return content;\n}\n\nfunction fitRightClosed(node, openRight, $from, depth, openLeft) {\n  var match = undefined,\n      content = node.content,\n      count = content.childCount;\n  if (openLeft >= 0) match = $from.node(depth).contentMatchAt($from.indexAfter(depth)).matchFragment(content, openLeft > 0 ? 1 : 0, count);else match = node.contentMatchAt(count);\n\n  if (openRight > 0) {\n    var closed = fitRightClosed(content.lastChild, openRight - 1, $from, depth + 1, count == 1 ? openLeft - 1 : -1);\n    content = content.replaceChild(count - 1, closed);\n  }\n\n  return node.copy(content.append(match.fillBefore(_model.Fragment.empty, true)));\n}\n\nfunction fitRightSeparate($to, depth) {\n  var node = $to.node(depth);\n  var fill = node.contentMatchAt(0).fillBefore(node.content, true, $to.index(depth));\n  if ($to.depth > depth) fill = fill.addToEnd(fitRightSeparate($to, depth + 1));\n  return node.copy(fill);\n}\n\nfunction normalizeSlice(content, openLeft, openRight) {\n  while (openLeft > 0 && openRight > 0 && content.childCount == 1) {\n    content = content.firstChild.content;\n    openLeft--;\n    openRight--;\n  }\n  return new _model.Slice(content, openLeft, openRight);\n}\n\n// : (ResolvedPos, ResolvedPos, number, Slice) → Slice\nfunction fitRight($from, $to, slice) {\n  var fitted = fitRightJoin(slice.content, $from.node(0), $from, $to, 0, slice.openLeft, slice.openRight);\n  // FIXME we might want to be clever about selectively dropping nodes here?\n  if (!fitted) return null;\n  return normalizeSlice(fitted, slice.openLeft, $to.depth);\n}\n\nfunction canMoveText($from, $to, slice) {\n  if (!$to.parent.isTextblock) return false;\n\n  var match = undefined;\n  if (!slice.openRight) {\n    var parent = $from.node($from.depth - (slice.openLeft - slice.openRight));\n    if (!parent.isTextblock) return false;\n    match = parent.contentMatchAt(parent.childCount);\n    if (slice.size) match = match.matchFragment(slice.content, slice.openLeft ? 1 : 0);\n  } else {\n    var parent = nodeRight(slice.content, slice.openRight);\n    if (!parent.isTextblock) return false;\n    match = parent.contentMatchAt(parent.childCount);\n  }\n  match = match.matchFragment($to.parent.content, $to.index());\n  return match && match.validEnd();\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// So placeSlice splits up a slice into a number of sub-slices,\n// along with information on where they can be placed on the given\n// left-side edge. It works by walking the open side of the slice,\n// from the inside out, and trying to find a landing spot for each\n// element, by simultaneously scanning over the gap side. When no\n// place is found for an open node's content, it is left in that node.\n//\n// If the outer content can't be placed, a set of wrapper nodes is\n// made up for it (by rooting it in the document node type using\n// findWrapping), and the algorithm continues to iterate over those.\n// This is guaranteed to find a fit, since both stacks now start with\n// the same node type (doc).\n\nfunction nodeLeft(content, depth) {\n  for (var i = 1; i < depth; i++) {\n    content = content.firstChild.content;\n  }return content.firstChild;\n}\n\nfunction nodeRight(content, depth) {\n  for (var i = 1; i < depth; i++) {\n    content = content.lastChild.content;\n  }return content.lastChild;\n}\n\nfunction placeSlice($from, slice) {\n  var dFrom = $from.depth,\n      unplaced = null;\n  var placed = [],\n      parents = null;\n\n  for (var dSlice = slice.openLeft;; --dSlice) {\n    var curType = undefined,\n        curAttrs = undefined,\n        curFragment = undefined;\n    if (dSlice >= 0) {\n      if (dSlice > 0) {\n        // Inside slice\n        ;\n        var _nodeLeft = nodeLeft(slice.content, dSlice);\n\n        curType = _nodeLeft.type;\n        curAttrs = _nodeLeft.attrs;\n        curFragment = _nodeLeft.content;\n      } else if (dSlice == 0) {\n        // Top of slice\n        curFragment = slice.content;\n      }\n      if (dSlice < slice.openLeft) curFragment = curFragment.cut(curFragment.firstChild.nodeSize);\n    } else {\n      // Outside slice\n      curFragment = _model.Fragment.empty;\n      var parent = parents[parents.length + dSlice - 1];\n      curType = parent.type;\n      curAttrs = parent.attrs;\n    }\n    if (unplaced) curFragment = curFragment.addToStart(unplaced);\n\n    if (curFragment.size == 0 && dSlice <= 0) break;\n\n    // FIXME cut/remove marks when it helps find a placement\n    var found = findPlacement(curFragment, $from, dFrom);\n    if (found) {\n      if (curFragment.size > 0) placed[found.depth] = {\n        content: found.fill.append(curFragment),\n        openRight: dSlice > 0 ? 0 : slice.openRight - dSlice,\n        depth: found.depth\n      };\n      if (dSlice <= 0) break;\n      unplaced = null;\n      dFrom = Math.max(0, found.depth - 1);\n    } else {\n      if (dSlice == 0) {\n        var top = $from.node(0);\n        parents = top.contentMatchAt($from.index(0)).findWrapping(curFragment.firstChild.type, curFragment.firstChild.attrs);\n        if (!parents) break;\n        var last = parents[parents.length - 1];\n        if (last ? !last.type.contentExpr.matches(last.attrs, curFragment) : !top.canReplace($from.indexAfter(0), $from.depth ? $from.index(0) : $from.indexAfter(0), curFragment)) break;\n        parents = [{ type: top.type, attrs: top.attrs }].concat(parents);\n        curType = parents[parents.length - 1].type;\n        curAttrs = parents[parents.length - 1].type;\n      }\n      curFragment = curType.contentExpr.start(curAttrs).fillBefore(curFragment, true).append(curFragment);\n      unplaced = curType.create(curAttrs, curFragment);\n    }\n  }\n\n  return placed;\n}\n\nfunction findPlacement(fragment, $from, start) {\n  for (var d = start; d >= 0; d--) {\n    var match = $from.node(d).contentMatchAt($from.indexAfter(d)).fillBefore(fragment);\n    if (match) return { depth: d, fill: match };\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/replace.js\n ** module id = 45\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/replace.js?");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _model = __webpack_require__(18);\n\nvar _transform = __webpack_require__(39);\n\nvar _mark_step = __webpack_require__(44);\n\nvar _replace_step = __webpack_require__(43);\n\n// :: (number, number, Mark) → Transform\n// Add the given mark to the inline content between `from` and `to`.\n_transform.Transform.prototype.addMark = function (from, to, mark) {\n  var _this = this;\n\n  var removed = [],\n      added = [],\n      removing = null,\n      adding = null;\n  this.doc.nodesBetween(from, to, function (node, pos, parent, index) {\n    if (!node.isInline) return;\n    var marks = node.marks;\n    if (mark.isInSet(marks) || !parent.contentMatchAt(index + 1).allowsMark(mark.type)) {\n      adding = removing = null;\n    } else {\n      var start = Math.max(pos, from),\n          end = Math.min(pos + node.nodeSize, to);\n      var rm = mark.type.isInSet(marks);\n\n      if (!rm) removing = null;else if (removing && removing.mark.eq(rm)) removing.to = end;else removed.push(removing = new _mark_step.RemoveMarkStep(start, end, rm));\n\n      if (adding) adding.to = end;else added.push(adding = new _mark_step.AddMarkStep(start, end, mark));\n    }\n  });\n\n  removed.forEach(function (s) {\n    return _this.step(s);\n  });\n  added.forEach(function (s) {\n    return _this.step(s);\n  });\n  return this;\n};\n\n// :: (number, number, ?union<Mark, MarkType>) → Transform\n// Remove the given mark, or all marks of the given type, from inline\n// nodes between `from` and `to`.\n_transform.Transform.prototype.removeMark = function (from, to) {\n  var _this2 = this;\n\n  var mark = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n  var matched = [],\n      step = 0;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) return;\n    step++;\n    var toRemove = null;\n    if (mark instanceof _model.MarkType) {\n      var found = mark.isInSet(node.marks);\n      if (found) toRemove = [found];\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark];\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i],\n            found = undefined;\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m;\n        }\n        if (found) {\n          found.to = end;\n          found.step = step;\n        } else {\n          matched.push({ style: style, from: Math.max(pos, from), to: end, step: step });\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) {\n    return _this2.step(new _mark_step.RemoveMarkStep(m.from, m.to, m.style));\n  });\n  return this;\n};\n\n// :: (number, number) → Transform\n// Remove all marks and non-text inline nodes from the given range.\n_transform.Transform.prototype.clearMarkup = function (from, to) {\n  var _this3 = this;\n\n  var delSteps = []; // Must be accumulated and applied in inverse order\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) return;\n    if (!node.type.isText) {\n      delSteps.push(new _replace_step.ReplaceStep(pos, pos + node.nodeSize, _model.Slice.empty));\n      return;\n    }\n    for (var i = 0; i < node.marks.length; i++) {\n      _this3.step(new _mark_step.RemoveMarkStep(Math.max(pos, from), Math.min(pos + node.nodeSize, to), node.marks[i]));\n    }\n  });\n  for (var i = delSteps.length - 1; i >= 0; i--) {\n    this.step(delSteps[i]);\n  }return this;\n};\n\n_transform.Transform.prototype.clearMarkupFor = function (pos, newType, newAttrs) {\n  var node = this.doc.nodeAt(pos),\n      match = newType.contentExpr.start(newAttrs);\n  var delSteps = [];\n  for (var i = 0, cur = pos + 1; i < node.childCount; i++) {\n    var child = node.child(i),\n        end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type, child.attrs, []);\n    if (!allowed) {\n      delSteps.push(new _replace_step.ReplaceStep(cur, end, _model.Slice.empty));\n    } else {\n      match = allowed;\n      for (var j = 0; j < child.marks.length; j++) {\n        if (!match.allowsMark(child.marks[j])) this.step(new _mark_step.RemoveMarkStep(cur, end, child.marks[j]));\n      }\n    }\n    cur = end;\n  }\n  for (var i = delSteps.length - 1; i >= 0; i--) {\n    this.step(delSteps[i]);\n  }return this;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/transform/mark.js\n ** module id = 46\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/transform/mark.js?");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.baseCommands = undefined;\n\nvar _dom = __webpack_require__(10);\n\nvar _transform = __webpack_require__(38);\n\nvar _model = __webpack_require__(18);\n\nvar _char = __webpack_require__(48);\n\nvar _selection = __webpack_require__(49);\n\n// :: Object<CommandSpec>\n// The set of default commands defined by the core library. They are\n// included in the [default command set](#CommandSet.default).\nvar baseCommands = exports.baseCommands = Object.create(null);\n\n// ;; #kind=command\n// Delete the selection, if there is one.\n//\n// **Keybindings:** Backspace, Delete, Mod-Backspace, Mod-Delete,\n// **Ctrl-H (Mac), Alt-Backspace (Mac), Ctrl-D (Mac),\n// **Ctrl-Alt-Backspace (Mac), Alt-Delete (Mac), Alt-D (Mac)\nbaseCommands.deleteSelection = {\n  label: \"Delete the selection\",\n  run: function run(pm) {\n    return pm.tr.replaceSelection().apply(pm.apply.scroll);\n  },\n\n  keys: {\n    all: [\"Backspace(10)\", \"Delete(10)\", \"Mod-Backspace(10)\", \"Mod-Delete(10)\"],\n    mac: [\"Ctrl-H(10)\", \"Alt-Backspace(10)\", \"Ctrl-D(10)\", \"Ctrl-Alt-Backspace(10)\", \"Alt-Delete(10)\", \"Alt-D(10)\"]\n  }\n};\n\nfunction deleteBarrier(pm, cut) {\n  var $cut = pm.doc.resolve(cut),\n      before = $cut.nodeBefore,\n      after = $cut.nodeAfter;\n  if ((0, _transform.joinable)(pm.doc, cut)) {\n    var tr = pm.tr.join(cut);\n    if (tr.steps.length && before.content.size == 0 && !before.sameMarkup(after) && $cut.parent.canReplace($cut.index() - 1, $cut.index())) tr.setNodeType(cut - before.nodeSize, after.type, after.attrs);\n    if (tr.apply(pm.apply.scroll) !== false) return;\n  }\n\n  var conn = undefined;\n  if (after.isTextblock && (conn = before.contentMatchAt($cut.index()).findWrapping(after.type, after.attrs))) {\n    var end = cut + after.nodeSize,\n        wrap = _model.Fragment.empty;\n    for (var i = conn.length - 1; i >= 0; i--) {\n      wrap = _model.Fragment.from(conn[i].type.create(conn[i].attrs, wrap));\n    }wrap = _model.Fragment.from(before.copy(wrap));\n    return pm.tr.step(new _transform.ReplaceAroundStep(cut - 1, end, cut, end, new _model.Slice(wrap, 1, 0), conn.length, true)).join(end + 2 * conn.length, 1, true).apply(pm.apply.scroll);\n  }\n\n  var selAfter = (0, _selection.findSelectionFrom)(pm.doc, cut, 1);\n  return pm.tr.lift(selAfter.from, selAfter.to, true).apply(pm.apply.scroll);\n}\n\n// ;; #kind=command\n// If the selection is empty and at the start of a textblock, move\n// that block closer to the block before it, by lifting it out of its\n// parent or, if it has no parent it doesn't share with the node\n// before it, moving it into a parent of that node, or joining it with\n// that.\n//\n// **Keybindings:** Backspace, Mod-Backspace\nbaseCommands.joinBackward = {\n  label: \"Join with the block above\",\n  run: function run(pm) {\n    var _pm$selection = pm.selection;\n    var head = _pm$selection.head;\n    var empty = _pm$selection.empty;\n\n    if (!empty) return false;\n\n    var $head = pm.doc.resolve(head);\n    if ($head.parentOffset > 0) return false;\n\n    // Find the node before this one\n    var before = undefined,\n        cut = undefined;\n    for (var i = $head.depth - 1; !before && i >= 0; i--) {\n      if ($head.index(i) > 0) {\n        cut = $head.before(i + 1);\n        before = $head.node(i).child($head.index(i) - 1);\n      }\n    } // If there is no node before this, try to lift\n    if (!before) return pm.tr.lift(head, head, true).apply(pm.apply.scroll);\n\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if (before.type.isLeaf && before.type.selectable && $head.parent.content.size == 0) {\n      var tr = pm.tr.delete(cut, cut + $head.parent.nodeSize).apply(pm.apply.scroll);\n      pm.setNodeSelection(cut - before.nodeSize);\n      return tr;\n    }\n\n    // If the node doesn't allow children, delete it\n    if (before.type.isLeaf) return pm.tr.delete(cut - before.nodeSize, cut).apply(pm.apply.scroll);\n\n    // Apply the joining algorithm\n    return deleteBarrier(pm, cut);\n  },\n\n  keys: [\"Backspace(30)\", \"Mod-Backspace(30)\"]\n};\n\n// Get an offset moving backward from a current offset inside a node.\nfunction moveBackward(doc, pos, by) {\n  if (by != \"char\" && by != \"word\") throw new RangeError(\"Unknown motion unit: \" + by);\n\n  var $pos = doc.resolve(pos);\n  var parent = $pos.parent,\n      offset = $pos.parentOffset;\n\n  var cat = null,\n      counted = 0;\n  for (;;) {\n    if (offset == 0) return pos;\n\n    var _parent$childBefore = parent.childBefore(offset);\n\n    var start = _parent$childBefore.offset;\n    var node = _parent$childBefore.node;\n\n    if (!node) return pos;\n    if (!node.isText) return cat ? pos : pos - 1;\n\n    if (by == \"char\") {\n      for (var i = offset - start; i > 0; i--) {\n        if (!(0, _char.isExtendingChar)(node.text.charAt(i - 1))) return pos - 1;\n        offset--;\n        pos--;\n      }\n    } else if (by == \"word\") {\n      // Work from the current position backwards through text of a singular\n      // character category (e.g. \"cat\" of \"#!*\") until reaching a character in a\n      // different category (i.e. the end of the word).\n      for (var i = offset - start; i > 0; i--) {\n        var nextCharCat = (0, _char.charCategory)(node.text.charAt(i - 1));\n        if (cat == null || counted == 1 && cat == \"space\") cat = nextCharCat;else if (cat != nextCharCat) return pos;\n        offset--;\n        pos--;\n        counted++;\n      }\n    }\n  }\n}\n\n// ;; #kind=command\n// Delete the character before the cursor, if the selection is empty\n// and the cursor isn't at the start of a textblock.\n//\n// **Keybindings:** Backspace, Ctrl-H (Mac)\nbaseCommands.deleteCharBefore = {\n  label: \"Delete a character before the cursor\",\n  run: function run(pm) {\n    if (_dom.browser.ios) return false;\n    var _pm$selection2 = pm.selection;\n    var head = _pm$selection2.head;\n    var empty = _pm$selection2.empty;\n\n    if (!empty || pm.doc.resolve(head).parentOffset == 0) return false;\n    var dest = moveBackward(pm.doc, head, \"char\");\n    return pm.tr.delete(dest, head).apply(pm.apply.scroll);\n  },\n\n  keys: {\n    all: [\"Backspace(60)\"],\n    mac: [\"Ctrl-H(40)\"]\n  }\n};\n\n// ;; #kind=command\n// Delete the word before the cursor, if the selection is empty and\n// the cursor isn't at the start of a textblock.\n//\n// **Keybindings:** Mod-Backspace, Alt-Backspace (Mac)\nbaseCommands.deleteWordBefore = {\n  label: \"Delete the word before the cursor\",\n  run: function run(pm) {\n    var _pm$selection3 = pm.selection;\n    var head = _pm$selection3.head;\n    var empty = _pm$selection3.empty;\n\n    if (!empty || pm.doc.resolve(head).parentOffset == 0) return false;\n    var dest = moveBackward(pm.doc, head, \"word\");\n    return pm.tr.delete(dest, head).apply(pm.apply.scroll);\n  },\n\n  keys: {\n    all: [\"Mod-Backspace(40)\"],\n    mac: [\"Alt-Backspace(40)\"]\n  }\n};\n\n// ;; #kind=command\n// If the selection is empty and the cursor is at the end of a\n// textblock, move the node after it closer to the node with the\n// cursor (lifting it out of parents that aren't shared, moving it\n// into parents of the cursor block, or joining the two when they are\n// siblings).\n//\n// **Keybindings:** Delete, Mod-Delete\nbaseCommands.joinForward = {\n  label: \"Join with the block below\",\n  run: function run(pm) {\n    var _pm$selection4 = pm.selection;\n    var head = _pm$selection4.head;\n    var empty = _pm$selection4.empty;var $head = undefined;\n    if (!empty || ($head = pm.doc.resolve(head)).parentOffset < $head.parent.content.size) return false;\n\n    // Find the node after this one\n    var after = undefined,\n        cut = undefined;\n    for (var i = $head.depth - 1; !after && i >= 0; i--) {\n      var parent = $head.node(i);\n      if ($head.index(i) + 1 < parent.childCount) {\n        after = parent.child($head.index(i) + 1);\n        cut = $head.after(i + 1);\n      }\n    }\n\n    // If there is no node after this, there's nothing to do\n    if (!after) return false;\n\n    // If the node doesn't allow children, delete it\n    if (after.type.isLeaf) return pm.tr.delete(cut, cut + after.nodeSize).apply(pm.apply.scroll);\n\n    // Apply the joining algorithm\n    return deleteBarrier(pm, cut);\n  },\n\n  keys: [\"Delete(30)\", \"Mod-Delete(30)\"]\n};\n\nfunction moveForward(doc, pos, by) {\n  if (by != \"char\" && by != \"word\") throw new RangeError(\"Unknown motion unit: \" + by);\n\n  var $pos = doc.resolve(pos);\n  var parent = $pos.parent,\n      offset = $pos.parentOffset;\n\n  var cat = null,\n      counted = 0;\n  for (;;) {\n    if (offset == parent.content.size) return pos;\n\n    var _parent$childAfter = parent.childAfter(offset);\n\n    var start = _parent$childAfter.offset;\n    var node = _parent$childAfter.node;\n\n    if (!node) return pos;\n    if (!node.isText) return cat ? pos : pos + 1;\n\n    if (by == \"char\") {\n      for (var i = offset - start; i < node.text.length; i++) {\n        if (!(0, _char.isExtendingChar)(node.text.charAt(i + 1))) return pos + 1;\n        offset++;\n        pos++;\n      }\n    } else if (by == \"word\") {\n      for (var i = offset - start; i < node.text.length; i++) {\n        var nextCharCat = (0, _char.charCategory)(node.text.charAt(i));\n        if (cat == null || counted == 1 && cat == \"space\") cat = nextCharCat;else if (cat != nextCharCat) return pos;\n        offset++;\n        pos++;\n        counted++;\n      }\n    }\n  }\n}\n\n// ;; #kind=command\n// Delete the character after the cursor, if the selection is empty\n// and the cursor isn't at the end of its textblock.\n//\n// **Keybindings:** Delete, Ctrl-D (Mac)\nbaseCommands.deleteCharAfter = {\n  label: \"Delete a character after the cursor\",\n  run: function run(pm) {\n    var _pm$selection5 = pm.selection;\n    var head = _pm$selection5.head;\n    var empty = _pm$selection5.empty;var $head = undefined;\n    if (!empty || ($head = pm.doc.resolve(head)).parentOffset == $head.parent.content.size) return false;\n    var dest = moveForward(pm.doc, head, \"char\");\n    return pm.tr.delete(head, dest).apply(pm.apply.scroll);\n  },\n\n  keys: {\n    all: [\"Delete(60)\"],\n    mac: [\"Ctrl-D(60)\"]\n  }\n};\n\n// ;; #kind=command\n// Delete the word after the cursor, if the selection is empty and the\n// cursor isn't at the end of a textblock.\n//\n// **Keybindings:** Mod-Delete, Ctrl-Alt-Backspace (Mac), Alt-Delete\n// (Mac), Alt-D (Mac)\nbaseCommands.deleteWordAfter = {\n  label: \"Delete a word after the cursor\",\n  run: function run(pm) {\n    var _pm$selection6 = pm.selection;\n    var head = _pm$selection6.head;\n    var empty = _pm$selection6.empty;var $head = undefined;\n    if (!empty || ($head = pm.doc.resolve(head)).parentOffset == $head.parent.content.size) return false;\n    var dest = moveForward(pm.doc, head, \"word\");\n    return pm.tr.delete(head, dest).apply(pm.apply.scroll);\n  },\n\n  keys: {\n    all: [\"Mod-Delete(40)\"],\n    mac: [\"Ctrl-Alt-Backspace(40)\", \"Alt-Delete(40)\", \"Alt-D(40)\"]\n  }\n};\n\nfunction joinPointAbove(pm) {\n  var _pm$selection7 = pm.selection;\n  var node = _pm$selection7.node;\n  var from = _pm$selection7.from;\n\n  if (node) return (0, _transform.joinable)(pm.doc, from) ? from : null;else return (0, _transform.joinPoint)(pm.doc, from, -1);\n}\n\n// ;; #kind=command\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\n//\n// **Keybindings:** Alt-Up\nbaseCommands.joinUp = {\n  label: \"Join with above block\",\n  run: function run(pm) {\n    var point = joinPointAbove(pm),\n        selectNode = undefined;\n    if (!point) return false;\n    if (pm.selection.node) selectNode = point - pm.doc.resolve(point).nodeBefore.nodeSize;\n    pm.tr.join(point).apply();\n    if (selectNode != null) pm.setNodeSelection(selectNode);\n  },\n  select: function select(pm) {\n    return joinPointAbove(pm);\n  },\n\n  menu: {\n    group: \"block\", rank: 80,\n    display: {\n      type: \"icon\",\n      width: 800, height: 900,\n      path: \"M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z\"\n    }\n  },\n  keys: [\"Alt-Up\"]\n};\n\nfunction joinPointBelow(pm) {\n  var _pm$selection8 = pm.selection;\n  var node = _pm$selection8.node;\n  var to = _pm$selection8.to;\n\n  if (node) return (0, _transform.joinable)(pm.doc, to) ? to : null;else return (0, _transform.joinPoint)(pm.doc, to, 1);\n}\n\n// ;; #kind=command\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\n//\n// **Keybindings:** Alt-Down\nbaseCommands.joinDown = {\n  label: \"Join with below block\",\n  run: function run(pm) {\n    var node = pm.selection.node,\n        nodeAt = pm.selection.from;\n    var point = joinPointBelow(pm);\n    if (!point) return false;\n    pm.tr.join(point).apply();\n    if (node) pm.setNodeSelection(nodeAt);\n  },\n  select: function select(pm) {\n    return joinPointBelow(pm);\n  },\n\n  keys: [\"Alt-Down\"]\n};\n\n// ;; #kind=command\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\n//\n// **Keybindings:** Ctrl-[\nbaseCommands.lift = {\n  label: \"Lift out of enclosing block\",\n  run: function run(pm) {\n    var _pm$selection9 = pm.selection;\n    var from = _pm$selection9.from;\n    var to = _pm$selection9.to;\n\n    return pm.tr.lift(from, to, true).apply(pm.apply.scroll);\n  },\n  select: function select(pm) {\n    var _pm$selection10 = pm.selection;\n    var from = _pm$selection10.from;\n    var to = _pm$selection10.to;\n\n    return (0, _transform.canLift)(pm.doc, from, to);\n  },\n\n  menu: {\n    group: \"block\", rank: 75,\n    display: {\n      type: \"icon\",\n      width: 1024, height: 1024,\n      path: \"M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z\"\n    }\n  },\n  keys: [\"Mod-[\"]\n};\n\n// ;; #kind=command\n// If the selection is in a node whose type has a truthy `isCode`\n// property, replace the selection with a newline character.\n//\n// **Keybindings:** Enter\nbaseCommands.newlineInCode = {\n  label: \"Insert newline\",\n  run: function run(pm) {\n    var _pm$selection11 = pm.selection;\n    var from = _pm$selection11.from;\n    var to = _pm$selection11.to;\n    var node = _pm$selection11.node;\n\n    if (node) return false;\n    var $from = pm.doc.resolve(from);\n    if (!$from.parent.type.isCode || to >= $from.end()) return false;\n    return pm.tr.typeText(\"\\n\").apply(pm.apply.scroll);\n  },\n\n  keys: [\"Enter(10)\"]\n};\n\n// ;; #kind=command\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\n//\n// **Keybindings:** Enter\nbaseCommands.createParagraphNear = {\n  label: \"Create a paragraph near the selected block\",\n  run: function run(pm) {\n    var _pm$selection12 = pm.selection;\n    var from = _pm$selection12.from;\n    var to = _pm$selection12.to;\n    var node = _pm$selection12.node;\n\n    if (!node || !node.isBlock) return false;\n    var $from = pm.doc.resolve(from),\n        side = $from.parentOffset ? to : from;\n    var type = $from.parent.defaultContentType($from.indexAfter());\n    pm.tr.insert(side, type.create()).apply(pm.apply.scroll);\n    pm.setTextSelection(side + 1);\n  },\n\n  keys: [\"Enter(20)\"]\n};\n\n// ;; #kind=command\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\n//\n// **Keybindings:** Enter\nbaseCommands.liftEmptyBlock = {\n  label: \"Move current block up\",\n  run: function run(pm) {\n    var _pm$selection13 = pm.selection;\n    var head = _pm$selection13.head;\n    var empty = _pm$selection13.empty;var $head = undefined;\n    if (!empty || ($head = pm.doc.resolve(head)).parent.content.size) return false;\n    if ($head.depth > 1 && $head.after() != $head.end(-1)) {\n      var before = $head.before();\n      if ((0, _transform.canSplit)(pm.doc, before)) return pm.tr.split(before).apply(pm.apply.scroll);\n    }\n    return pm.tr.lift(head, head, true).apply(pm.apply.scroll);\n  },\n\n  keys: [\"Enter(30)\"]\n};\n\n// ;; #kind=command\n// Split the parent block of the selection. If the selection is a text\n// selection, delete it.\n//\n// **Keybindings:** Enter\nbaseCommands.splitBlock = {\n  label: \"Split the current block\",\n  run: function run(pm) {\n    var _pm$selection14 = pm.selection;\n    var from = _pm$selection14.from;\n    var to = _pm$selection14.to;\n    var node = _pm$selection14.node;var $from = pm.doc.resolve(from);\n    if (node && node.isBlock) {\n      if (!$from.parentOffset || !(0, _transform.canSplit)(pm.doc, from)) return false;\n      return pm.tr.split(from).apply(pm.apply.scroll);\n    } else {\n      var $to = pm.doc.resolve(to),\n          atEnd = $to.parentOffset == $to.parent.content.size;\n      var tr = pm.tr.delete(from, to);\n      var deflt = $from.node(-1).defaultContentType($from.indexAfter(-1)),\n          type = atEnd ? deflt : null;\n      if ((0, _transform.canSplit)(tr.doc, from, 1, type)) {\n        tr.split(from, 1, type);\n        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) tr.setNodeType($from.before(), deflt);\n      }\n      return tr.apply(pm.apply.scroll);\n    }\n  },\n\n  keys: [\"Enter(60)\"]\n};\n\nfunction nodeAboveSelection(pm) {\n  var sel = pm.selection;\n  if (sel.node) {\n    var $from = pm.doc.resolve(sel.from);\n    return !!$from.depth && $from.before();\n  }\n  var $head = pm.doc.resolve(sel.head);\n  var same = $head.sameDepth(pm.doc.resolve(sel.anchor));\n  return same == 0 ? false : $head.before(same);\n}\n\n// ;; #kind=command\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\n//\n// **Keybindings:** Esc\nbaseCommands.selectParentNode = {\n  label: \"Select parent node\",\n  run: function run(pm) {\n    var node = nodeAboveSelection(pm);\n    if (node === false) return false;\n    pm.setNodeSelection(node);\n  },\n  select: function select(pm) {\n    return nodeAboveSelection(pm);\n  },\n\n  menu: {\n    group: \"block\", rank: 90,\n    display: { type: \"icon\", text: \"⬚\", style: \"font-weight: bold\" }\n  },\n  keys: [\"Esc\"]\n};\n\n// ;; #kind=command\n// Undo the most recent change event, if any.\n//\n// **Keybindings:** Mod-Z\nbaseCommands.undo = {\n  label: \"Undo last change\",\n  run: function run(pm) {\n    pm.scrollIntoView();return pm.history.undo();\n  },\n  select: function select(pm) {\n    return pm.history.undoDepth > 0;\n  },\n\n  menu: {\n    group: \"history\", rank: 10,\n    display: {\n      type: \"icon\",\n      width: 1024, height: 1024,\n      path: \"M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z\"\n    }\n  },\n  keys: [\"Mod-Z\"]\n};\n\n// ;; #kind=command\n// Redo the most recently undone change event, if any.\n//\n// **Keybindings:** Mod-Y, Shift-Mod-Z\nbaseCommands.redo = {\n  label: \"Redo last undone change\",\n  run: function run(pm) {\n    pm.scrollIntoView();return pm.history.redo();\n  },\n  select: function select(pm) {\n    return pm.history.redoDepth > 0;\n  },\n\n  menu: {\n    group: \"history\", rank: 20,\n    display: {\n      type: \"icon\",\n      width: 1024, height: 1024,\n      path: \"M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z\"\n    }\n  },\n  keys: [\"Mod-Y\", \"Shift-Mod-Z\"]\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/base_commands.js\n ** module id = 47\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/base_commands.js?");

/***/ },
/* 48 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isWordChar = isWordChar;\nexports.charCategory = charCategory;\nexports.isExtendingChar = isExtendingChar;\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChar = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\nfunction isWordChar(ch) {\n  return (/\\w/.test(ch) || isExtendingChar(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  );\n}\n\n// Get the category of a given character. Either a \"space\",\n// a character that can be part of a word (\"word\"), or anything else (\"other\").\nfunction charCategory(ch) {\n  return (/\\s/.test(ch) ? \"space\" : isWordChar(ch) ? \"word\" : \"other\"\n  );\n}\n\nfunction isExtendingChar(ch) {\n  return ch.charCodeAt(0) >= 768 && extendingChar.test(ch);\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/char.js\n ** module id = 48\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/char.js?");

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeSelection = exports.TextSelection = exports.Selection = exports.SelectionState = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.selectionFromDOM = selectionFromDOM;\nexports.hasFocus = hasFocus;\nexports.findSelectionFrom = findSelectionFrom;\nexports.findSelectionNear = findSelectionNear;\nexports.findSelectionAtStart = findSelectionAtStart;\nexports.findSelectionAtEnd = findSelectionAtEnd;\nexports.verticalMotionLeavesTextblock = verticalMotionLeavesTextblock;\n\nvar _dom = __webpack_require__(10);\n\nvar _dompos = __webpack_require__(50);\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Track the state of the current editor selection. Keeps the editor\n// selection in sync with the DOM selection by polling for changes,\n// as there is no DOM event for DOM selection changes.\n\nvar SelectionState = exports.SelectionState = function () {\n  function SelectionState(pm, range) {\n    var _this = this;\n\n    _classCallCheck(this, SelectionState);\n\n    this.pm = pm;\n    // The current editor selection.\n    this.range = range;\n\n    // The timeout ID for the poller when active.\n    this.polling = null;\n    // Track the state of the DOM selection.\n    this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null;\n    // The corresponding DOM node when a node selection is active.\n    this.lastNode = null;\n\n    pm.content.addEventListener(\"focus\", function () {\n      return _this.receivedFocus();\n    });\n\n    this.poller = this.poller.bind(this);\n  }\n\n  // : (Selection, boolean)\n  // Set the current selection and signal an event on the editor.\n\n\n  _createClass(SelectionState, [{\n    key: \"setAndSignal\",\n    value: function setAndSignal(range, clearLast) {\n      this.set(range, clearLast);\n      // :: () #path=ProseMirror#events#selectionChange\n      // Indicates that the editor's selection has changed.\n      this.pm.signal(\"selectionChange\");\n    }\n\n    // : (Selection, boolean)\n    // Set the current selection.\n\n  }, {\n    key: \"set\",\n    value: function set(range, clearLast) {\n      this.pm.ensureOperation({ readSelection: false, selection: range });\n      this.range = range;\n      if (clearLast !== false) this.lastAnchorNode = null;\n    }\n  }, {\n    key: \"poller\",\n    value: function poller() {\n      if (hasFocus(this.pm)) {\n        if (!this.pm.operation) this.readFromDOM();\n        this.polling = setTimeout(this.poller, 100);\n      } else {\n        this.polling = null;\n      }\n    }\n  }, {\n    key: \"startPolling\",\n    value: function startPolling() {\n      clearTimeout(this.polling);\n      this.polling = setTimeout(this.poller, 50);\n    }\n  }, {\n    key: \"fastPoll\",\n    value: function fastPoll() {\n      this.startPolling();\n    }\n  }, {\n    key: \"stopPolling\",\n    value: function stopPolling() {\n      clearTimeout(this.polling);\n      this.polling = null;\n    }\n\n    // : () → bool\n    // Whether the DOM selection has changed from the last known state.\n\n  }, {\n    key: \"domChanged\",\n    value: function domChanged() {\n      var sel = window.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset;\n    }\n\n    // Store the current state of the DOM selection.\n\n  }, {\n    key: \"storeDOMState\",\n    value: function storeDOMState() {\n      var sel = window.getSelection();\n      this.lastAnchorNode = sel.anchorNode;this.lastAnchorOffset = sel.anchorOffset;\n      this.lastHeadNode = sel.focusNode;this.lastHeadOffset = sel.focusOffset;\n    }\n\n    // : () → bool\n    // When the DOM selection changes in a notable manner, modify the\n    // current selection state to match.\n\n  }, {\n    key: \"readFromDOM\",\n    value: function readFromDOM() {\n      if (!hasFocus(this.pm) || !this.domChanged()) return false;\n\n      var _selectionFromDOM = selectionFromDOM(this.pm, this.pm.doc, this.range.head);\n\n      var range = _selectionFromDOM.range;\n      var adjusted = _selectionFromDOM.adjusted;\n\n      this.setAndSignal(range);\n\n      if (range instanceof NodeSelection || adjusted) {\n        this.toDOM();\n      } else {\n        this.clearNode();\n        this.storeDOMState();\n      }\n      return true;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM(takeFocus) {\n      if (!hasFocus(this.pm)) {\n        if (!takeFocus) return;\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444\n        else if (_dom.browser.gecko) this.pm.content.focus();\n      }\n      if (this.range instanceof NodeSelection) this.nodeToDOM();else this.rangeToDOM();\n    }\n\n    // Make changes to the DOM for a node selection.\n\n  }, {\n    key: \"nodeToDOM\",\n    value: function nodeToDOM() {\n      var dom = (0, _dompos.DOMAfterPos)(this.pm, this.range.from);\n      if (dom != this.lastNode) {\n        this.clearNode();\n        dom.classList.add(\"ProseMirror-selectednode\");\n        this.pm.content.classList.add(\"ProseMirror-nodeselection\");\n        this.lastNode = dom;\n      }\n      var range = document.createRange(),\n          sel = window.getSelection();\n      range.selectNode(dom);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      this.storeDOMState();\n    }\n\n    // Make changes to the DOM for a text selection.\n\n  }, {\n    key: \"rangeToDOM\",\n    value: function rangeToDOM() {\n      this.clearNode();\n\n      var anchor = (0, _dompos.DOMFromPos)(this.pm, this.range.anchor);\n      var head = (0, _dompos.DOMFromPos)(this.pm, this.range.head);\n\n      var sel = window.getSelection(),\n          range = document.createRange();\n      if (sel.extend) {\n        range.setEnd(anchor.node, anchor.offset);\n        range.collapse(false);\n      } else {\n        if (this.range.anchor > this.range.head) {\n          var tmp = anchor;anchor = head;head = tmp;\n        }\n        range.setEnd(head.node, head.offset);\n        range.setStart(anchor.node, anchor.offset);\n      }\n      sel.removeAllRanges();\n      sel.addRange(range);\n      if (sel.extend) sel.extend(head.node, head.offset);\n      this.storeDOMState();\n    }\n\n    // Clear all DOM statefulness of the last node selection.\n\n  }, {\n    key: \"clearNode\",\n    value: function clearNode() {\n      if (this.lastNode) {\n        this.lastNode.classList.remove(\"ProseMirror-selectednode\");\n        this.pm.content.classList.remove(\"ProseMirror-nodeselection\");\n        this.lastNode = null;\n        return true;\n      }\n    }\n  }, {\n    key: \"receivedFocus\",\n    value: function receivedFocus() {\n      if (this.polling == null) this.startPolling();\n    }\n  }]);\n\n  return SelectionState;\n}();\n\n// ;; An editor selection. Can be one of two selection types:\n// `TextSelection` and `NodeSelection`. Both have the properties\n// listed here, but also contain more information (such as the\n// selected [node](#NodeSelection.node) or the\n// [head](#TextSelection.head) and [anchor](#TextSelection.anchor)).\n\n\nvar Selection = exports.Selection = function Selection() {\n  _classCallCheck(this, Selection);\n};\n\n// :: number #path=Selection.prototype.from\n// The left-bound of the selection.\n\n// :: number #path=Selection.prototype.to\n// The right-bound of the selection.\n\n// :: bool #path=Selection.prototype.empty\n// True if the selection is an empty text selection (head an anchor\n// are the same).\n\n// :: (other: Selection) → bool #path=Selection.prototype.eq\n// Test whether the selection is the same as another selection.\n\n// :: (doc: Node, mapping: Mappable) → Selection #path=Selection.prototype.map\n// Map this selection through a [mappable](#Mappable) thing. `doc`\n// should be the new document, to which we are mapping.\n\n\n// ;; A text selection represents a classical editor\n// selection, with a head (the moving side) and anchor (immobile\n// side), both of which point into textblock nodes. It can be empty (a\n// regular cursor position).\n\nvar TextSelection = exports.TextSelection = function (_Selection) {\n  _inherits(TextSelection, _Selection);\n\n  // :: (number, ?number)\n  // Construct a text selection. When `head` is not given, it defaults\n  // to `anchor`.\n\n  function TextSelection(anchor, head) {\n    _classCallCheck(this, TextSelection);\n\n    // :: number\n    // The selection's immobile side (does not move when pressing\n    // shift-arrow).\n\n    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(TextSelection).call(this));\n\n    _this2.anchor = anchor;\n    // :: number\n    // The selection's mobile side (the side that moves when pressing\n    // shift-arrow).\n    _this2.head = head == null ? anchor : head;\n    return _this2;\n  }\n\n  _createClass(TextSelection, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof TextSelection && other.head == this.head && other.anchor == this.anchor;\n    }\n  }, {\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var head = mapping.map(this.head);\n      if (!doc.resolve(head).parent.isTextblock) return findSelectionNear(doc, head);\n      var anchor = mapping.map(this.anchor);\n      return new TextSelection(doc.resolve(anchor).parent.isTextblock ? anchor : head, head);\n    }\n  }, {\n    key: \"inverted\",\n    get: function get() {\n      return this.anchor > this.head;\n    }\n  }, {\n    key: \"from\",\n    get: function get() {\n      return Math.min(this.head, this.anchor);\n    }\n  }, {\n    key: \"to\",\n    get: function get() {\n      return Math.max(this.head, this.anchor);\n    }\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return this.anchor == this.head;\n    }\n  }, {\n    key: \"token\",\n    get: function get() {\n      return new SelectionToken(TextSelection, this.anchor, this.head);\n    }\n  }], [{\n    key: \"mapToken\",\n    value: function mapToken(token, mapping) {\n      return new SelectionToken(TextSelection, mapping.map(token.a), mapping.map(token.b));\n    }\n  }, {\n    key: \"fromToken\",\n    value: function fromToken(token, doc) {\n      if (!doc.resolve(token.b).parent.isTextblock) return findSelectionNear(doc, token.b);\n      return new TextSelection(doc.resolve(token.a).parent.isTextblock ? token.a : token.b, token.b);\n    }\n  }]);\n\n  return TextSelection;\n}(Selection);\n\n// ;; A node selection is a selection that points at a\n// single node. All nodes marked [selectable](#NodeType.selectable)\n// can be the target of a node selection. In such an object, `from`\n// and `to` point directly before and after the selected node.\n\n\nvar NodeSelection = exports.NodeSelection = function (_Selection2) {\n  _inherits(NodeSelection, _Selection2);\n\n  // :: (number, number, Node)\n  // Create a node selection. Does not verify the validity of its\n  // arguments. Use `ProseMirror.setNodeSelection` for an easier,\n  // error-checking way to create a node selection.\n\n  function NodeSelection(from, to, node) {\n    _classCallCheck(this, NodeSelection);\n\n    var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(NodeSelection).call(this));\n\n    _this3.from = from;\n    _this3.to = to;\n    // :: Node The selected node.\n    _this3.node = node;\n    return _this3;\n  }\n\n  _createClass(NodeSelection, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof NodeSelection && this.from == other.from;\n    }\n  }, {\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var from = mapping.map(this.from, 1);\n      var to = mapping.map(this.to, -1);\n      var node = doc.nodeAt(from);\n      if (node && to == from + node.nodeSize && node.type.selectable) return new NodeSelection(from, to, node);\n      return findSelectionNear(doc, from);\n    }\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"token\",\n    get: function get() {\n      return new SelectionToken(NodeSelection, this.from, this.to);\n    }\n  }], [{\n    key: \"mapToken\",\n    value: function mapToken(token, mapping) {\n      return new SelectionToken(TextSelection, mapping.map(token.a, 1), mapping.map(token.b, -1));\n    }\n  }, {\n    key: \"fromToken\",\n    value: function fromToken(token, doc) {\n      var node = doc.nodeAt(token.a);\n      if (node && token.b == token.a + node.nodeSize && node.type.selectable) return new NodeSelection(token.a, token.b, node);\n      return findSelectionNear(doc, token.a);\n    }\n  }]);\n\n  return NodeSelection;\n}(Selection);\n\nvar SelectionToken = function SelectionToken(type, a, b) {\n  _classCallCheck(this, SelectionToken);\n\n  this.type = type;\n  this.a = a;\n  this.b = b;\n};\n\nfunction selectionFromDOM(pm, doc, oldHead, loose) {\n  var sel = window.getSelection();\n  var anchor = (0, _dompos.posFromDOM)(pm, sel.anchorNode, sel.anchorOffset, loose);\n  var head = sel.isCollapsed ? anchor : (0, _dompos.posFromDOM)(pm, sel.focusNode, sel.focusOffset, loose);\n\n  var range = findSelectionNear(doc, head, oldHead != null && oldHead < head ? 1 : -1);\n  if (range instanceof TextSelection) {\n    var selNearAnchor = findSelectionNear(doc, anchor, anchor > range.to ? -1 : 1, true);\n    range = new TextSelection(selNearAnchor.anchor, range.head);\n  } else if (anchor < range.from || anchor > range.to) {\n    // If head falls on a node, but anchor falls outside of it,\n    // create a text selection between them\n    var inv = anchor > range.to;\n    range = new TextSelection(findSelectionNear(doc, anchor, inv ? -1 : 1, true).anchor, findSelectionNear(doc, inv ? range.from : range.to, inv ? 1 : -1, true).head);\n  }\n  return { range: range, adjusted: head != range.head || anchor != range.anchor };\n}\n\nfunction hasFocus(pm) {\n  if (document.activeElement != pm.content) return false;\n  var sel = window.getSelection();\n  return sel.rangeCount && (0, _dom.contains)(pm.content, sel.anchorNode);\n}\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(node, pos, index, dir, text) {\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (child.isTextblock) return new TextSelection(pos + dir);\n    if (!child.type.isLeaf) {\n      var inner = findSelectionIn(child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) return inner;\n    } else if (!text && child.type.selectable) {\n      return new NodeSelection(pos - (dir < 0 ? child.nodeSize : 0), pos + (dir > 0 ? child.nodeSize : 0), child);\n    }\n    pos += child.nodeSize * dir;\n  }\n}\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Create a selection which is moved relative to a position in a\n// given direction. When a selection isn't found at the given position,\n// walks up the document tree one level and one step in the\n// desired direction.\nfunction findSelectionFrom(doc, pos, dir, text) {\n  var $pos = doc.resolve(pos);\n  var inner = $pos.parent.isTextblock ? new TextSelection(pos) : findSelectionIn($pos.parent, pos, $pos.index(), dir, text);\n  if (inner) return inner;\n\n  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n    var found = dir < 0 ? findSelectionIn($pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, text) : findSelectionIn($pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, text);\n    if (found) return found;\n  }\n}\n\nfunction findSelectionNear(doc, pos) {\n  var bias = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n  var text = arguments[3];\n\n  var result = findSelectionFrom(doc, pos, bias, text) || findSelectionFrom(doc, pos, -bias, text);\n  if (!result) throw new RangeError(\"Searching for selection in invalid document \" + doc);\n  return result;\n}\n\n// Find the selection closest to the start of the given node. `pos`,\n// if given, should point at the start of the node's content.\nfunction findSelectionAtStart(node, text) {\n  return findSelectionIn(node, 0, 0, 1, text);\n}\n\n// Find the selection closest to the end of the given node.\nfunction findSelectionAtEnd(node, text) {\n  return findSelectionIn(node, node.content.size, node.childCount, -1, text);\n}\n\n// : (ProseMirror, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction verticalMotionLeavesTextblock(pm, pos, dir) {\n  var $pos = pm.doc.resolve(pos);\n  var dom = (0, _dompos.DOMAfterPos)(pm, $pos.before());\n  var coords = (0, _dompos.coordsAtPos)(pm, pos);\n  for (var child = dom.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType != 1) continue;\n    var boxes = child.getClientRects();\n    for (var i = 0; i < boxes.length; i++) {\n      var box = boxes[i];\n      if (dir < 0 ? box.bottom < coords.top : box.top > coords.bottom) return false;\n    }\n  }\n  return true;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/selection.js\n ** module id = 49\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/selection.js?");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.posBeforeFromDOM = posBeforeFromDOM;\nexports.posFromDOM = posFromDOM;\nexports.childContainer = childContainer;\nexports.DOMFromPos = DOMFromPos;\nexports.DOMAfterPos = DOMAfterPos;\nexports.scrollIntoView = scrollIntoView;\nexports.posAtCoords = posAtCoords;\nexports.coordsAtPos = coordsAtPos;\nexports.selectableNodeAbove = selectableNodeAbove;\nexports.handleNodeClick = handleNodeClick;\n\nvar _dom = __webpack_require__(10);\n\n// : (ProseMirror, DOMNode) → number\n// Get the path for a given a DOM node in a document.\nfunction posBeforeFromDOM(pm, node) {\n  var pos = 0,\n      add = 0;\n  for (var cur = node; cur != pm.content; cur = cur.parentNode) {\n    var attr = cur.getAttribute(\"pm-offset\");\n    if (attr) {\n      pos += +attr + add;add = 1;\n    }\n  }\n  return pos;\n}\n\n// : (ProseMirror, DOMNode, number) → number\nfunction posFromDOM(pm, dom, domOffset, loose) {\n  if (!loose && pm.operation && pm.doc != pm.operation.doc) throw new RangeError(\"Fetching a position from an outdated DOM structure\");\n\n  if (domOffset == null) {\n    domOffset = Array.prototype.indexOf.call(dom.parentNode.childNodes, dom);\n    dom = dom.parentNode;\n  }\n\n  // Move up to the wrapping container, counting local offset along\n  // the way.\n  var innerOffset = 0,\n      tag = undefined;\n  for (;;) {\n    var adjust = 0;\n    if (dom.nodeType == 3) {\n      innerOffset += domOffset;\n      // IE has a habit of splitting text nodes for no apparent reason\n      if (loose) for (var _before = dom.previousSibling; _before && _before.nodeType == 3; _before = _before.previousSibling) {\n        innerOffset += _before.nodeValue.length;\n      }\n    } else if (tag = dom.getAttribute(\"pm-offset\") && !childContainer(dom)) {\n      if (!loose) {\n        var size = +dom.getAttribute(\"pm-size\");\n        if (domOffset == dom.childNodes.length) innerOffset = size;else innerOffset = Math.min(innerOffset, size);\n      } else {\n        for (var i = 0; i < domOffset; i++) {\n          var child = dom.childNodes[i];\n          if (child.nodeType == 3) innerOffset += child.nodeValue.length;\n        }\n      }\n      return posBeforeFromDOM(pm, dom) + innerOffset;\n    } else if (dom.hasAttribute(\"pm-container\")) {\n      break;\n    } else if (tag = dom.getAttribute(\"pm-inner-offset\")) {\n      innerOffset += +tag;\n      adjust = -1;\n    } else if (domOffset && domOffset == dom.childNodes.length) {\n      adjust = 1;\n    }\n\n    var parent = dom.parentNode;\n    domOffset = adjust < 0 ? 0 : Array.prototype.indexOf.call(parent.childNodes, dom) + adjust;\n    dom = parent;\n  }\n\n  var start = dom == pm.content ? 0 : posBeforeFromDOM(pm, dom) + 1,\n      before = 0;\n\n  for (var child = dom.childNodes[domOffset - 1]; child; child = child.previousSibling) {\n    if (child.nodeType == 1 && (tag = child.getAttribute(\"pm-offset\"))) {\n      before += +tag + +child.getAttribute(\"pm-size\");\n      break;\n    } else if (loose && child.nodeType == 3) {\n      before += child.nodeValue.length;\n    }\n  }\n  return start + before + innerOffset;\n}\n\n// : (DOMNode) → ?DOMNode\nfunction childContainer(dom) {\n  return dom.hasAttribute(\"pm-container\") ? dom : dom.querySelector(\"[pm-container]\");\n}\n\n// : (ProseMirror, number) → {node: DOMNode, offset: number}\n// Find the DOM node and offset into that node that the given document\n// position refers to.\nfunction DOMFromPos(pm, pos, loose) {\n  if (!loose && pm.operation && pm.doc != pm.operation.doc) throw new RangeError(\"Resolving a position in an outdated DOM structure\");\n\n  var container = pm.content,\n      offset = pos;\n  for (;;) {\n    for (var child = container.firstChild, i = 0;; child = child.nextSibling, i++) {\n      if (!child) {\n        if (offset && !loose) throw new RangeError(\"Failed to find node at \" + pos);\n        return { node: container, offset: i };\n      }\n\n      var size = child.nodeType == 1 && child.getAttribute(\"pm-size\");\n      if (size) {\n        if (!offset) return { node: container, offset: i };\n        size = +size;\n        if (offset < size) {\n          container = childContainer(child);\n          if (!container) {\n            return leafAt(child, offset);\n          } else {\n            offset--;\n            break;\n          }\n        } else {\n          offset -= size;\n        }\n      }\n    }\n  }\n}\n\n// : (ProseMirror, number) → DOMNode\nfunction DOMAfterPos(pm, pos) {\n  var _DOMFromPos = DOMFromPos(pm, pos);\n\n  var node = _DOMFromPos.node;\n  var offset = _DOMFromPos.offset;\n\n  if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError(\"No node after pos \" + pos);\n  return node.childNodes[offset];\n}\n\n// : (DOMNode, number) → {node: DOMNode, offset: number}\nfunction leafAt(node, offset) {\n  for (;;) {\n    var child = node.firstChild;\n    if (!child) return { node: node, offset: offset };\n    if (child.nodeType != 1) return { node: child, offset: offset };\n    if (child.hasAttribute(\"pm-inner-offset\")) {\n      var nodeOffset = 0;\n      for (;;) {\n        var nextSib = child.nextSibling,\n            nextOffset = undefined;\n        if (!nextSib || (nextOffset = +nextSib.getAttribute(\"pm-inner-offset\")) >= offset) break;\n        child = nextSib;\n        nodeOffset = nextOffset;\n      }\n      offset -= nodeOffset;\n    }\n    node = child;\n  }\n}\n\nfunction windowRect() {\n  return { left: 0, right: window.innerWidth,\n    top: 0, bottom: window.innerHeight };\n}\n\nfunction scrollIntoView(pm, pos) {\n  if (!pos) pos = pm.sel.range.head || pm.sel.range.from;\n  var coords = coordsAtPos(pm, pos);\n  for (var parent = pm.content;; parent = parent.parentNode) {\n    var _pm$options = pm.options;\n    var scrollThreshold = _pm$options.scrollThreshold;\n    var scrollMargin = _pm$options.scrollMargin;\n\n    var atBody = parent == document.body;\n    var rect = atBody ? windowRect() : parent.getBoundingClientRect();\n    var moveX = 0,\n        moveY = 0;\n    if (coords.top < rect.top + scrollThreshold) moveY = -(rect.top - coords.top + scrollMargin);else if (coords.bottom > rect.bottom - scrollThreshold) moveY = coords.bottom - rect.bottom + scrollMargin;\n    if (coords.left < rect.left + scrollThreshold) moveX = -(rect.left - coords.left + scrollMargin);else if (coords.right > rect.right - scrollThreshold) moveX = coords.right - rect.right + scrollMargin;\n    if (moveX || moveY) {\n      if (atBody) {\n        window.scrollBy(moveX, moveY);\n      } else {\n        if (moveY) parent.scrollTop += moveY;\n        if (moveX) parent.scrollLeft += moveX;\n      }\n    }\n    if (atBody) break;\n  }\n}\n\nfunction findOffsetInNode(node, coords) {\n  var closest = undefined,\n      dyClosest = 2e8,\n      coordsClosest = undefined,\n      offset = 0;\n  for (var child = node.firstChild; child; child = child.nextSibling) {\n    var rects = undefined;\n    if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRange(child).getClientRects();else continue;\n\n    for (var i = 0; i < rects.length; i++) {\n      var rect = rects[i];\n      if (rect.left <= coords.left && rect.right >= coords.left) {\n        var dy = rect.top > coords.top ? rect.top - coords.top : rect.bottom < coords.top ? coords.top - rect.bottom : 0;\n        if (dy < dyClosest) {\n          // FIXME does not group by row\n          closest = child;\n          dyClosest = dy;\n          coordsClosest = dy ? { left: coords.left, top: rect.top } : coords;\n          if (child.nodeType == 1 && !child.firstChild) offset = i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n          continue;\n        }\n      }\n      if (!closest && (coords.top >= rect.bottom || coords.top >= rect.top && coords.left >= rect.right)) offset = i + 1;\n    }\n  }\n  if (!closest) return { node: node, offset: offset };\n  if (closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);\n  if (closest.firstChild) return findOffsetInNode(closest, coordsClosest);\n  return { node: node, offset: offset };\n}\n\nfunction findOffsetInText(node, coords) {\n  var len = node.nodeValue.length;\n  var range = document.createRange();\n  for (var i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    var rect = range.getBoundingClientRect();\n    if (rect.top == rect.bottom) continue;\n    if (rect.left - 1 <= coords.left && rect.right + 1 >= coords.left && rect.top - 1 <= coords.top && rect.bottom + 1 >= coords.top) return { node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n  }\n  return { node: node, offset: 0 };\n}\n\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(pm, coords) {\n  var elt = document.elementFromPoint(coords.left, coords.top + 1);\n  if (!(0, _dom.contains)(pm.content, elt)) return null;\n\n  if (!elt.firstChild) elt = elt.parentNode;\n\n  var _findOffsetInNode = findOffsetInNode(elt, coords);\n\n  var node = _findOffsetInNode.node;\n  var offset = _findOffsetInNode.offset;\n\n  return posFromDOM(pm, node, offset);\n}\n\nfunction textRange(node, from, to) {\n  var range = document.createRange();\n  range.setEnd(node, to == null ? node.nodeValue.length : to);\n  range.setStart(node, from || 0);\n  return range;\n}\n\nfunction singleRect(object, bias) {\n  var rects = object.getClientRects();\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];\n}\n\n// : (ProseMirror, number) → ClientRect\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(pm, pos) {\n  var _DOMFromPos2 = DOMFromPos(pm, pos);\n\n  var node = _DOMFromPos2.node;\n  var offset = _DOMFromPos2.offset;\n\n  var side = undefined,\n      rect = undefined;\n  if (node.nodeType == 3) {\n    if (offset < node.nodeValue.length) {\n      rect = singleRect(textRange(node, offset, offset + 1), -1);\n      side = \"left\";\n    }\n    if ((!rect || rect.left == rect.right) && offset) {\n      rect = singleRect(textRange(node, offset - 1, offset), 1);\n      side = \"right\";\n    }\n  } else if (node.firstChild) {\n    if (offset < node.childNodes.length) {\n      var child = node.childNodes[offset];\n      rect = singleRect(child.nodeType == 3 ? textRange(child) : child, -1);\n      side = \"left\";\n    }\n    if ((!rect || rect.top == rect.bottom) && offset) {\n      var child = node.childNodes[offset - 1];\n      rect = singleRect(child.nodeType == 3 ? textRange(child) : child, 1);\n      side = \"right\";\n    }\n  } else {\n    rect = node.getBoundingClientRect();\n    side = \"left\";\n  }\n  var x = rect[side];\n  return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n}\n\n// ;; #path=NodeType #kind=class #noAnchor\n// You can add several properties to [node types](#NodeType) to\n// influence the way the editor interacts with them.\n\n// :: (node: Node, pos: number, dom: DOMNode, coords: {left: number, top: number}) → ?number\n// #path=NodeType.prototype.countCoordsAsChild\n// Specifies that, if this node is clicked, a child node might\n// actually be meant. This is used to, for example, make clicking a\n// list marker (which, in the DOM, is part of the list node) select\n// the list item it belongs to. Should return null if the given\n// coordinates don't refer to a child node, or the position\n// before the child otherwise.\n\nfunction selectableNodeAbove(pm, dom, coords, liberal) {\n  for (; dom && dom != pm.content; dom = dom.parentNode) {\n    if (dom.hasAttribute(\"pm-offset\")) {\n      var pos = posBeforeFromDOM(pm, dom),\n          node = pm.doc.nodeAt(pos);\n      if (node.type.countCoordsAsChild) {\n        var result = node.type.countCoordsAsChild(node, pos, dom, coords);\n        if (result != null) return result;\n      }\n      // Leaf nodes are implicitly clickable\n      if ((liberal || node.type.isLeaf) && node.type.selectable) return pos;\n      if (!liberal) return null;\n    }\n  }\n}\n\n// :: (pm: ProseMirror, event: MouseEvent, pos: number, node: Node) → bool\n// #path=NodeType.prototype.handleClick\n// If a node is directly clicked (that is, the click didn't land in a\n// DOM node belonging to a child node), and its type has a\n// `handleClick` method, that method is given a chance to handle the\n// click. The method is called, and should return `false` if it did\n// _not_ handle the click.\n//\n// The `event` passed is the event for `\"mousedown\"`, but calling\n// `preventDefault` on it has no effect, since this method is only\n// called after a corresponding `\"mouseup\"` has occurred and\n// ProseMirror has determined that this is not a drag or multi-click\n// event.\n\n// :: (pm: ProseMirror, event: MouseEvent, pos: number, node: Node) → bool\n// #path=NodeType.prototype.handleDoubleClick\n// This works like [`handleClick`](#NodeType.handleClick), but is\n// called for double clicks instead.\n\n// :: (pm: ProseMirror, event: MouseEvent, pos: number, node: Node) → bool\n// #path=NodeType.prototype.handleContextMenu\n//\n// When the [context\n// menu](https://developer.mozilla.org/en-US/docs/Web/Events/contextmenu)\n// is activated in the editable context, nodes that the clicked\n// position falls inside of get a chance to react to it. Node types\n// may define a `handleContextMenu` method, which will be called when\n// present, first on inner nodes and then up the document tree, until\n// one of the methods returns something other than `false`.\n//\n// The handlers can inspect `event.target` to figure out whether they\n// were directly clicked, and may call `event.preventDefault()` to\n// prevent the native context menu.\n\nfunction handleNodeClick(pm, type, event, target, direct) {\n  for (var dom = target; dom && dom != pm.content; dom = dom.parentNode) {\n    if (dom.hasAttribute(\"pm-offset\")) {\n      var pos = posBeforeFromDOM(pm, dom),\n          node = pm.doc.nodeAt(pos);\n      var handled = node.type[type] && node.type[type](pm, event, pos, node) !== false;\n      if (direct || handled) return handled;\n    }\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/dompos.js\n ** module id = 50\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/dompos.js?");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.draw = draw;\nexports.redraw = redraw;\n\nvar _format = __webpack_require__(15);\n\nvar _dom = __webpack_require__(10);\n\nvar _main = __webpack_require__(8);\n\nvar _dompos = __webpack_require__(50);\n\nfunction options(ranges) {\n  return {\n    pos: 0,\n    preRenderContent: function preRenderContent() {\n      this.pos++;\n    },\n    postRenderContent: function postRenderContent() {\n      this.pos++;\n    },\n    onRender: function onRender(node, dom, offset) {\n      if (node.isBlock) {\n        if (offset != null) dom.setAttribute(\"pm-offset\", offset);\n        dom.setAttribute(\"pm-size\", node.nodeSize);\n        if (node.isTextblock) adjustTrailingHacks(dom, node);\n        if (dom.contentEditable == \"false\") dom = (0, _dom.elt)(\"div\", null, dom);\n        if (node.type.isLeaf) this.pos++;\n      }\n\n      return dom;\n    },\n    onContainer: function onContainer(node) {\n      node.setAttribute(\"pm-container\", true);\n    },\n\n    // : (Node, DOMNode, number) → DOMNode\n    renderInlineFlat: function renderInlineFlat(node, dom, offset) {\n      ranges.advanceTo(this.pos);\n      var pos = this.pos,\n          end = pos + node.nodeSize;\n      var nextCut = ranges.nextChangeBefore(end);\n\n      var inner = dom,\n          wrapped = undefined;\n      for (var i = 0; i < node.marks.length; i++) {\n        inner = inner.firstChild;\n      }if (dom.nodeType != 1) {\n        dom = (0, _dom.elt)(\"span\", null, dom);\n        if (nextCut == -1) wrapped = dom;\n      }\n      if (!wrapped && (nextCut > -1 || ranges.current.length)) {\n        wrapped = inner == dom ? dom = (0, _dom.elt)(\"span\", null, inner) : inner.parentNode.appendChild((0, _dom.elt)(\"span\", null, inner));\n      }\n\n      dom.setAttribute(\"pm-offset\", offset);\n      dom.setAttribute(\"pm-size\", node.nodeSize);\n\n      var inlineOffset = 0;\n      while (nextCut > -1) {\n        var size = nextCut - pos;\n        var split = splitSpan(wrapped, size);\n        if (ranges.current.length) split.className = ranges.current.join(\" \");\n        split.setAttribute(\"pm-inner-offset\", inlineOffset);\n        inlineOffset += size;\n        ranges.advanceTo(nextCut);\n        nextCut = ranges.nextChangeBefore(end);\n        if (nextCut == -1) wrapped.setAttribute(\"pm-inner-offset\", inlineOffset);\n        pos += size;\n      }\n\n      if (ranges.current.length) wrapped.className = ranges.current.join(\" \");\n      this.pos += node.nodeSize;\n      return dom;\n    },\n\n    document: document\n  };\n}\n\nfunction splitSpan(span, at) {\n  var textNode = span.firstChild,\n      text = textNode.nodeValue;\n  var newNode = span.parentNode.insertBefore((0, _dom.elt)(\"span\", null, text.slice(0, at)), span);\n  textNode.nodeValue = text.slice(at);\n  return newNode;\n}\n\nfunction draw(pm, doc) {\n  pm.content.textContent = \"\";\n  pm.content.appendChild((0, _format.toDOM)(doc, options(pm.ranges.activeRangeTracker())));\n}\n\nfunction adjustTrailingHacks(dom, node) {\n  var needs = node.content.size == 0 || node.lastChild.type.isBR || node.type.isCode && node.lastChild.isText && /\\n$/.test(node.lastChild.text) ? \"br\" : !node.lastChild.isText && node.lastChild.type.isLeaf ? \"text\" : null;\n  var last = dom.lastChild;\n  var has = !last || last.nodeType != 1 || !last.hasAttribute(\"pm-ignore\") ? null : last.nodeName == \"BR\" ? \"br\" : \"text\";\n  if (needs != has) {\n    if (has) dom.removeChild(last);\n    if (needs) dom.appendChild(needs == \"br\" ? (0, _dom.elt)(\"br\", { \"pm-ignore\": \"trailing-break\" }) : (0, _dom.elt)(\"span\", { \"pm-ignore\": \"cursor-text\" }, \"\"));\n  }\n}\n\nfunction findNodeIn(parent, i, node) {\n  for (; i < parent.childCount; i++) {\n    var child = parent.child(i);\n    if (child == node) return i;\n  }\n  return -1;\n}\n\nfunction movePast(dom) {\n  var next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next;\n}\n\nfunction redraw(pm, dirty, doc, prev) {\n  if (dirty.get(prev) == _main.DIRTY_REDRAW) return draw(pm, doc);\n\n  var opts = options(pm.ranges.activeRangeTracker());\n\n  function scan(dom, node, prev, pos) {\n    var iPrev = 0,\n        pChild = prev.firstChild;\n    var domPos = dom.firstChild;\n\n    for (var iNode = 0, offset = 0; iNode < node.childCount; iNode++) {\n      var child = node.child(iNode),\n          matching = undefined,\n          reuseDOM = undefined;\n      var found = pChild == child ? iPrev : findNodeIn(prev, iPrev + 1, child);\n      if (found > -1) {\n        matching = child;\n        while (iPrev != found) {\n          iPrev++;\n          domPos = movePast(domPos);\n        }\n      }\n\n      if (matching && !dirty.get(matching)) {\n        reuseDOM = true;\n      } else if (pChild && !child.isText && child.sameMarkup(pChild) && dirty.get(pChild) != _main.DIRTY_REDRAW) {\n        reuseDOM = true;\n        if (!pChild.type.isLeaf) scan((0, _dompos.childContainer)(domPos), child, pChild, pos + offset + 1);\n      } else {\n        opts.pos = pos + offset;\n        var rendered = (0, _format.nodeToDOM)(child, opts, offset);\n        dom.insertBefore(rendered, domPos);\n        reuseDOM = false;\n      }\n\n      if (reuseDOM) {\n        domPos.setAttribute(\"pm-offset\", offset);\n        domPos.setAttribute(\"pm-size\", child.nodeSize);\n        domPos = domPos.nextSibling;\n        pChild = prev.maybeChild(++iPrev);\n      }\n      offset += child.nodeSize;\n    }\n\n    while (pChild) {\n      domPos = movePast(domPos);\n      pChild = prev.maybeChild(++iPrev);\n    }\n    if (node.isTextblock) adjustTrailingHacks(dom, node);\n\n    if (_dom.browser.ios) iosHacks(dom);\n  }\n  scan(pm.content, doc, prev, 0);\n}\n\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    var oldCSS = dom.style.cssText;\n    dom.style.cssText = oldCSS + \"; list-style: square !important\";\n    window.getComputedStyle(dom).listStyle;\n    dom.style.cssText = oldCSS;\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/draw.js\n ** module id = 51\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/draw.js?");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Input = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _model = __webpack_require__(18);\n\nvar _browserkeymap = __webpack_require__(11);\n\nvar _browserkeymap2 = _interopRequireDefault(_browserkeymap);\n\nvar _format = __webpack_require__(15);\n\nvar _capturekeys = __webpack_require__(53);\n\nvar _dom = __webpack_require__(10);\n\nvar _domchange = __webpack_require__(54);\n\nvar _selection = __webpack_require__(49);\n\nvar _dompos = __webpack_require__(50);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar stopSeq = null;\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nvar handlers = {};\n\nvar Input = exports.Input = function () {\n  function Input(pm) {\n    var _this = this;\n\n    _classCallCheck(this, Input);\n\n    this.pm = pm;\n    this.baseKeymap = null;\n\n    this.keySeq = null;\n\n    this.mouseDown = null;\n    this.dragging = null;\n    this.dropTarget = null;\n    this.shiftKey = false;\n    this.finishComposing = null;\n\n    this.keymaps = [];\n    this.defaultKeymap = null;\n\n    this.storedMarks = null;\n\n    var _loop = function _loop(event) {\n      var handler = handlers[event];\n      pm.content.addEventListener(event, function (e) {\n        return handler(pm, e);\n      });\n    };\n\n    for (var event in handlers) {\n      _loop(event);\n    }\n\n    pm.on(\"selectionChange\", function () {\n      return _this.storedMarks = null;\n    });\n  }\n\n  // Dispatch a key press to the internal keymaps, which will override the default\n  // DOM behavior.\n\n\n  _createClass(Input, [{\n    key: \"dispatchKey\",\n    value: function dispatchKey(name, e) {\n      var pm = this.pm,\n          seq = pm.input.keySeq;\n      // If the previous key should be used in sequence with this one, modify the name accordingly.\n      if (seq) {\n        if (_browserkeymap2.default.isModifierKey(name)) return true;\n        clearTimeout(stopSeq);\n        stopSeq = setTimeout(function () {\n          if (pm.input.keySeq == seq) pm.input.keySeq = null;\n        }, 50);\n        name = seq + \" \" + name;\n      }\n\n      var handle = function handle(bound) {\n        if (bound === false) return \"nothing\";\n        if (bound == \"...\") return \"multi\";\n        if (bound == null) return false;\n\n        var result = false;\n        if (Array.isArray(bound)) {\n          for (var i = 0; result === false && i < bound.length; i++) {\n            result = handle(bound[i]);\n          }\n        } else if (typeof bound == \"string\") {\n          result = pm.execCommand(bound);\n        } else {\n          result = bound(pm);\n        }\n        return result == false ? false : \"handled\";\n      };\n\n      var result = undefined;\n      for (var i = 0; !result && i < pm.input.keymaps.length; i++) {\n        result = handle(pm.input.keymaps[i].map.lookup(name, pm));\n      }if (!result) result = handle(pm.input.baseKeymap.lookup(name, pm)) || handle(_capturekeys.captureKeys.lookup(name));\n\n      // If the key should be used in sequence with the next key, store the keyname internally.\n      if (result == \"multi\") pm.input.keySeq = name;\n\n      if ((result == \"handled\" || result == \"multi\") && e) e.preventDefault();\n\n      if (seq && !result && /\\'$/.test(name)) {\n        if (e) e.preventDefault();\n        return true;\n      }\n      return !!result;\n    }\n\n    // : (ProseMirror, TextSelection, string, ?(Node) → Selection)\n    // Insert text into a document.\n\n  }, {\n    key: \"insertText\",\n    value: function insertText(from, to, text, findSelection) {\n      if (from == to && !text) return;\n      var pm = this.pm,\n          marks = pm.input.storedMarks || pm.doc.marksAt(from);\n      var tr = pm.tr.replaceWith(from, to, text ? pm.schema.text(text, marks) : null);\n      tr.apply({\n        scrollIntoView: true,\n        selection: findSelection && findSelection(tr.doc) || (0, _selection.findSelectionNear)(tr.doc, tr.map(to), -1, true)\n      });\n      // :: () #path=ProseMirror#events#textInput\n      // Fired when the user types text into the editor.\n      if (text) pm.signal(\"textInput\", text);\n    }\n  }, {\n    key: \"startComposition\",\n    value: function startComposition(dataLen, realStart) {\n      this.pm.ensureOperation({ noFlush: true, readSelection: realStart }).composing = {\n        ended: false,\n        applied: false,\n        margin: dataLen\n      };\n      this.pm.unscheduleFlush();\n    }\n  }, {\n    key: \"applyComposition\",\n    value: function applyComposition(andFlush) {\n      var composing = this.composing;\n      if (composing.applied) return;\n      (0, _domchange.readCompositionChange)(this.pm, composing.margin);\n      composing.applied = true;\n      // Operations that read DOM changes must be flushed, to make sure\n      // subsequent DOM changes find a clean DOM.\n      if (andFlush) this.pm.flush();\n    }\n  }, {\n    key: \"composing\",\n    get: function get() {\n      return this.pm.operation && this.pm.operation.composing;\n    }\n  }]);\n\n  return Input;\n}();\n\nhandlers.keydown = function (pm, e) {\n  // :: () #path=ProseMirror#events#interaction\n  // Fired when the user interacts with the editor, for example by\n  // clicking on it or pressing a key while it is focused. Mostly\n  // useful for closing or resetting transient UI state such as open\n  // menus.\n  if (!(0, _selection.hasFocus)(pm)) return;\n  pm.signal(\"interaction\");\n  if (e.keyCode == 16) pm.input.shiftKey = true;\n  if (pm.input.composing) return;\n  var name = _browserkeymap2.default.keyName(e);\n  if (name && pm.input.dispatchKey(name, e)) return;\n  pm.sel.fastPoll();\n};\n\nhandlers.keyup = function (pm, e) {\n  if (e.keyCode == 16) pm.input.shiftKey = false;\n};\n\nhandlers.keypress = function (pm, e) {\n  if (!(0, _selection.hasFocus)(pm) || pm.input.composing || !e.charCode || e.ctrlKey && !e.altKey || _dom.browser.mac && e.metaKey) return;\n  if (pm.input.dispatchKey(_browserkeymap2.default.keyName(e), e)) return;\n  var sel = pm.selection;\n  // On iOS, let input through, because if we handle it the virtual\n  // keyboard's default case doesn't update (it only does so when the\n  // user types or taps, not on selection updates from JavaScript).\n  if (!_dom.browser.ios) {\n    pm.input.insertText(sel.from, sel.to, String.fromCharCode(e.charCode));\n    e.preventDefault();\n  }\n};\n\nfunction realTarget(pm, mouseEvent) {\n  if (pm.operation && pm.flush()) return document.elementFromPoint(mouseEvent.clientX, mouseEvent.clientY);else return mouseEvent.target;\n}\n\nfunction selectClickedNode(pm, e, target) {\n  var pos = (0, _dompos.selectableNodeAbove)(pm, target, { left: e.clientX, top: e.clientY }, true);\n  if (pos == null) return pm.sel.fastPoll();\n\n  var _pm$selection = pm.selection;\n  var node = _pm$selection.node;\n  var from = _pm$selection.from;\n\n  if (node) {\n    var $pos = pm.doc.resolve(pos),\n        $from = pm.doc.resolve(from);\n    if ($pos.depth >= $from.depth && $pos.before() == from) {\n      if ($from.depth == 0) return pm.sel.fastPoll();\n      pos = $pos.before();\n    }\n  }\n\n  pm.setNodeSelection(pos);\n  pm.focus();\n  e.preventDefault();\n}\n\nvar lastClick = 0,\n    oneButLastClick = 0;\n\nfunction handleTripleClick(pm, e, target) {\n  e.preventDefault();\n  var pos = (0, _dompos.selectableNodeAbove)(pm, target, { left: e.clientX, top: e.clientY }, true);\n  if (pos != null) {\n    var $pos = pm.doc.resolve(pos),\n        node = $pos.nodeAfter;\n    if (node.isBlock && !node.isTextblock) // Non-textblock block, select it\n      pm.setNodeSelection(pos);else if (node.isInline) // Inline node, select whole parent\n      pm.setTextSelection($pos.start(), $pos.end());else // Textblock, select content\n      pm.setTextSelection(pos + 1, pos + 1 + node.content.size);\n    pm.focus();\n  }\n}\n\nhandlers.mousedown = function (pm, e) {\n  pm.signal(\"interaction\");\n  var now = Date.now(),\n      doubleClick = now - lastClick < 500,\n      tripleClick = now - oneButLastClick < 600;\n  oneButLastClick = lastClick;\n  lastClick = now;\n\n  var target = realTarget(pm, e);\n  if (tripleClick) handleTripleClick(pm, e, target);else if (doubleClick && (0, _dompos.handleNodeClick)(pm, \"handleDoubleClick\", e, target, true)) {} else pm.input.mouseDown = new MouseDown(pm, e, target, doubleClick);\n};\n\nvar MouseDown = function () {\n  function MouseDown(pm, event, target, doubleClick) {\n    _classCallCheck(this, MouseDown);\n\n    this.pm = pm;\n    this.event = event;\n    this.target = target;\n    this.leaveToBrowser = pm.input.shiftKey || doubleClick;\n\n    var pos = (0, _dompos.posBeforeFromDOM)(pm, this.target),\n        node = pm.doc.nodeAt(pos);\n    this.mightDrag = node.type.draggable || node == pm.sel.range.node ? pos : null;\n    if (this.mightDrag != null) {\n      this.target.draggable = true;\n      if (_dom.browser.gecko && (this.setContentEditable = !this.target.hasAttribute(\"contentEditable\"))) this.target.setAttribute(\"contentEditable\", \"false\");\n    }\n\n    this.x = event.clientX;this.y = event.clientY;\n\n    window.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n    window.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n    pm.sel.fastPoll();\n  }\n\n  _createClass(MouseDown, [{\n    key: \"done\",\n    value: function done() {\n      window.removeEventListener(\"mouseup\", this.up);\n      window.removeEventListener(\"mousemove\", this.move);\n      if (this.mightDrag != null) {\n        this.target.draggable = false;\n        if (_dom.browser.gecko && this.setContentEditable) this.target.removeAttribute(\"contentEditable\");\n      }\n    }\n  }, {\n    key: \"up\",\n    value: function up(event) {\n      this.done();\n\n      var target = realTarget(this.pm, event);\n      if (this.leaveToBrowser || !(0, _dom.contains)(this.pm.content, target)) {\n        this.pm.sel.fastPoll();\n      } else if (this.event.ctrlKey) {\n        selectClickedNode(this.pm, event, target);\n      } else if (!(0, _dompos.handleNodeClick)(this.pm, \"handleClick\", event, target, true)) {\n        var pos = (0, _dompos.selectableNodeAbove)(this.pm, target, { left: this.x, top: this.y });\n        if (pos) {\n          this.pm.setNodeSelection(pos);\n          this.pm.focus();\n        } else {\n          this.pm.sel.fastPoll();\n        }\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(event) {\n      if (!this.leaveToBrowser && (Math.abs(this.x - event.clientX) > 4 || Math.abs(this.y - event.clientY) > 4)) this.leaveToBrowser = true;\n      this.pm.sel.fastPoll();\n    }\n  }]);\n\n  return MouseDown;\n}();\n\nhandlers.touchdown = function (pm) {\n  pm.sel.fastPoll();\n};\n\nhandlers.contextmenu = function (pm, e) {\n  (0, _dompos.handleNodeClick)(pm, \"handleContextMenu\", e, realTarget(pm, e), false);\n};\n\n// Input compositions are hard. Mostly because the events fired by\n// browsers are A) very unpredictable and inconsistent, and B) not\n// cancelable.\n//\n// ProseMirror has the problem that it must not update the DOM during\n// a composition, or the browser will cancel it. What it does is keep\n// long-running operations (delayed DOM updates) when a composition is\n// active.\n//\n// We _do not_ trust the information in the composition events which,\n// apart from being very uninformative to begin with, is often just\n// plain wrong. Instead, when a composition ends, we parse the dom\n// around the original selection, and derive an update from that.\n\nhandlers.compositionstart = function (pm, e) {\n  if (!pm.input.composing && (0, _selection.hasFocus)(pm)) pm.input.startComposition(e.data ? e.data.length : 0, true);\n};\n\nhandlers.compositionupdate = function (pm) {\n  if (!pm.input.composing && (0, _selection.hasFocus)(pm)) pm.input.startComposition(0, false);\n};\n\nhandlers.compositionend = function (pm, e) {\n  if (!(0, _selection.hasFocus)(pm)) return;\n  var composing = pm.input.composing;\n  if (!composing) {\n    // We received a compositionend without having seen any previous\n    // events for the composition. If there's data in the event\n    // object, we assume that it's a real change, and start a\n    // composition. Otherwise, we just ignore it.\n    if (e.data) pm.input.startComposition(e.data.length, false);else return;\n  } else if (composing.applied) {\n    // This happens when a flush during composition causes a\n    // syncronous compositionend.\n    return;\n  }\n\n  clearTimeout(pm.input.finishComposing);\n  pm.operation.composing.ended = true;\n  // Applying the composition right away from this event confuses\n  // Chrome (and probably other browsers), causing them to re-update\n  // the DOM afterwards. So we apply the composition either in the\n  // next input event, or after a short interval.\n  pm.input.finishComposing = window.setTimeout(function () {\n    var composing = pm.input.composing;\n    if (composing && composing.ended) pm.input.applyComposition(true);\n  }, 20);\n};\n\nfunction readInput(pm) {\n  var composing = pm.input.composing;\n  if (composing) {\n    // Ignore input events during composition, except when the\n    // composition has ended, in which case we can apply it.\n    if (composing.ended) pm.input.applyComposition(true);\n    return true;\n  }\n\n  // Read the changed DOM and derive an update from that.\n  var result = (0, _domchange.readInputChange)(pm);\n  pm.flush();\n  return result;\n}\n\nfunction readInputSoon(pm) {\n  window.setTimeout(function () {\n    if (!readInput(pm)) window.setTimeout(function () {\n      return readInput(pm);\n    }, 80);\n  }, 20);\n}\n\nhandlers.input = function (pm) {\n  if ((0, _selection.hasFocus)(pm)) readInput(pm);\n};\n\nfunction toClipboard(doc, from, to, dataTransfer) {\n  var slice = doc.slice(from, to),\n      $from = doc.resolve(from);\n  var parent = $from.node($from.depth - slice.openLeft);\n  var attr = parent.type.name + \" \" + slice.openLeft + \" \" + slice.openRight;\n  var html = \"<div pm-context=\\\"\" + attr + \"\\\">\" + (0, _format.toHTML)(slice.content) + \"</div>\";\n  dataTransfer.clearData();\n  dataTransfer.setData(\"text/html\", html);\n  dataTransfer.setData(\"text/plain\", (0, _format.toText)(slice.content));\n  return slice;\n}\n\nvar cachedCanUpdateClipboard = null;\n\nfunction canUpdateClipboard(dataTransfer) {\n  if (cachedCanUpdateClipboard != null) return cachedCanUpdateClipboard;\n  dataTransfer.setData(\"text/html\", \"<hr>\");\n  return cachedCanUpdateClipboard = dataTransfer.getData(\"text/html\") == \"<hr>\";\n}\n\n// :: (text: string) → string #path=ProseMirror#events#transformPastedText\n// Fired when plain text is pasted. Handlers must return the given\n// string or a [transformed](#EventMixin.signalPipelined) version of\n// it.\n\n// :: (html: string) → string #path=ProseMirror#events#transformPastedHTML\n// Fired when html content is pasted or dragged into the editor.\n// Handlers must return the given string or a\n// [transformed](#EventMixin.signalPipelined) version of it.\n\n// :: (slice: Slice) → Slice #path=ProseMirror#events#transformPasted\n// Fired when something is pasted or dragged into the editor. The\n// given slice represents the pasted content, and your handler can\n// return a modified version to manipulate it before it is inserted\n// into the document.\n\n// : (ProseMirror, DataTransfer, ?bool) → ?Slice\nfunction fromClipboard(pm, dataTransfer, plainText) {\n  var txt = dataTransfer.getData(\"text/plain\");\n  var html = dataTransfer.getData(\"text/html\");\n  if (!html && !txt) return null;\n  var fragment = undefined,\n      slice = undefined;\n  if ((plainText || !html) && txt) {\n    // FIXME provide way not to wrap this in a whole doc / redo text parsing\n    fragment = (0, _format.parseFrom)(pm.schema, pm.signalPipelined(\"transformPastedText\", txt), \"text\").content;\n  } else {\n    var dom = document.createElement(\"div\");\n    dom.innerHTML = pm.signalPipelined(\"transformPastedHTML\", html);\n    var wrap = dom.querySelector(\"[pm-context]\"),\n        context = undefined,\n        contextNodeType = undefined,\n        found = undefined;\n    if (wrap && (context = /^(\\w+) (\\d+) (\\d+)$/.exec(wrap.getAttribute(\"pm-context\"))) && (contextNodeType = pm.schema.nodes[context[1]]) && contextNodeType.defaultAttrs && (found = parseFromContext(wrap, contextNodeType, +context[2], +context[3]))) slice = found;else fragment = (0, _format.fromDOM)(pm.schema, dom, { topNode: false });\n  }\n  if (!slice) {\n    var openLeft = 0,\n        openRight = 0;\n    if (fragment.size) {\n      if (fragment.firstChild.isTextblock) openLeft = 1;\n      if (fragment.lastChild.isTextblock) openRight = 1;\n    }\n    slice = new _model.Slice(fragment, openLeft, openRight);\n  }\n  return pm.signalPipelined(\"transformPasted\", slice);\n}\n\nfunction parseFromContext(dom, contextNodeType, openLeft, openRight) {\n  var schema = contextNodeType.schema,\n      contextNode = contextNodeType.create();\n  var parsed = (0, _format.fromDOM)(schema, dom, { topNode: contextNode, preserveWhitespace: true });\n  return new _model.Slice(parsed.content, clipOpen(parsed.content, openLeft, true), clipOpen(parsed.content, openRight, false), contextNode);\n}\n\nfunction clipOpen(fragment, max, start) {\n  for (var i = 0; i < max; i++) {\n    var node = start ? fragment.firstChild : fragment.lastChild;\n    if (!node || node.type.isLeaf) return i;\n    fragment = node.content;\n  }\n  return max;\n}\n\nhandlers.copy = handlers.cut = function (pm, e) {\n  var _pm$selection2 = pm.selection;\n  var from = _pm$selection2.from;\n  var to = _pm$selection2.to;\n  var empty = _pm$selection2.empty;var cut = e.type == \"cut\";\n  if (empty) return;\n  if (!e.clipboardData || !canUpdateClipboard(e.clipboardData)) {\n    if (cut && _dom.browser.ie && _dom.browser.ie_version <= 11) readInputSoon(pm);\n    return;\n  }\n  toClipboard(pm.doc, from, to, e.clipboardData);\n  e.preventDefault();\n  if (cut) pm.tr.delete(from, to).apply();\n};\n\nhandlers.paste = function (pm, e) {\n  if (!(0, _selection.hasFocus)(pm)) return;\n  if (!e.clipboardData) {\n    if (_dom.browser.ie && _dom.browser.ie_version <= 11) readInputSoon(pm);\n    return;\n  }\n  var sel = pm.selection;\n  var slice = fromClipboard(pm, e.clipboardData, pm.input.shiftKey);\n  if (slice) {\n    e.preventDefault();\n    var tr = pm.tr.replace(sel.from, sel.to, slice);\n    tr.apply({ scrollIntoView: true, selection: (0, _selection.findSelectionNear)(tr.doc, tr.map(sel.to)) });\n  }\n};\n\nvar Dragging = function Dragging(slice, from, to) {\n  _classCallCheck(this, Dragging);\n\n  this.slice = slice;\n  this.from = from;\n  this.to = to;\n};\n\nfunction dropPos(pm, e, slice) {\n  var pos = pm.posAtCoords({ left: e.clientX, top: e.clientY });\n  if (pos == null || !slice || !slice.content.size) return pos;\n  var $pos = pm.doc.resolve(pos);\n  for (var d = $pos.depth; d >= 0; d--) {\n    var bias = d == $pos.depth ? 0 : pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n    var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n    if ($pos.node(d).canReplace(insertPos, insertPos, slice.content)) return bias == 0 ? pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n  }\n  return pos;\n}\n\nfunction removeDropTarget(pm) {\n  if (pm.input.dropTarget) {\n    pm.wrapper.removeChild(pm.input.dropTarget);\n    pm.input.dropTarget = null;\n  }\n}\n\nhandlers.dragstart = function (pm, e) {\n  var mouseDown = pm.input.mouseDown;\n  if (mouseDown) mouseDown.done();\n\n  if (!e.dataTransfer) return;\n\n  var _pm$selection3 = pm.selection;\n  var from = _pm$selection3.from;\n  var to = _pm$selection3.to;\n  var empty = _pm$selection3.empty;var dragging = undefined;\n  var pos = !empty && pm.posAtCoords({ left: e.clientX, top: e.clientY });\n  if (pos != null && pos >= from && pos <= to) {\n    dragging = { from: from, to: to };\n  } else if (mouseDown && mouseDown.mightDrag != null) {\n    var _pos = mouseDown.mightDrag;\n    dragging = { from: _pos, to: _pos + pm.doc.nodeAt(_pos).nodeSize };\n  }\n\n  if (dragging) {\n    var slice = toClipboard(pm.doc, dragging.from, dragging.to, e.dataTransfer);\n    // FIXME the document could change during a drag, invalidating this range\n    // use a marked range?\n    pm.input.dragging = new Dragging(slice, dragging.from, dragging.to);\n  }\n};\n\nhandlers.dragend = function (pm) {\n  removeDropTarget(pm);\n  window.setTimeout(function () {\n    return pm.input.dragging = null;\n  }, 50);\n};\n\nhandlers.dragover = handlers.dragenter = function (pm, e) {\n  e.preventDefault();\n\n  var target = pm.input.dropTarget;\n  if (!target) target = pm.input.dropTarget = pm.wrapper.appendChild((0, _dom.elt)(\"div\", { class: \"ProseMirror-drop-target\" }));\n\n  var pos = dropPos(pm, e, pm.input.dragging && pm.input.dragging.slice);\n  if (pos == null) return;\n  var coords = pm.coordsAtPos(pos);\n  var rect = pm.wrapper.getBoundingClientRect();\n  coords.top -= rect.top;\n  coords.right -= rect.left;\n  coords.bottom -= rect.top;\n  coords.left -= rect.left;\n  target.style.left = coords.left - 1 + \"px\";\n  target.style.top = coords.top + \"px\";\n  target.style.height = coords.bottom - coords.top + \"px\";\n};\n\nhandlers.dragleave = function (pm, e) {\n  if (e.target == pm.content) removeDropTarget(pm);\n};\n\nhandlers.drop = function (pm, e) {\n  var dragging = pm.input.dragging;\n  pm.input.dragging = null;\n  removeDropTarget(pm);\n\n  // :: (event: DOMEvent) #path=ProseMirror#events#drop\n  // Fired when a drop event occurs on the editor content. A handler\n  // may declare the event handled by calling `preventDefault` on it\n  // or returning a truthy value.\n  if (!e.dataTransfer || pm.signalDOM(e)) return;\n\n  var slice = dragging && dragging.slice || fromClipboard(pm, e.dataTransfer);\n  if (slice) {\n    e.preventDefault();\n    var insertPos = dropPos(pm, e, slice),\n        start = insertPos;\n    if (insertPos == null) return;\n    var tr = pm.tr;\n    if (dragging && !e.ctrlKey && dragging.from != null) {\n      tr.delete(dragging.from, dragging.to);\n      insertPos = tr.map(insertPos);\n    }\n    tr.replace(insertPos, insertPos, slice).apply();\n    var found = undefined;\n    if (slice.content.childCount == 1 && slice.openLeft == 0 && slice.openRight == 0 && slice.content.child(0).type.selectable && (found = pm.doc.nodeAt(insertPos)) && found.sameMarkup(slice.content.child(0))) {\n      pm.setNodeSelection(insertPos);\n    } else {\n      var left = (0, _selection.findSelectionNear)(pm.doc, insertPos, 1, true).from;\n      var right = (0, _selection.findSelectionNear)(pm.doc, tr.map(start), -1, true).to;\n      pm.setTextSelection(left, right);\n    }\n    pm.focus();\n  }\n};\n\nhandlers.focus = function (pm) {\n  pm.wrapper.classList.add(\"ProseMirror-focused\");\n  // :: () #path=ProseMirror#events#focus\n  // Fired when the editor gains focus.\n  pm.signal(\"focus\");\n};\n\nhandlers.blur = function (pm) {\n  pm.wrapper.classList.remove(\"ProseMirror-focused\");\n  // :: () #path=ProseMirror#events#blur\n  // Fired when the editor loses focus.\n  pm.signal(\"blur\");\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/input.js\n ** module id = 52\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/input.js?");

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.captureKeys = undefined;\n\nvar _browserkeymap = __webpack_require__(11);\n\nvar _browserkeymap2 = _interopRequireDefault(_browserkeymap);\n\nvar _selection = __webpack_require__(49);\n\nvar _dom = __webpack_require__(10);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction nothing() {}\n\nfunction moveSelectionBlock(pm, dir) {\n  var _pm$selection = pm.selection;\n  var from = _pm$selection.from;\n  var to = _pm$selection.to;\n  var node = _pm$selection.node;\n\n  var side = pm.doc.resolve(dir > 0 ? to : from);\n  return (0, _selection.findSelectionFrom)(pm.doc, node && node.isBlock ? side.pos : dir > 0 ? side.after(side.depth) : side.before(side.depth), dir);\n}\n\nfunction selectNodeHorizontally(pm, dir) {\n  var _pm$selection2 = pm.selection;\n  var empty = _pm$selection2.empty;\n  var node = _pm$selection2.node;\n  var from = _pm$selection2.from;\n  var to = _pm$selection2.to;\n\n  if (!empty && !node) return false;\n\n  if (node && node.isInline) {\n    pm.setTextSelection(dir > 0 ? to : from);\n    return true;\n  }\n\n  if (!node) {\n    var $from = pm.doc.resolve(from);\n\n    var _ref = dir > 0 ? $from.parent.childAfter($from.parentOffset) : $from.parent.childBefore($from.parentOffset);\n\n    var nextNode = _ref.node;\n    var offset = _ref.offset;\n\n    if (nextNode) {\n      if (nextNode.type.selectable && offset == $from.parentOffset - (dir > 0 ? 0 : nextNode.nodeSize)) {\n        pm.setNodeSelection(dir < 0 ? from - nextNode.nodeSize : from);\n        return true;\n      }\n      return false;\n    }\n  }\n\n  var next = moveSelectionBlock(pm, dir);\n  if (next && (next instanceof _selection.NodeSelection || node)) {\n    pm.setSelection(next);\n    return true;\n  }\n  return false;\n}\n\nfunction horiz(dir) {\n  return function (pm) {\n    var done = selectNodeHorizontally(pm, dir);\n    if (done) pm.scrollIntoView();\n    return done;\n  };\n}\n\n// : (ProseMirror, number)\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectNodeVertically(pm, dir) {\n  var _pm$selection3 = pm.selection;\n  var empty = _pm$selection3.empty;\n  var node = _pm$selection3.node;\n  var from = _pm$selection3.from;\n  var to = _pm$selection3.to;\n\n  if (!empty && !node) return false;\n\n  var leavingTextblock = true;\n  if (!node || node.isInline) {\n    pm.flush(); // verticalMotionLeavesTextblock needs an up-to-date DOM\n    leavingTextblock = (0, _selection.verticalMotionLeavesTextblock)(pm, dir > 0 ? to : from, dir);\n  }\n\n  if (leavingTextblock) {\n    var next = moveSelectionBlock(pm, dir);\n    if (next && next instanceof _selection.NodeSelection) {\n      pm.setSelection(next);\n      return true;\n    }\n  }\n\n  if (!node || node.isInline) return false;\n\n  var beyond = (0, _selection.findSelectionFrom)(pm.doc, dir < 0 ? from : to, dir);\n  if (beyond) pm.setSelection(beyond);\n  return true;\n}\n\nfunction vert(dir) {\n  return function (pm) {\n    var done = selectNodeVertically(pm, dir);\n    if (done !== false) pm.scrollIntoView();\n    return done;\n  };\n}\n\n// A backdrop keymap used to make sure we always suppress keys that\n// have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\n\nvar keys = {\n  \"Esc\": nothing,\n  \"Enter\": nothing,\n  \"Ctrl-Enter\": nothing,\n  \"Mod-Enter\": nothing,\n  \"Shift-Enter\": nothing,\n  \"Backspace\": _dom.browser.ios ? undefined : nothing,\n  \"Delete\": nothing,\n  \"Mod-B\": nothing,\n  \"Mod-I\": nothing,\n  \"Mod-Backspace\": nothing,\n  \"Mod-Delete\": nothing,\n  \"Shift-Backspace\": nothing,\n  \"Shift-Delete\": nothing,\n  \"Shift-Mod-Backspace\": nothing,\n  \"Shift-Mod-Delete\": nothing,\n  \"Mod-Z\": nothing,\n  \"Mod-Y\": nothing,\n  \"Shift-Mod-Z\": nothing,\n  \"Ctrl-D\": nothing,\n  \"Ctrl-H\": nothing,\n  \"Ctrl-Alt-Backspace\": nothing,\n  \"Alt-D\": nothing,\n  \"Alt-Delete\": nothing,\n  \"Alt-Backspace\": nothing,\n\n  \"Left\": horiz(-1),\n  \"Mod-Left\": horiz(-1),\n  \"Right\": horiz(1),\n  \"Mod-Right\": horiz(1),\n  \"Up\": vert(-1),\n  \"Down\": vert(1)\n};\n\nif (_dom.browser.mac) {\n  keys[\"Alt-Left\"] = horiz(-1);\n  keys[\"Alt-Right\"] = horiz(1);\n  keys[\"Ctrl-Backspace\"] = keys[\"Ctrl-Delete\"] = nothing;\n}\n\nvar captureKeys = exports.captureKeys = new _browserkeymap2.default(keys);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/capturekeys.js\n ** module id = 53\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/capturekeys.js?");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readInputChange = readInputChange;\nexports.readCompositionChange = readCompositionChange;\n\nvar _model = __webpack_require__(18);\n\nvar _format = __webpack_require__(15);\n\nvar _map = __webpack_require__(40);\n\nvar _selection = __webpack_require__(49);\n\nvar _dompos = __webpack_require__(50);\n\nfunction readInputChange(pm) {\n  pm.ensureOperation({ readSelection: false });\n  return readDOMChange(pm, rangeAroundSelection(pm));\n}\n\nfunction readCompositionChange(pm, margin) {\n  return readDOMChange(pm, rangeAroundComposition(pm, margin));\n}\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\n\nfunction parseBetween(pm, from, to) {\n  var _DOMFromPos = (0, _dompos.DOMFromPos)(pm, from, true);\n\n  var parent = _DOMFromPos.node;\n  var startOff = _DOMFromPos.offset;\n\n  var endOff = (0, _dompos.DOMFromPos)(pm, to, true).offset;\n  while (startOff) {\n    var prev = parent.childNodes[startOff - 1];\n    if (prev.nodeType != 1 || !prev.hasAttribute(\"pm-offset\")) --startOff;else break;\n  }\n  while (endOff < parent.childNodes.length) {\n    var next = parent.childNodes[endOff];\n    if (next.nodeType != 1 || !next.hasAttribute(\"pm-offset\")) ++endOff;else break;\n  }\n  return (0, _format.fromDOM)(pm.schema, parent, {\n    topNode: pm.doc.resolve(from).parent.copy(),\n    from: startOff,\n    to: endOff,\n    preserveWhitespace: true,\n    editableContent: true\n  });\n}\n\nfunction isAtEnd($pos, depth) {\n  for (var i = depth || 0; i < $pos.depth; i++) {\n    if ($pos.index(i) + 1 < $pos.node(i).childCount) return false;\n  }return $pos.parentOffset == $pos.parent.content.size;\n}\nfunction isAtStart($pos, depth) {\n  for (var i = depth || 0; i < $pos.depth; i++) {\n    if ($pos.index(0) > 0) return false;\n  }return $pos.parentOffset == 0;\n}\n\nfunction rangeAroundSelection(pm) {\n  var _pm$operation = pm.operation;\n  var sel = _pm$operation.sel;\n  var doc = _pm$operation.doc;var $from = doc.resolve(sel.from);var $to = doc.resolve(sel.to);\n  // When the selection is entirely inside a text block, use\n  // rangeAroundComposition to get a narrow range.\n  if ($from.sameParent($to) && $from.parent.isTextblock && $from.parentOffset && $to.parentOffset < $to.parent.content.size) return rangeAroundComposition(pm, 0);\n\n  for (var depth = 0;; depth++) {\n    var fromStart = isAtStart($from, depth + 1),\n        toEnd = isAtEnd($to, depth + 1);\n    if (fromStart || toEnd || $from.index(depth) != $to.index(depth) || $to.node(depth).isTextblock) {\n      var from = $from.before(depth + 1),\n          to = $to.after(depth + 1);\n      if (fromStart && $from.index(depth) > 0) from -= $from.node(depth).child($from.index(depth) - 1).nodeSize;\n      if (toEnd && $to.index(depth) + 1 < $to.node(depth).childCount) to += $to.node(depth).child($to.index(depth) + 1).nodeSize;\n      return { from: from, to: to };\n    }\n  }\n}\n\nfunction rangeAroundComposition(pm, margin) {\n  var _pm$operation2 = pm.operation;\n  var sel = _pm$operation2.sel;\n  var doc = _pm$operation2.doc;\n\n  var $from = doc.resolve(sel.from),\n      $to = doc.resolve(sel.to);\n  if (!$from.sameParent($to)) return rangeAroundSelection(pm);\n  var startOff = Math.max(0, $from.parentOffset - margin);\n  var size = $from.parent.content.size;\n  var endOff = Math.min(size, $to.parentOffset + margin);\n\n  if (startOff > 0) startOff = $from.parent.childBefore(startOff).offset;\n  if (endOff < size) {\n    var after = $from.parent.childAfter(endOff);\n    endOff = after.offset + after.node.nodeSize;\n  }\n  var nodeStart = $from.start();\n  return { from: nodeStart + startOff, to: nodeStart + endOff };\n}\n\nfunction readDOMChange(pm, range) {\n  var op = pm.operation;\n  // If the document was reset since the start of the current\n  // operation, we can't do anything useful with the change to the\n  // DOM, so we discard it.\n  if (op.docSet) {\n    pm.markAllDirty();\n    return false;\n  }\n\n  var parsed = parseBetween(pm, range.from, range.to);\n  var compare = op.doc.slice(range.from, range.to);\n  var change = findDiff(compare.content, parsed.content, range.from, op.sel.from);\n  if (!change) return false;\n  var fromMapped = (0, _map.mapThroughResult)(op.mappings, change.start);\n  var toMapped = (0, _map.mapThroughResult)(op.mappings, change.endA);\n  if (fromMapped.deleted && toMapped.deleted) return false;\n\n  // Mark nodes touched by this change as 'to be redrawn'\n  markDirtyFor(pm, op.doc, change.start, change.endA);\n\n  var $from = parsed.resolveNoCache(change.start - range.from);\n  var $to = parsed.resolveNoCache(change.endB - range.from),\n      nextSel = undefined,\n      text = undefined;\n  // If this looks like the effect of pressing Enter, just dispatch an\n  // Enter key instead.\n  if (!$from.sameParent($to) && $from.pos < parsed.content.size && (nextSel = (0, _selection.findSelectionFrom)(parsed, $from.pos + 1, 1, true)) && nextSel.head == $to.pos) {\n    pm.input.dispatchKey(\"Enter\");\n  } else if ($from.sameParent($to) && $from.parent.isTextblock && (text = uniformTextBetween(parsed, $from.pos, $to.pos)) != null) {\n    pm.input.insertText(fromMapped.pos, toMapped.pos, text, function (doc) {\n      return domSel(pm, doc);\n    });\n  } else {\n    var slice = parsed.slice(change.start - range.from, change.endB - range.from);\n    var tr = pm.tr.replace(fromMapped.pos, toMapped.pos, slice);\n    tr.apply({\n      scrollIntoView: true,\n      selection: domSel(pm, tr.doc)\n    });\n  }\n  return true;\n}\n\nfunction domSel(pm, doc) {\n  if (pm.hasFocus()) return (0, _selection.selectionFromDOM)(pm, doc, null, true).range;\n}\n\nfunction uniformTextBetween(node, from, to) {\n  var result = \"\",\n      valid = true,\n      marks = null;\n  node.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline && pos < from) return;\n    if (!node.isText) return valid = false;\n    if (!marks) marks = node.marks;else if (!_model.Mark.sameSet(marks, node.marks)) valid = false;\n    result += node.text.slice(Math.max(0, from - pos), to - pos);\n  });\n  return valid ? result : null;\n}\n\nfunction findDiff(a, b, pos, preferedStart) {\n  var start = (0, _model.findDiffStart)(a, b, pos);\n  if (!start) return null;\n\n  var _findDiffEnd = (0, _model.findDiffEnd)(a, b, pos + a.size, pos + b.size);\n\n  var endA = _findDiffEnd.a;\n  var endB = _findDiffEnd.b;\n\n  if (endA < start) {\n    var move = preferedStart <= start && preferedStart >= endA ? start - preferedStart : 0;\n    start -= move;\n    endB = start + (endB - endA);\n    endA = start;\n  } else if (endB < start) {\n    var move = preferedStart <= start && preferedStart >= endB ? start - preferedStart : 0;\n    start -= move;\n    endA = start + (endA - endB);\n    endB = start;\n  }\n  return { start: start, endA: endA, endB: endB };\n}\n\nfunction markDirtyFor(pm, doc, start, end) {\n  var $start = doc.resolve(start),\n      $end = doc.resolve(end),\n      same = $start.sameDepth($end);\n  if (same == 0) pm.markAllDirty();else pm.markRangeDirty($start.before(same), $start.after(same), doc);\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/domchange.js\n ** module id = 54\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/domchange.js?");

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.History = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _transform = __webpack_require__(38);\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ProseMirror's history implements not a way to roll back to a\n// previous state, because ProseMirror supports applying changes\n// without adding them to the history (for example during\n// collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection token field is the\n// start of an 'event' -- a group of changes that will be undone or\n// redone at once. (It stores only a token, since that way we don't\n// have to provide a document until the selection is actually applied,\n// which is useful when compressing.)\n\n// Used to schedule history compression\nvar max_empty_items = 500;\n\nvar Branch = function () {\n  function Branch(maxEvents) {\n    _classCallCheck(this, Branch);\n\n    this.events = 0;\n    this.maxEvents = maxEvents;\n    // Item 0 is always a dummy that's only used to have an id to\n    // refer to at the start of the history.\n    this.items = [new Item()];\n  }\n\n  // : (Node, bool, ?Item) → ?{transform: Transform, selection: SelectionToken, ids: [number]}\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform, returning the transform and the step IDs.\n\n\n  _createClass(Branch, [{\n    key: \"popEvent\",\n    value: function popEvent(doc, preserveItems, upto) {\n      var preserve = preserveItems,\n          transform = new _transform.Transform(doc);\n      var remap = new BranchRemapping();\n      var selection = undefined,\n          ids = [],\n          i = this.items.length;\n\n      for (;;) {\n        var cur = this.items[--i];\n        if (upto && cur == upto) break;\n        if (!cur.map) return null;\n\n        if (!cur.step) {\n          remap.add(cur);\n          preserve = true;\n          continue;\n        }\n\n        if (preserve) {\n          var step = cur.step.map(remap.remap),\n              map = undefined;\n\n          this.items[i] = new MapItem(cur.map);\n          if (step && transform.maybeStep(step).doc) {\n            map = transform.maps[transform.maps.length - 1];\n            this.items.push(new MapItem(map, this.items[i].id));\n          }\n          remap.movePastStep(cur, map);\n        } else {\n          this.items.pop();\n          transform.maybeStep(cur.step);\n        }\n\n        ids.push(cur.id);\n        if (cur.selection) {\n          this.events--;\n          if (!upto) {\n            selection = cur.selection.type.mapToken(cur.selection, remap.remap);\n            break;\n          }\n        }\n      }\n\n      return { transform: transform, selection: selection, ids: ids };\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.items.length = 1;\n      this.events = 0;\n    }\n\n    // : (Transform, Selection, ?[number])\n    // Create a new branch with the given transform added.\n\n  }, {\n    key: \"addTransform\",\n    value: function addTransform(transform, selection, ids) {\n      for (var i = 0; i < transform.steps.length; i++) {\n        var step = transform.steps[i].invert(transform.docs[i]);\n        this.items.push(new StepItem(transform.maps[i], ids && ids[i], step, selection));\n        if (selection) {\n          this.events++;\n          selection = null;\n        }\n      }\n      if (this.events > this.maxEvents) this.clip();\n    }\n\n    // Clip this branch to the max number of events.\n\n  }, {\n    key: \"clip\",\n    value: function clip() {\n      var seen = 0,\n          toClip = this.events - this.maxEvents;\n      for (var i = 0;; i++) {\n        var cur = this.items[i];\n        if (cur.selection) {\n          if (seen < toClip) {\n            ++seen;\n          } else {\n            this.items.splice(0, i, new Item(null, this.events[toClip - 1]));\n            this.events = this.maxEvents;\n            return;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"addMaps\",\n    value: function addMaps(array) {\n      if (this.events == 0) return;\n      for (var i = 0; i < array.length; i++) {\n        this.items.push(new MapItem(array[i]));\n      }\n    }\n  }, {\n    key: \"findChangeID\",\n    value: function findChangeID(id) {\n      if (id == this.items[0].id) return this.items[0];\n\n      for (var i = this.items.length - 1; i >= 0; i--) {\n        var cur = this.items[i];\n        if (cur.step) {\n          if (cur.id == id) return cur;\n          if (cur.id < id) return null;\n        }\n      }\n    }\n\n    // : ([PosMap], Transform, [number])\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n\n  }, {\n    key: \"rebased\",\n    value: function rebased(newMaps, rebasedTransform, positions) {\n      if (this.events == 0) return;\n\n      var rebasedItems = [],\n          start = this.items.length - positions.length,\n          startPos = 0;\n      if (start < 1) {\n        startPos = 1 - start;\n        start = 1;\n        this.items[0] = new Item();\n      }\n\n      if (positions.length) {\n        var remap = new _transform.Remapping([], newMaps.slice());\n        for (var iItem = start, iPosition = startPos; iItem < this.items.length; iItem++) {\n          var item = this.items[iItem],\n              pos = positions[iPosition++],\n              id = undefined;\n          if (pos != -1) {\n            var map = rebasedTransform.maps[pos];\n            if (item.step) {\n              var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n              var selection = item.selection && item.selection.type.mapToken(item.selection, remap);\n              rebasedItems.push(new StepItem(map, item.id, step, selection));\n            } else {\n              rebasedItems.push(new MapItem(map));\n            }\n            id = remap.addToBack(map);\n          }\n          remap.addToFront(item.map.invert(), id);\n        }\n\n        this.items.length = start;\n      }\n\n      for (var i = 0; i < newMaps.length; i++) {\n        this.items.push(new MapItem(newMaps[i]));\n      }for (var i = 0; i < rebasedItems.length; i++) {\n        this.items.push(rebasedItems[i]);\n      }if (!this.compressing && this.emptyItems(start) + newMaps.length > max_empty_items) this.compress(start + newMaps.length);\n    }\n  }, {\n    key: \"emptyItems\",\n    value: function emptyItems(upto) {\n      var count = 0;\n      for (var i = 1; i < upto; i++) {\n        if (!this.items[i].step) count++;\n      }return count;\n    }\n\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old ids to rebased steps.\n\n  }, {\n    key: \"compress\",\n    value: function compress(upto) {\n      var remap = new BranchRemapping();\n      var items = [],\n          events = 0;\n      for (var i = this.items.length - 1; i >= 0; i--) {\n        var item = this.items[i];\n        if (i >= upto) {\n          items.push(item);\n        } else if (item.step) {\n          var step = item.step.map(remap.remap),\n              map = step && step.posMap();\n          remap.movePastStep(item, map);\n          if (step) {\n            var selection = item.selection && item.selection.type.mapToken(item.selection, remap.remap);\n            items.push(new StepItem(map.invert(), item.id, step, selection));\n            if (selection) events++;\n          }\n        } else if (item.map) {\n          remap.add(item);\n        } else {\n          items.push(item);\n        }\n      }\n      this.items = items.reverse();\n      this.events = events;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.items.join(\"\\n\");\n    }\n  }, {\n    key: \"changeID\",\n    get: function get() {\n      for (var i = this.items.length - 1; i > 0; i--) {\n        if (this.items[i].step) return this.items[i].id;\n      }return this.items[0].id;\n    }\n  }]);\n\n  return Branch;\n}();\n\n// History items all have ids, but the meaning of these is somewhat\n// complicated.\n//\n// - For StepItems, the ids are kept ordered (inside a given branch),\n//   and are kept associated with a given change (if you undo and then\n//   redo it, the resulting item gets the old id)\n//\n// - For MapItems, the ids are just opaque identifiers, not\n//   necessarily ordered.\n//\n// - The placeholder item at the base of a branch's list\n\n\nvar nextID = 1;\n\nvar Item = function () {\n  function Item(map, id) {\n    _classCallCheck(this, Item);\n\n    this.map = map;\n    this.id = id || nextID++;\n  }\n\n  _createClass(Item, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.id + \":\" + (this.map || \"\") + (this.step ? \":\" + this.step : \"\") + (this.mirror != null ? \"->\" + this.mirror : \"\");\n    }\n  }]);\n\n  return Item;\n}();\n\nvar StepItem = function (_Item) {\n  _inherits(StepItem, _Item);\n\n  function StepItem(map, id, step, selection) {\n    _classCallCheck(this, StepItem);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(StepItem).call(this, map, id));\n\n    _this.step = step;\n    _this.selection = selection;\n    return _this;\n  }\n\n  return StepItem;\n}(Item);\n\nvar MapItem = function (_Item2) {\n  _inherits(MapItem, _Item2);\n\n  function MapItem(map, mirror) {\n    _classCallCheck(this, MapItem);\n\n    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(MapItem).call(this, map));\n\n    _this2.mirror = mirror;\n    return _this2;\n  }\n\n  return MapItem;\n}(Item);\n\n// Assists with remapping a step with other changes that have been\n// made since the step was first applied.\n\n\nvar BranchRemapping = function () {\n  function BranchRemapping() {\n    _classCallCheck(this, BranchRemapping);\n\n    this.remap = new _transform.Remapping();\n    this.mirrorBuffer = Object.create(null);\n  }\n\n  _createClass(BranchRemapping, [{\n    key: \"add\",\n    value: function add(item) {\n      var id = this.remap.addToFront(item.map, this.mirrorBuffer[item.id]);\n      if (item.mirror != null) this.mirrorBuffer[item.mirror] = id;\n      return id;\n    }\n  }, {\n    key: \"movePastStep\",\n    value: function movePastStep(item, map) {\n      var id = this.add(item);\n      if (map) this.remap.addToBack(map, id);\n    }\n  }]);\n\n  return BranchRemapping;\n}();\n\n// ;; An undo/redo history manager for an editor instance.\n\n\nvar History = exports.History = function () {\n  function History(pm) {\n    _classCallCheck(this, History);\n\n    this.pm = pm;\n\n    this.done = new Branch(pm.options.historyDepth);\n    this.undone = new Branch(pm.options.historyDepth);\n\n    this.lastAddedAt = 0;\n    this.ignoreTransform = false;\n    this.preserveItems = 0;\n\n    pm.on(\"transform\", this.recordTransform.bind(this));\n  }\n\n  // : (Transform, Selection, Object)\n  // Record a transformation in undo history.\n\n\n  _createClass(History, [{\n    key: \"recordTransform\",\n    value: function recordTransform(transform, selection, options) {\n      if (this.ignoreTransform) return;\n\n      if (options.addToHistory == false) {\n        this.done.addMaps(transform.maps);\n        this.undone.addMaps(transform.maps);\n      } else {\n        var now = Date.now();\n        // Group transforms that occur in quick succession into one event.\n        var newGroup = now > this.lastAddedAt + this.pm.options.historyEventDelay;\n        this.done.addTransform(transform, newGroup ? selection.token : null);\n        this.undone.clear();\n        this.lastAddedAt = now;\n      }\n    }\n\n    // :: () → bool\n    // Undo one history event. The return value indicates whether\n    // anything was actually undone. Note that in a collaborative\n    // context, or when changes are [applied](#ProseMirror.apply)\n    // without adding them to the history, it is possible for\n    // [`undoDepth`](#History.undoDepth) to have a positive value, but\n    // this method to still return `false`, when non-history changes\n    // overwrote all remaining changes in the history.\n\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      return this.shift(this.done, this.undone);\n    }\n\n    // :: () → bool\n    // Redo one history event. The return value indicates whether\n    // anything was actually redone.\n\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      return this.shift(this.undone, this.done);\n    }\n\n    // :: number\n    // The amount of undoable events available.\n\n  }, {\n    key: \"shift\",\n\n\n    // : (Branch, Branch) → bool\n    // Apply the latest event from one branch to the document and optionally\n    // shift the event onto the other branch. Returns true when an event could\n    // be shifted.\n    value: function shift(from, to) {\n      var pop = from.popEvent(this.pm.doc, this.preserveItems > 0);\n      if (!pop) return false;\n      var selectionBeforeTransform = this.pm.selection;\n\n      if (!pop.transform.steps.length) return this.shift(from, to);\n\n      var selection = pop.selection.type.fromToken(pop.selection, pop.transform.doc);\n      this.applyIgnoring(pop.transform, selection);\n\n      // Store the selection before transform on the event so that\n      // it can be reapplied if the event is undone or redone (e.g.\n      // redoing a character addition should place the cursor after\n      // the character).\n      to.addTransform(pop.transform, selectionBeforeTransform.token, pop.ids);\n\n      this.lastAddedAt = 0;\n\n      return true;\n    }\n  }, {\n    key: \"applyIgnoring\",\n    value: function applyIgnoring(transform, selection) {\n      this.ignoreTransform = true;\n      this.pm.apply(transform, { selection: selection, filter: false });\n      this.ignoreTransform = false;\n    }\n\n    // :: () → Object\n    // Get the current ‘version’ of the editor content. This can be used\n    // to later [check](#History.isAtVersion) whether anything changed, or\n    // to [roll back](#History.backToVersion) to this version.\n\n  }, {\n    key: \"getVersion\",\n    value: function getVersion() {\n      return this.done.changeID;\n    }\n\n    // :: (Object) → bool\n    // Returns `true` when the editor history is in the state that it\n    // was when the given [version](#History.getVersion) was recorded.\n    // That means either no changes were made, or changes were\n    // done/undone and then undone/redone again.\n\n  }, {\n    key: \"isAtVersion\",\n    value: function isAtVersion(version) {\n      return this.done.changeID == version;\n    }\n\n    // :: (Object) → bool\n    // Rolls back all changes made since the given\n    // [version](#History.getVersion) was recorded. Returns `false` if\n    // that version was no longer found in the history, and thus the\n    // action could not be completed.\n\n  }, {\n    key: \"backToVersion\",\n    value: function backToVersion(version) {\n      var found = this.done.findChangeID(version);\n      if (!found) return false;\n\n      var _done$popEvent = this.done.popEvent(this.pm.doc, this.preserveItems > 0, found);\n\n      var transform = _done$popEvent.transform;\n\n      this.applyIgnoring(transform);\n      this.undone.clear();\n      return true;\n    }\n\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n\n  }, {\n    key: \"rebased\",\n    value: function rebased(newMaps, rebasedTransform, positions) {\n      this.done.rebased(newMaps, rebasedTransform, positions);\n      this.undone.rebased(newMaps, rebasedTransform, positions);\n    }\n  }, {\n    key: \"undoDepth\",\n    get: function get() {\n      return this.done.events;\n    }\n\n    // :: number\n    // The amount of redoable events available.\n\n  }, {\n    key: \"redoDepth\",\n    get: function get() {\n      return this.undone.events;\n    }\n  }]);\n\n  return History;\n}();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/history.js\n ** module id = 55\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/history.js?");

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RangeStore = exports.MarkedRange = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _event = __webpack_require__(14);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ;; A [marked range](#ProseMirror.markRange). Includes the methods\n// from the [event mixin](#EventMixin).\n\nvar MarkedRange = exports.MarkedRange = function () {\n  function MarkedRange(from, to, options) {\n    _classCallCheck(this, MarkedRange);\n\n    this.options = options || {};\n    // :: ?number\n    // The current start position of the range. Updated whenever the\n    // editor's document is changed. Set to `null` when the marked\n    // range is [removed](#ProseMirror.removeRange).\n    this.from = from;\n    // :: ?number\n    // The current end position of the range. Updated whenever the\n    // editor's document is changed. Set to `null` when the marked\n    // range is [removed](#ProseMirror.removeRange).\n    this.to = to;\n  }\n\n  _createClass(MarkedRange, [{\n    key: \"remove\",\n    value: function remove() {\n      // :: (from: number, to: number) #path=MarkedRange#events#removed\n      // Signalled when the marked range is removed from the editor.\n      this.signal(\"removed\", this.from, Math.max(this.to, this.from));\n      this.from = this.to = null;\n    }\n  }]);\n\n  return MarkedRange;\n}();\n\n(0, _event.eventMixin)(MarkedRange);\n\nvar RangeSorter = function () {\n  function RangeSorter() {\n    _classCallCheck(this, RangeSorter);\n\n    this.sorted = [];\n  }\n\n  _createClass(RangeSorter, [{\n    key: \"find\",\n    value: function find(at) {\n      var min = 0,\n          max = this.sorted.length;\n      for (;;) {\n        if (max < min + 10) {\n          for (var i = min; i < max; i++) {\n            if (this.sorted[i].at >= at) return i;\n          }return max;\n        }\n        var mid = min + max >> 1;\n        if (this.sorted[mid].at > at) max = mid;else min = mid;\n      }\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(obj) {\n      this.sorted.splice(this.find(obj.at), 0, obj);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(at, range) {\n      var pos = this.find(at);\n      for (var dist = 0;; dist++) {\n        var leftPos = pos - dist - 1,\n            rightPos = pos + dist;\n        if (leftPos >= 0 && this.sorted[leftPos].range == range) {\n          this.sorted.splice(leftPos, 1);\n          return;\n        } else if (rightPos < this.sorted.length && this.sorted[rightPos].range == range) {\n          this.sorted.splice(rightPos, 1);\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"resort\",\n    value: function resort() {\n      for (var i = 0; i < this.sorted.length; i++) {\n        var cur = this.sorted[i];\n        var at = cur.at = cur.type == \"open\" ? cur.range.from : cur.range.to;\n        var pos = i;\n        while (pos > 0 && this.sorted[pos - 1].at > at) {\n          this.sorted[pos] = this.sorted[pos - 1];\n          this.sorted[--pos] = cur;\n        }\n      }\n    }\n  }]);\n\n  return RangeSorter;\n}();\n\nvar RangeStore = exports.RangeStore = function () {\n  function RangeStore(pm) {\n    _classCallCheck(this, RangeStore);\n\n    this.pm = pm;\n    this.ranges = [];\n    this.sorted = new RangeSorter();\n  }\n\n  _createClass(RangeStore, [{\n    key: \"addRange\",\n    value: function addRange(range) {\n      this.ranges.push(range);\n      this.sorted.insert({ type: \"open\", at: range.from, range: range });\n      this.sorted.insert({ type: \"close\", at: range.to, range: range });\n      if (range.options.className) this.pm.markRangeDirty(range.from, range.to);\n    }\n  }, {\n    key: \"removeRange\",\n    value: function removeRange(range) {\n      var found = this.ranges.indexOf(range);\n      if (found > -1) {\n        this.ranges.splice(found, 1);\n        this.sorted.remove(range.from, range);\n        this.sorted.remove(range.to, range);\n        if (range.options.className) this.pm.markRangeDirty(range.from, range.to);\n        range.remove();\n      }\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(mapping) {\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        range.from = mapping.map(range.from, range.options.inclusiveLeft ? -1 : 1);\n        range.to = mapping.map(range.to, range.options.inclusiveRight ? 1 : -1);\n        if (range.options.removeWhenEmpty !== false && range.from >= range.to) {\n          this.removeRange(range);\n          i--;\n        } else if (range.from > range.to) {\n          range.to = range.from;\n        }\n      }\n      this.sorted.resort();\n    }\n  }, {\n    key: \"activeRangeTracker\",\n    value: function activeRangeTracker() {\n      return new RangeTracker(this.sorted.sorted);\n    }\n  }]);\n\n  return RangeStore;\n}();\n\nfunction significant(range) {\n  return range.options.className && range.from != range.to;\n}\n\nvar RangeTracker = function () {\n  function RangeTracker(sorted) {\n    _classCallCheck(this, RangeTracker);\n\n    this.sorted = sorted;\n    this.pos = 0;\n    this.current = [];\n  }\n\n  _createClass(RangeTracker, [{\n    key: \"advanceTo\",\n    value: function advanceTo(pos) {\n      var next = undefined;\n      while (this.pos < this.sorted.length && (next = this.sorted[this.pos]).at <= pos) {\n        if (significant(next.range)) {\n          var className = next.range.options.className;\n          if (next.type == \"open\") this.current.push(className);else this.current.splice(this.current.indexOf(className), 1);\n        }\n        this.pos++;\n      }\n    }\n  }, {\n    key: \"nextChangeBefore\",\n    value: function nextChangeBefore(pos) {\n      for (;;) {\n        if (this.pos == this.sorted.length) return -1;\n        var next = this.sorted[this.pos];\n        if (!significant(next.range)) this.pos++;else if (next.at >= pos) return -1;else return next.at;\n      }\n    }\n  }]);\n\n  return RangeTracker;\n}();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/range.js\n ** module id = 56\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/range.js?");

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EditorTransform = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _model = __webpack_require__(18);\n\nvar _transform = __webpack_require__(38);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// ;; A selection-aware extension of `Transform`. Use\n// `ProseMirror.tr` to create an instance.\n\nvar EditorTransform = exports.EditorTransform = function (_Transform) {\n  _inherits(EditorTransform, _Transform);\n\n  function EditorTransform(pm) {\n    _classCallCheck(this, EditorTransform);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EditorTransform).call(this, pm.doc));\n\n    _this.pm = pm;\n    return _this;\n  }\n\n  // :: (?Object) → ?EditorTransform\n  // Apply the transformation. Returns the transform, or `false` it is\n  // was empty.\n\n\n  _createClass(EditorTransform, [{\n    key: \"apply\",\n    value: function apply(options) {\n      return this.pm.apply(this, options);\n    }\n\n    // :: Selection\n    // Get the editor's current selection, [mapped](#Selection.map)\n    // through the steps in this transform.\n\n  }, {\n    key: \"replaceSelection\",\n\n\n    // :: (?Node, ?bool) → EditorTransform\n    // Replace the selection with the given node, or delete it if `node`\n    // is null. When `inheritMarks` is true and the node is an inline\n    // node, it inherits the marks from the place where it is inserted.\n    value: function replaceSelection(node, inheritMarks) {\n      var _selection = this.selection;\n      var empty = _selection.empty;\n      var from = _selection.from;\n      var to = _selection.to;\n      var selNode = _selection.node;\n\n\n      if (node && node.isInline && inheritMarks !== false) node = node.mark(empty ? this.pm.input.storedMarks : this.doc.marksAt(from));\n\n      if (selNode && selNode.isTextblock && node && node.isInline) {\n        // Putting inline stuff onto a selected textblock puts it\n        // inside, so cut off the sides\n        from++;\n        to--;\n      } else if (selNode) {\n        // This node can not simply be removed/replaced. Remove its parent as well\n        var $from = this.doc.resolve(from),\n            depth = $from.depth;\n        while (depth && $from.node(depth).childCount == 1 && !$from.node(depth).canReplace($from.index(depth - 1), $from.index(depth - 1) + 1, _model.Fragment.from(node))) {\n          depth--;\n        }if (depth < $from.depth) {\n          from = $from.before(depth + 1);\n          to = $from.after(depth + 1);\n        }\n      } else if (node && from == to) {\n        var $from = this.doc.resolve(from);\n        if ($from.parentOffset == 0) {\n          for (var d = $from.depth; d > 0; d--) {\n            if ((d == $from.depth || $from.index(d) == 0) && !$from.node(d).canReplace($from.index(d), $from.index(d), _model.Fragment.from(node))) from = to = $from.before(d);else break;\n          }\n        } else if ($from.parentOffset == $from.parent.content.size) {\n          for (var d = $from.depth; d > 0; d--) {\n            if ((d == $from.depth || $from.index(d) == $from.node(d).childCount - 1) && !$from.node(d).canReplace($from.index(d) + 1, $from.index(d) + 1, _model.Fragment.from(node))) from = to = $from.after(d);else break;\n          }\n        }\n      }\n\n      return this.replaceWith(from, to, node);\n    }\n\n    // :: () → EditorTransform\n    // Delete the selection.\n\n  }, {\n    key: \"deleteSelection\",\n    value: function deleteSelection() {\n      return this.replaceSelection();\n    }\n\n    // :: (string) → EditorTransform\n    // Replace the selection with a text node containing the given string.\n\n  }, {\n    key: \"typeText\",\n    value: function typeText(text) {\n      return this.replaceSelection(this.pm.schema.text(text), true);\n    }\n  }, {\n    key: \"selection\",\n    get: function get() {\n      return this.steps.length ? this.pm.selection.map(this) : this.pm.selection;\n    }\n  }]);\n\n  return EditorTransform;\n}(_transform.Transform);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/transform.js\n ** module id = 57\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/transform.js?");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _model = __webpack_require__(18);\n\nvar _transform = __webpack_require__(38);\n\nvar _command = __webpack_require__(37);\n\nvar _format = __webpack_require__(15);\n\n// # Mark types\n\n// ;; #path=\"strong:set\" #kind=command\n// Add the [strong](#StrongMark) mark to the selected content.\n_model.StrongMark.register(\"command\", \"set\", { derive: true, label: \"Set strong\" });\n\n// ;; #path=\"strong:unset\" #kind=command\n// Remove the [strong](#StrongMark) mark from the selected content.\n_model.StrongMark.register(\"command\", \"unset\", { derive: true, label: \"Unset strong\" });\n\n// ;; #path=\"strong:toggle\" #kind=command\n// Toggle the [strong](#StrongMark) mark. If there is any strong\n// content in the selection, or there is no selection and the [active\n// marks](#ProseMirror.activeMarks) contain the strong mark, this\n// counts as [active](#Command.active) and executing it removes the\n// mark. Otherwise, this does not count as active, and executing it\n// makes the selected content strong.\n//\n// **Keybindings:** Mod-B\n_model.StrongMark.register(\"command\", \"toggle\", {\n  derive: true,\n  label: \"Toggle strong\",\n  menu: {\n    group: \"inline\", rank: 20,\n    display: {\n      type: \"icon\",\n      width: 805, height: 1024,\n      path: \"M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z\"\n    }\n  },\n  keys: [\"Mod-B\"]\n});\n\n// ;; #path=em:set #kind=command\n// Add the [emphasis](#EmMark) mark to the selected content.\n_model.EmMark.register(\"command\", \"set\", { derive: true, label: \"Add emphasis\" });\n\n// ;; #path=em:unset #kind=command\n// Remove the [emphasis](#EmMark) mark from the selected content.\n_model.EmMark.register(\"command\", \"unset\", { derive: true, label: \"Remove emphasis\" });\n\n// ;; #path=em:toggle #kind=command\n// Toggle the [emphasis](#EmMark) mark. If there is any emphasized\n// content in the selection, or there is no selection and the [active\n// marks](#ProseMirror.activeMarks) contain the emphasis mark, this\n// counts as [active](#Command.active) and executing it removes the\n// mark. Otherwise, this does not count as active, and executing it\n// makes the selected content emphasized.\n//\n// **Keybindings:** Mod-I\n_model.EmMark.register(\"command\", \"toggle\", {\n  derive: true,\n  label: \"Toggle emphasis\",\n  menu: {\n    group: \"inline\", rank: 21,\n    display: {\n      type: \"icon\",\n      width: 585, height: 1024,\n      path: \"M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z\"\n    }\n  },\n  keys: [\"Mod-I\"]\n});\n\n// ;; #path=code:set #kind=command\n// Add the [code](#CodeMark) mark to the selected content.\n_model.CodeMark.register(\"command\", \"set\", { derive: true, label: \"Set code style\" });\n\n// ;; #path=code:unset #kind=command\n// Remove the [code](#CodeMark) mark from the selected content.\n_model.CodeMark.register(\"command\", \"unset\", { derive: true, label: \"Remove code style\" });\n\n// ;; #path=code:toggle #kind=command\n// Toggle the [code](#CodeMark) mark. If there is any code-styled\n// content in the selection, or there is no selection and the [active\n// marks](#ProseMirror.activeMarks) contain the code mark, this\n// counts as [active](#Command.active) and executing it removes the\n// mark. Otherwise, this does not count as active, and executing it\n// styles the selected content as code.\n//\n// **Keybindings:** Mod-`\n_model.CodeMark.register(\"command\", \"toggle\", {\n  derive: true,\n  label: \"Toggle code style\",\n  menu: {\n    group: \"inline\", rank: 22,\n    display: {\n      type: \"icon\",\n      width: 896, height: 1024,\n      path: \"M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z\"\n    }\n  },\n  keys: [\"Mod-`\"]\n});\n\nvar linkIcon = {\n  type: \"icon\",\n  width: 951, height: 1024,\n  path: \"M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z\"\n};\n\n// ;; #path=link:unset #kind=command\n// Removes all links for the selected content, or, if there is no\n// selection, from the [active marks](#ProseMirror.activeMarks). Will\n// only [select](#Command.select) itself when there is a link in the\n// selection or active marks.\n_model.LinkMark.register(\"command\", \"unset\", {\n  derive: true,\n  label: \"Unlink\",\n  menu: { group: \"inline\", rank: 30, display: linkIcon },\n  active: function active() {\n    return true;\n  }\n});\n\n// ;; #path=link:set #kind=command\n// Adds a link mark to the selection or set of [active\n// marks](#ProseMirror.activeMarks). Takes parameters to determine the\n// attributes of the link:\n//\n// **`href`**`: string`\n//   : The link's target.\n//\n// **`title`**`: string`\n//   : The link's title.\n//\n// Only selects itself when `unlink` isn't selected, so that only one\n// of the two is visible in the menu at any time.\n_model.LinkMark.register(\"command\", \"set\", {\n  derive: {\n    inverseSelect: true,\n    params: [{ label: \"Target\", attr: \"href\" }, { label: \"Title\", attr: \"title\" }]\n  },\n  label: \"Add link\",\n  menu: { group: \"inline\", rank: 30, display: linkIcon }\n});\n\n// Node types\n\n// ;; #path=image:insert #kind=command\n// Replace the selection with an [image](#Image) node. Takes paramers\n// that specify the image's attributes:\n//\n// **`src`**`: string`\n//   : The URL of the image.\n//\n// **`alt`**`: string`\n//   : The alt text for the image.\n//\n// **`title`**`: string`\n//   : A title for the image.\n_model.Image.register(\"command\", \"insert\", {\n  derive: {\n    params: [{ label: \"Image URL\", attr: \"src\" }, { label: \"Description / alternative text\", attr: \"alt\",\n      prefill: function prefill(pm) {\n        return (0, _command.selectedNodeAttr)(pm, this, \"alt\") || (0, _format.toText)(pm.doc.cut(pm.selection.from, pm.selection.to));\n      } }, { label: \"Title\", attr: \"title\" }]\n  },\n  label: \"Insert image\",\n  menu: {\n    group: \"insert\", rank: 20,\n    display: { type: \"label\", label: \"Image\" }\n  }\n});\n\n// ;; #path=bullet_list:wrap #kind=command\n// Wrap the selection in a bullet list.\n//\n// **Keybindings:** Shift-Ctrl-8\n_model.BulletList.register(\"command\", \"wrap\", {\n  derive: { list: true },\n  label: \"Wrap the selection in a bullet list\",\n  menu: {\n    group: \"block\", rank: 40,\n    display: {\n      type: \"icon\",\n      width: 768, height: 896,\n      path: \"M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z\"\n    }\n  },\n  keys: [\"Shift-Ctrl-8\"]\n});\n\n// ;; #path=ordered_list:wrap #kind=command\n// Wrap the selection in an ordered list.\n//\n// **Keybindings:** Shift-Ctrl-9\n_model.OrderedList.register(\"command\", \"wrap\", {\n  derive: { list: true },\n  label: \"Wrap the selection in an ordered list\",\n  menu: {\n    group: \"block\", rank: 41,\n    display: {\n      type: \"icon\",\n      width: 768, height: 896,\n      path: \"M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z\"\n    }\n  },\n  keys: [\"Shift-Ctrl-9\"]\n});\n\n// ;; #path=blockquote:wrap #kind=command\n// Wrap the selection in a block quote.\n//\n// **Keybindings:** Shift-Ctrl-.\n_model.BlockQuote.register(\"command\", \"wrap\", {\n  derive: true,\n  label: \"Wrap the selection in a block quote\",\n  menu: {\n    group: \"block\", rank: 45,\n    display: {\n      type: \"icon\",\n      width: 640, height: 896,\n      path: \"M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z\"\n    }\n  },\n  keys: [\"Shift-Ctrl-.\"]\n});\n\n// ;; #path=hard_break:insert #kind=command\n// Replace the selection with a hard break node. If the selection is\n// in a node whose [type](#NodeType) has a truthy `isCode` property\n// (such as `CodeBlock` in the default schema), a regular newline is\n// inserted instead.\n//\n// **Keybindings:** Mod-Enter, Shift-Enter\n_model.HardBreak.register(\"command\", \"insert\", {\n  label: \"Insert hard break\",\n  run: function run(pm) {\n    var _pm$selection = pm.selection;\n    var node = _pm$selection.node;\n    var from = _pm$selection.from;\n\n    if (node && node.isBlock) return false;else if (pm.doc.resolve(from).parent.type.isCode) return pm.tr.typeText(\"\\n\").apply(pm.apply.scroll);else return pm.tr.replaceSelection(this.create()).apply(pm.apply.scroll);\n  },\n\n  keys: { all: [\"Mod-Enter\", \"Shift-Enter\"],\n    mac: [\"Ctrl-Enter\"] }\n});\n\n// ;; #path=list_item:split #kind=command\n// If the selection is a text selection inside of a child of a list\n// item, split that child and the list item, and delete the selection.\n//\n// **Keybindings:** Enter\n_model.ListItem.register(\"command\", \"split\", {\n  label: \"Split the current list item\",\n  run: function run(pm) {\n    var _pm$selection2 = pm.selection;\n    var from = _pm$selection2.from;\n    var to = _pm$selection2.to;\n    var node = _pm$selection2.node;var $from = pm.doc.resolve(from);\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent(pm.doc.resolve(to))) return false;\n    var grandParent = $from.node(-1);\n    if (grandParent.type != this) return false;\n    var nextType = to == $from.end() ? grandParent.defaultContentType($from.indexAfter(-1)) : null;\n    var tr = pm.tr.delete(from, to);\n    if ((0, _transform.canSplit)(tr.doc, from, 2, nextType)) return tr.split(from, 2, nextType).apply(pm.apply.scroll);\n    return false;\n  },\n\n  keys: [\"Enter(50)\"]\n});\n\nfunction selectedListItems(pm, type) {\n  var _pm$selection3 = pm.selection;\n  var node = _pm$selection3.node;\n  var from = _pm$selection3.from;\n  var to = _pm$selection3.to;var $from = pm.doc.resolve(from);\n  if (node && node.type == type) return { from: from, to: to, depth: $from.depth + 1 };\n\n  var itemDepth = $from.parent.type == type ? $from.depth : $from.depth > 0 && $from.node(-1).type == type ? $from.depth - 1 : null;\n  if (itemDepth == null) return;\n\n  var $to = pm.doc.resolve(to);\n  if ($from.sameDepth($to) < itemDepth - 1) return null;\n  return { from: $from.before(itemDepth),\n    to: $to.after(itemDepth),\n    depth: itemDepth };\n}\n\n// ;; #path=\"list_item:lift\" #kind=command\n// Lift a list item into a parent list.\n//\n// **Keybindings:** Mod-[\n_model.ListItem.register(\"command\", \"lift\", {\n  label: \"Lift the selected list items to an outer list\",\n  run: function run(pm) {\n    var selected = selectedListItems(pm, this);\n    if (!selected || selected.depth < 3) return false;\n    var $to = pm.doc.resolve(pm.selection.to);\n    if ($to.node(selected.depth - 2).type != this) return false;\n    var itemsAfter = selected.to < $to.end(selected.depth - 1);\n    var tr = pm.tr.lift(selected.from, selected.to);\n    var end = tr.map(selected.to, -1);\n    if (itemsAfter) tr.join(end);\n    return tr.apply(pm.apply.scroll);\n  },\n\n  keys: [\"Mod-[(20)\"]\n});\n\n// ;; #path=\"list_item:sink\" #kind=command\n// Move a list item into a sublist.\n//\n// **Keybindings:** Mod-]\n_model.ListItem.register(\"command\", \"sink\", {\n  label: \"Sink the selected list items into an inner list\",\n  run: function run(pm) {\n    var selected = selectedListItems(pm, this);\n    if (!selected) return false;\n    var $from = pm.doc.resolve(pm.selection.from),\n        startIndex = $from.index(selected.depth - 1);\n    if (startIndex == 0) return false;\n    var parent = $from.node(selected.depth - 1),\n        before = parent.child(startIndex - 1);\n    var tr = pm.tr.wrap(selected.from, selected.to, parent.type, parent.attrs);\n    if (before.type == this) tr.join(selected.from, before.lastChild && before.lastChild.type == parent.type ? 2 : 1);\n    return tr.apply(pm.apply.scroll);\n  },\n\n  keys: [\"Mod-](20)\"]\n});\n\nvar _loop = function _loop(i) {\n  // ;; #path=\"heading:make_\" #kind=command\n  // The commands `make1` to `make6` set the textblocks in the\n  // selection to become headers with the given level.\n  //\n  // **Keybindings:** Shift-Ctrl-1 through Shift-Ctrl-6\n  _model.Heading.registerComputed(\"command\", \"make\" + i, function (type) {\n    var attrs = { level: i };\n    if (i <= type.maxLevel) return {\n      derive: { name: \"make\", attrs: attrs },\n      label: \"Change to heading \" + i,\n      keys: i <= 6 && [\"Shift-Ctrl-\" + i],\n      menu: {\n        group: \"textblockHeading\", rank: 30 + i,\n        display: { type: \"label\", label: \"Level \" + i },\n        activeDisplay: \"Head \" + i\n      }\n    };\n  });\n};\n\nfor (var i = 1; i <= 10; i++) {\n  _loop(i);\n} // ;; #path=paragraph:make #kind=command\n// Set the textblocks in the selection to be regular paragraphs.\n//\n// **Keybindings:** Shift-Ctrl-0\n_model.Paragraph.register(\"command\", \"make\", {\n  derive: true,\n  label: \"Change to paragraph\",\n  keys: [\"Shift-Ctrl-0\"],\n  menu: {\n    group: \"textblock\", rank: 10,\n    display: { type: \"label\", label: \"Plain\" },\n    activeDisplay: \"Plain\"\n  }\n});\n\n// ;; #path=code_block:make #kind=command\n// Set the textblocks in the selection to be code blocks.\n//\n// **Keybindings:** Shift-Ctrl-\\\n_model.CodeBlock.register(\"command\", \"make\", {\n  derive: true,\n  label: \"Change to code block\",\n  keys: [\"Shift-Ctrl-\\\\\"],\n  menu: {\n    group: \"textblock\", rank: 20,\n    display: { type: \"label\", label: \"Code\" },\n    activeDisplay: \"Code\"\n  }\n});\n\n// ;; #path=horizontal_rule:insert #kind=command\n// Replace the selection with a horizontal rule.\n//\n// **Keybindings:** Mod-Shift-Minus\n_model.HorizontalRule.register(\"command\", \"insert\", {\n  derive: true,\n  label: \"Insert horizontal rule\",\n  keys: [\"Mod-Shift--\"],\n  menu: { group: \"insert\", rank: 70, display: { type: \"label\", label: \"Horizontal rule\" } }\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/edit/schema_commands.js\n ** module id = 58\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/edit/schema_commands.js?");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _edit = __webpack_require__(7);\n\nvar _dom = __webpack_require__(10);\n\nvar _update = __webpack_require__(60);\n\nvar _menu = __webpack_require__(61);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar prefix = \"ProseMirror-menubar\";\n\n// :: union<bool, Object> #path=menuBar #kind=option\n//\n// When given a truthy value, enables the menu bar module for this\n// editor. The menu bar takes up space above the editor, showing\n// currently available commands (that have been\n// [added](#CommandSpec.menuGroup) to the menu). To configure the\n// module, you can pass a configuration object, on which the following\n// properties are supported:\n//\n// **`float`**`: bool = false`\n//   : When enabled, causes the menu bar to stay visible when the\n//     editor is partially scrolled out of view, by making it float at\n//     the top of the viewport.\n//\n// **`content`**`: [`[`MenuGroup`](#MenuGroup)`]`\n//   : Determines the content of the menu.\n\n(0, _edit.defineOption)(\"menuBar\", false, function (pm, value) {\n  if (pm.mod.menuBar) pm.mod.menuBar.detach();\n  pm.mod.menuBar = value ? new MenuBar(pm, value) : null;\n});\n\nvar defaultMenu = [_menu.inlineGroup, _menu.insertMenu, [_menu.textblockMenu, _menu.blockGroup], _menu.historyGroup];\n\nvar MenuBar = function () {\n  function MenuBar(pm, config) {\n    var _this = this;\n\n    _classCallCheck(this, MenuBar);\n\n    this.pm = pm;\n    this.config = config || {};\n\n    this.wrapper = pm.wrapper.insertBefore((0, _dom.elt)(\"div\", { class: prefix }), pm.wrapper.firstChild);\n    this.spacer = null;\n    this.maxHeight = 0;\n    this.widthForMaxHeight = 0;\n\n    this.updater = new _update.UpdateScheduler(pm, \"selectionChange change activeMarkChange commandsChanged\", function () {\n      return _this.update();\n    });\n    this.content = config.content || defaultMenu;\n    this.updater.force();\n\n    this.floating = false;\n    if (this.config.float) {\n      this.updateFloat();\n      this.scrollFunc = function () {\n        if (!document.body.contains(_this.pm.wrapper)) window.removeEventListener(\"scroll\", _this.scrollFunc);else _this.updateFloat();\n      };\n      window.addEventListener(\"scroll\", this.scrollFunc);\n    }\n  }\n\n  _createClass(MenuBar, [{\n    key: \"detach\",\n    value: function detach() {\n      this.updater.detach();\n      this.wrapper.parentNode.removeChild(this.wrapper);\n\n      if (this.scrollFunc) window.removeEventListener(\"scroll\", this.scrollFunc);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this2 = this;\n\n      this.wrapper.textContent = \"\";\n      this.wrapper.appendChild((0, _menu.renderGrouped)(this.pm, this.content));\n\n      return this.floating ? this.updateScrollCursor() : function () {\n        if (_this2.wrapper.offsetWidth != _this2.widthForMaxHeight) {\n          _this2.widthForMaxHeight = _this2.wrapper.offsetWidth;\n          _this2.maxHeight = 0;\n        }\n        if (_this2.wrapper.offsetHeight > _this2.maxHeight) {\n          _this2.maxHeight = _this2.wrapper.offsetHeight;\n          return function () {\n            _this2.wrapper.style.minHeight = _this2.maxHeight + \"px\";\n          };\n        }\n      };\n    }\n  }, {\n    key: \"updateFloat\",\n    value: function updateFloat() {\n      var editorRect = this.pm.wrapper.getBoundingClientRect();\n      if (this.floating) {\n        if (editorRect.top >= 0 || editorRect.bottom < this.wrapper.offsetHeight + 10) {\n          this.floating = false;\n          this.wrapper.style.position = this.wrapper.style.left = this.wrapper.style.width = \"\";\n          this.wrapper.style.display = \"\";\n          this.spacer.parentNode.removeChild(this.spacer);\n          this.spacer = null;\n        } else {\n          var border = (this.pm.wrapper.offsetWidth - this.pm.wrapper.clientWidth) / 2;\n          this.wrapper.style.left = editorRect.left + border + \"px\";\n          this.wrapper.style.display = editorRect.top > window.innerHeight ? \"none\" : \"\";\n        }\n      } else {\n        if (editorRect.top < 0 && editorRect.bottom >= this.wrapper.offsetHeight + 10) {\n          this.floating = true;\n          var menuRect = this.wrapper.getBoundingClientRect();\n          this.wrapper.style.left = menuRect.left + \"px\";\n          this.wrapper.style.width = menuRect.width + \"px\";\n          this.wrapper.style.position = \"fixed\";\n          this.spacer = (0, _dom.elt)(\"div\", { class: prefix + \"-spacer\", style: \"height: \" + menuRect.height + \"px\" });\n          this.pm.wrapper.insertBefore(this.spacer, this.wrapper);\n        }\n      }\n    }\n  }, {\n    key: \"updateScrollCursor\",\n    value: function updateScrollCursor() {\n      var _this3 = this;\n\n      if (!this.floating) return null;\n      var head = this.pm.selection.head;\n      if (!head) return null;\n      return function () {\n        var cursorPos = _this3.pm.coordsAtPos(head);\n        var menuRect = _this3.wrapper.getBoundingClientRect();\n        if (cursorPos.top < menuRect.bottom && cursorPos.bottom > menuRect.top) {\n          var _ret = function () {\n            var scrollable = findWrappingScrollable(_this3.pm.wrapper);\n            if (scrollable) return {\n                v: function v() {\n                  scrollable.scrollTop -= menuRect.bottom - cursorPos.top;\n                }\n              };\n          }();\n\n          if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n        }\n      };\n    }\n  }]);\n\n  return MenuBar;\n}();\n\nfunction findWrappingScrollable(node) {\n  for (var cur = node.parentNode; cur; cur = cur.parentNode) {\n    if (cur.scrollHeight > cur.clientHeight) return cur;\n  }\n}\n\n(0, _dom.insertCSS)(\"\\n.\" + prefix + \" {\\n  border-top-left-radius: inherit;\\n  border-top-right-radius: inherit;\\n  position: relative;\\n  min-height: 1em;\\n  color: #666;\\n  padding: 1px 6px;\\n  top: 0; left: 0; right: 0;\\n  border-bottom: 1px solid silver;\\n  background: white;\\n  z-index: 10;\\n  -moz-box-sizing: border-box;\\n  box-sizing: border-box;\\n  overflow: visible;\\n}\\n\");\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/menu/menubar.js\n ** module id = 59\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/menu/menubar.js?");

/***/ },
/* 60 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.scheduleDOMUpdate = scheduleDOMUpdate;\nexports.unscheduleDOMUpdate = unscheduleDOMUpdate;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar UPDATE_TIMEOUT = 50;\nvar MIN_FLUSH_DELAY = 100;\n\nvar CentralScheduler = function () {\n  function CentralScheduler(pm) {\n    var _this = this;\n\n    _classCallCheck(this, CentralScheduler);\n\n    this.waiting = [];\n    this.timeout = null;\n    this.lastForce = 0;\n    this.pm = pm;\n    this.timedOut = function () {\n      if (_this.pm.operation) _this.timeout = setTimeout(_this.timedOut, UPDATE_TIMEOUT);else _this.force();\n    };\n    pm.on(\"flush\", this.onFlush.bind(this));\n  }\n\n  _createClass(CentralScheduler, [{\n    key: \"set\",\n    value: function set(f) {\n      if (this.waiting.length == 0) this.timeout = setTimeout(this.timedOut, UPDATE_TIMEOUT);\n      if (this.waiting.indexOf(f) == -1) this.waiting.push(f);\n    }\n  }, {\n    key: \"unset\",\n    value: function unset(f) {\n      var index = this.waiting.indexOf(f);\n      if (index > -1) this.waiting.splice(index, 1);\n    }\n  }, {\n    key: \"force\",\n    value: function force() {\n      clearTimeout(this.timeout);\n      this.lastForce = Date.now();\n\n      while (this.waiting.length) {\n        for (var i = 0; i < this.waiting.length; i++) {\n          var result = this.waiting[i]();\n          if (result) this.waiting[i] = result;else this.waiting.splice(i--, 1);\n        }\n      }\n    }\n  }, {\n    key: \"onFlush\",\n    value: function onFlush() {\n      if (this.waiting.length && Date.now() - this.lastForce > MIN_FLUSH_DELAY) this.force();\n    }\n  }], [{\n    key: \"get\",\n    value: function get(pm) {\n      return pm.mod.centralScheduler || (pm.mod.centralScheduler = new this(pm));\n    }\n  }]);\n\n  return CentralScheduler;\n}();\n\n// :: (ProseMirror, () -> ?() -> ?())\n// Schedule a DOM update function to be called either the next time\n// the editor is [flushed](#ProseMirror.flush), or if no flush happens\n// immediately, after 200 milliseconds. This is used to synchronize\n// DOM updates and read to prevent [DOM layout\n// thrashing](http://eloquentjavascript.net/13_dom.html#p_nnTb9RktUT).\n//\n// Often, your updates will need to both read and write from the DOM.\n// To schedule such access in lockstep with other modules, the\n// function you give can return another function, which may return\n// another function, and so on. The first call should _write_ to the\n// DOM, and _not read_. If a _read_ needs to happen, that should be\n// done in the function returned from the first call. If that has to\n// be followed by another _write_, that should be done in a function\n// returned from the second function, and so on.\n\n\nfunction scheduleDOMUpdate(pm, f) {\n  CentralScheduler.get(pm).set(f);\n}\n\n// :: (ProseMirror, () -> ?() -> ?())\n// Cancel an update scheduled with `scheduleDOMUpdate`. Calling this with\n// a function that is not actually scheduled is harmless.\nfunction unscheduleDOMUpdate(pm, f) {\n  CentralScheduler.get(pm).unset(f);\n}\n\n// ;; Helper for scheduling updates whenever any of a series of events\n// happen.\n\nvar UpdateScheduler = exports.UpdateScheduler = function () {\n  // :: (ProseMirror, string, () -> ?())\n  // Creates an update scheduler for the given editor. `events` should\n  // be a space-separated list of event names (for example\n  // `\"selectionChange change\"`). `start` should be a function as\n  // expected by `scheduleDOMUpdate`.\n\n  function UpdateScheduler(pm, events, start) {\n    var _this2 = this;\n\n    _classCallCheck(this, UpdateScheduler);\n\n    this.pm = pm;\n    this.start = start;\n\n    this.events = events.split(\" \");\n    this.onEvent = this.onEvent.bind(this);\n    this.events.forEach(function (event) {\n      return pm.on(event, _this2.onEvent);\n    });\n  }\n\n  // :: ()\n  // Detach the event handlers registered by this scheduler.\n\n\n  _createClass(UpdateScheduler, [{\n    key: \"detach\",\n    value: function detach() {\n      var _this3 = this;\n\n      unscheduleDOMUpdate(this.pm, this.start);\n      this.events.forEach(function (event) {\n        return _this3.pm.off(event, _this3.onEvent);\n      });\n    }\n  }, {\n    key: \"onEvent\",\n    value: function onEvent() {\n      scheduleDOMUpdate(this.pm, this.start);\n    }\n\n    // :: ()\n    // Force an update. Note that if the editor has scheduled a flush,\n    // the update is still delayed until the flush occurs.\n\n  }, {\n    key: \"force\",\n    value: function force() {\n      if (this.pm.operation) {\n        this.onEvent();\n      } else {\n        unscheduleDOMUpdate(this.pm, this.start);\n        for (var run = this.start; run; run = run()) {}\n      }\n    }\n  }]);\n\n  return UpdateScheduler;\n}();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/ui/update.js\n ** module id = 60\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/ui/update.js?");

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.historyGroup = exports.blockGroup = exports.textblockMenu = exports.insertMenu = exports.inlineGroup = exports.DropdownSubmenu = exports.Dropdown = exports.MenuCommandGroup = exports.MenuCommand = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.resolveGroup = resolveGroup;\nexports.renderGrouped = renderGrouped;\n\nvar _dom = __webpack_require__(10);\n\nvar _sortedinsert = __webpack_require__(12);\n\nvar _sortedinsert2 = _interopRequireDefault(_sortedinsert);\n\nvar _obj = __webpack_require__(28);\n\nvar _icons = __webpack_require__(62);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// !! This module defines a number of building blocks for ProseMirror\n// menus, as consumed by the [`menubar`](#menu/menubar) and\n// [`tooltipmenu`](#menu/tooltipmenu) modules.\n\n// ;; #path=MenuElement #kind=interface\n// The types defined in this module aren't the only thing you can\n// display in your menu. Anything that conforms to this interface can\n// be put into a menu structure.\n\n// :: (pm: ProseMirror) → ?DOMNode #path=MenuElement.render\n// Render the element for display in the menu. Returning `null` can be\n// used to signal that this element shouldn't be displayed for the\n// given editor state.\n\n// ;; #path=MenuGroup #kind=interface\n// A menu group represents a group of things that may appear in a\n// menu. It may be either a `MenuElement`, a `MenuCommandGroup`, or an\n// array of such values. Can be reduced to an array of `MenuElement`s\n// using `resolveGroup`.\n\nvar prefix = \"ProseMirror-menu\";\n\nfunction title(pm, command) {\n  if (!command.label) return null;\n  var label = pm.translate(command.label);\n  var key = command.name && pm.keyForCommand(command.name);\n  return key ? label + \" (\" + key + \")\" : label;\n}\n\n// ;; Wraps a [command](#Command) so that it can be rendered in a\n// menu.\n\nvar MenuCommand = exports.MenuCommand = function () {\n  // :: (union<Command, string>, MenuCommandSpec)\n\n  function MenuCommand(command, options) {\n    _classCallCheck(this, MenuCommand);\n\n    this.command_ = command;\n    this.options = options;\n  }\n\n  // :: (ProseMirror) → Command\n  // Retrieve the command associated with this object.\n\n\n  _createClass(MenuCommand, [{\n    key: \"command\",\n    value: function command(pm) {\n      return typeof this.command_ == \"string\" ? pm.commands[this.command_] : this.command_;\n    }\n  }, {\n    key: \"render\",\n\n\n    // :: (ProseMirror) → DOMNode\n    // Renders the command according to its [display\n    // spec](#MenuCommandSpec.display), and adds an event handler which\n    // executes the command when the representation is clicked.\n    value: function render(pm) {\n      var cmd = this.command(pm),\n          disabled = false;\n      if (!cmd) return;\n      if (this.options.select != \"ignore\" && !cmd.select(pm)) {\n        if (this.options.select == null || this.options.select == \"hide\") return null;else if (this.options.select == \"disable\") disabled = true;\n      }\n\n      var disp = this.options.display;\n      if (!disp) throw new RangeError(\"No display style defined for menu command \" + cmd.name);\n\n      var dom = undefined;\n      if (disp.render) {\n        dom = disp.render(cmd, pm);\n      } else if (disp.type == \"icon\") {\n        dom = (0, _icons.getIcon)(cmd.name, disp);\n        if (!disabled && cmd.active(pm)) dom.classList.add(prefix + \"-active\");\n      } else if (disp.type == \"label\") {\n        var label = pm.translate(disp.label || cmd.spec.label);\n        dom = (0, _dom.elt)(\"div\", null, label);\n      } else {\n        throw new RangeError(\"Unsupported command display style: \" + disp.type);\n      }\n      dom.setAttribute(\"title\", title(pm, cmd));\n      if (this.options.class) dom.classList.add(this.options.class);\n      if (disabled) dom.classList.add(prefix + \"-disabled\");\n      if (this.options.css) dom.style.cssText += this.options.css;\n      dom.addEventListener(this.options.execEvent || \"mousedown\", function (e) {\n        e.preventDefault();e.stopPropagation();\n        pm.signal(\"interaction\");\n        cmd.exec(pm, null, dom);\n      });\n      dom.setAttribute(\"data-command\", this.commandName);\n      return dom;\n    }\n  }, {\n    key: \"commandName\",\n    get: function get() {\n      return typeof this.command_ === \"string\" ? this.command_.command : this.command_.name;\n    }\n  }]);\n\n  return MenuCommand;\n}();\n\n// ;; Represents a [group](#MenuCommandSpec.group) of commands, as\n// they appear in the editor's schema.\n\n\nvar MenuCommandGroup = exports.MenuCommandGroup = function () {\n  // :: (string, ?MenuCommandSpec)\n  // Create a group for the given group name, optionally adding or\n  // overriding fields in the commands' [specs](#MenuCommandSpec).\n\n  function MenuCommandGroup(name, options) {\n    _classCallCheck(this, MenuCommandGroup);\n\n    this.name = name;\n    this.options = options;\n  }\n\n  _createClass(MenuCommandGroup, [{\n    key: \"collect\",\n    value: function collect(pm) {\n      var _this = this;\n\n      var result = [];\n      for (var name in pm.commands) {\n        var cmd = pm.commands[name],\n            spec = cmd.spec.menu;\n        if (spec && spec.group == this.name) (0, _sortedinsert2.default)(result, { cmd: cmd, rank: spec.rank == null ? 50 : spec.rank }, function (a, b) {\n          return a.rank - b.rank;\n        });\n      }\n      return result.map(function (o) {\n        var spec = o.cmd.spec.menu;\n        if (_this.options) spec = (0, _obj.copyObj)(_this.options, (0, _obj.copyObj)(spec));\n        return new MenuCommand(o.cmd, spec);\n      });\n    }\n\n    // :: (ProseMirror) → [MenuCommand]\n    // Get the group of matching commands in the given editor.\n\n  }, {\n    key: \"get\",\n    value: function get(pm) {\n      var groups = pm.mod.menuGroups || this.startGroups(pm);\n      return groups[this.name] || (groups[this.name] = this.collect(pm));\n    }\n  }, {\n    key: \"startGroups\",\n    value: function startGroups(pm) {\n      var clear = function clear() {\n        pm.mod.menuGroups = null;\n        pm.off(\"commandsChanging\", clear);\n      };\n      pm.on(\"commandsChanging\", clear);\n      return pm.mod.menuGroups = Object.create(null);\n    }\n  }]);\n\n  return MenuCommandGroup;\n}();\n\n// ;; A drop-down menu, displayed as a label with a downwards-pointing\n// triangle to the right of it.\n\n\nvar Dropdown = exports.Dropdown = function () {\n  // :: (Object, MenuGroup)\n  // Create a dropdown wrapping the given group. Options may include\n  // the following properties:\n  //\n  // **`label`**`: string`\n  //   : The label to show on the drop-down control. When\n  //     `activeLabel` is also given, this one is used as a\n  //     fallback.\n  //\n  // **`activeLabel`**`: bool`\n  //   : Instead of showing a fixed label, enabling this causes the\n  //     element to search through its content, looking for an\n  //     [active](#CommandSpec.active) command. If one is found, its\n  //     [`activeLabel`](#MenuCommandSpec.activeLabel) property is\n  //     shown as the drop-down's label.\n  //\n  // **`title`**`: string`\n  //   : Sets the\n  //     [`title`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/title)\n  //     attribute given to the menu control.\n  //\n  // **`class`**`: string`\n  //   : When given, adds an extra CSS class to the menu control.\n\n  function Dropdown(options, content) {\n    _classCallCheck(this, Dropdown);\n\n    this.options = options || {};\n    this.content = content;\n  }\n\n  // :: (ProseMirror) → DOMNode\n  // Returns a node showing the collapsed menu, which expands when clicked.\n\n\n  _createClass(Dropdown, [{\n    key: \"render\",\n    value: function render(pm) {\n      var _this2 = this;\n\n      var items = renderDropdownItems(resolveGroup(pm, this.content), pm);\n      if (!items.length) return;\n\n      var label = this.options.activeLabel && this.findActiveIn(this, pm) || this.options.label;\n      label = pm.translate(label);\n      var dom = (0, _dom.elt)(\"div\", { class: prefix + \"-dropdown \" + (this.options.class || \"\"),\n        style: this.options.css,\n        title: this.options.title }, label);\n      var open = null;\n      dom.addEventListener(\"mousedown\", function (e) {\n        e.preventDefault();e.stopPropagation();\n        if (open && open()) open = null;else open = _this2.expand(pm, dom, items);\n      });\n      return dom;\n    }\n  }, {\n    key: \"select\",\n    value: function select(pm) {\n      return resolveGroup(pm, this.content).some(function (e) {\n        return e.select(pm);\n      });\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(pm, dom, items) {\n      var box = dom.getBoundingClientRect(),\n          outer = pm.wrapper.getBoundingClientRect();\n      var menuDOM = (0, _dom.elt)(\"div\", { class: prefix + \"-dropdown-menu \" + (this.options.class || \"\"),\n        style: \"left: \" + (box.left - outer.left) + \"px; top: \" + (box.bottom - outer.top) + \"px\" }, items);\n\n      var done = false;\n      function finish() {\n        if (done) return;\n        done = true;\n        pm.off(\"interaction\", finish);\n        pm.wrapper.removeChild(menuDOM);\n        return true;\n      }\n      pm.signal(\"interaction\");\n      pm.wrapper.appendChild(menuDOM);\n      pm.on(\"interaction\", finish);\n      return finish;\n    }\n  }, {\n    key: \"findActiveIn\",\n    value: function findActiveIn(element, pm) {\n      var items = resolveGroup(pm, element.content);\n      for (var i = 0; i < items.length; i++) {\n        var cur = items[i];\n        if (cur instanceof MenuCommand) {\n          var active = cur.command(pm).active(pm);\n          if (active) return cur.options.activeLabel;\n        } else if (cur instanceof DropdownSubmenu) {\n          var found = this.findActiveIn(cur, pm);\n          if (found) return found;\n        }\n      }\n    }\n  }]);\n\n  return Dropdown;\n}();\n\nfunction renderDropdownItems(items, pm) {\n  var rendered = [];\n  for (var i = 0; i < items.length; i++) {\n    var inner = items[i].render(pm);\n    if (inner) rendered.push((0, _dom.elt)(\"div\", { class: prefix + \"-dropdown-item\" }, inner));\n  }\n  return rendered;\n}\n\n// ;; Represents a submenu wrapping a group of items that start hidden\n// and expand to the right when hovered over or tapped.\n\nvar DropdownSubmenu = exports.DropdownSubmenu = function () {\n  // :: (Object, MenuGroup)\n  // Creates a submenu for the given group of menu elements. The\n  // following options are recognized:\n  //\n  // **`label`**`: string`\n  //   : The label to show on the submenu.\n\n  function DropdownSubmenu(options, content) {\n    _classCallCheck(this, DropdownSubmenu);\n\n    this.options = options || {};\n    this.content = content;\n  }\n\n  // :: (ProseMirror) → DOMNode\n  // Renders the submenu.\n\n\n  _createClass(DropdownSubmenu, [{\n    key: \"render\",\n    value: function render(pm) {\n      var items = renderDropdownItems(resolveGroup(pm, this.content), pm);\n      if (!items.length) return;\n\n      var label = (0, _dom.elt)(\"div\", { class: prefix + \"-submenu-label\" }, pm.translate(this.options.label));\n      var wrap = (0, _dom.elt)(\"div\", { class: prefix + \"-submenu-wrap\" }, label, (0, _dom.elt)(\"div\", { class: prefix + \"-submenu\" }, items));\n      label.addEventListener(\"mousedown\", function (e) {\n        e.preventDefault();e.stopPropagation();\n        wrap.classList.toggle(prefix + \"-submenu-wrap-active\");\n      });\n      return wrap;\n    }\n  }]);\n\n  return DropdownSubmenu;\n}();\n\n// :: (ProseMirror, MenuGroup) → [MenuElement]\n// Resolve the given `MenuGroup` into a flat array of renderable\n// elements.\n\n\nfunction resolveGroup(pm, content) {\n  var result = undefined,\n      isArray = Array.isArray(content);\n  for (var i = 0; i < (isArray ? content.length : 1); i++) {\n    var cur = isArray ? content[i] : content;\n    if (cur instanceof MenuCommandGroup) {\n      var elts = cur.get(pm);\n      if (!isArray || content.length == 1) return elts;else result = (result || content.slice(0, i)).concat(elts);\n    } else if (result) {\n      result.push(cur);\n    }\n  }\n  return result || (isArray ? content : [content]);\n}\n\n// :: (ProseMirror, [MenuGroup]) → ?DOMFragment\n// Render the given menu groups into a document fragment, placing\n// separators between them (and ensuring no superfluous separators\n// appear when some of the groups turn out to be empty).\nfunction renderGrouped(pm, content) {\n  var result = document.createDocumentFragment(),\n      needSep = false;\n  for (var i = 0; i < content.length; i++) {\n    var items = resolveGroup(pm, content[i]),\n        added = false;\n    for (var j = 0; j < items.length; j++) {\n      var rendered = items[j].render(pm);\n      if (rendered) {\n        if (!added && needSep) result.appendChild(separator());\n        result.appendChild((0, _dom.elt)(\"span\", { class: prefix + \"item\" }, rendered));\n        added = true;\n      }\n    }\n    if (added) needSep = true;\n  }\n  return result;\n}\n\nfunction separator() {\n  return (0, _dom.elt)(\"span\", { class: prefix + \"separator\" });\n}\n\n// ;; #path=CommandSpec #kind=interface #noAnchor\n// The `menu` module gives meaning to an additional property in\n// [command specs](#CommandSpec).\n\n// :: MenuCommandSpec #path=CommandSpec.menu\n// Adds the command to a menu group, so that it is picked up by\n// `MenuCommandGroup` objects with the matching\n// [name](#MenuCommandSpec.name).\n\n// ;; #path=MenuCommandSpec #kind=interface\n// Configures the way a command shows up in a menu, when wrapped in a\n// `MenuCommand`.\n\n// :: string #path=MenuCommandSpec.group\n// Identifies the group this command should be added to (for example\n// `\"inline\"` or `\"block\"`). Only meaningful when associated with a\n// `CommandSpec` (as opposed to passed directly to `MenuCommand`).\n\n// :: number #path=MenuCommandSpec.rank\n// Determines the command's position in its group (lower ranks come\n// first). Only meaningful in a `CommandSpec`.\n\n// :: Object #path=MenuCommandSpec.display\n// Determines how the command is shown in the menu. It may have either\n// a `type` property containing one of the strings shown below, or a\n// `render` property that, when called with the command and a\n// `ProseMirror` instance as arguments, returns a DOM node\n// representing the command's menu representation.\n//\n// **`\"icon\"`**\n//   : Show the command as an icon. The object may have `{path, width,\n//     height}` properties, where `path` is an [SVG path\n//     spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),\n//     and `width` and `height` provide the viewbox in which that path\n//     exists. Alternatively, it may have a `text` property specifying\n//     a string of text that makes up the icon, with an optional\n//     `style` property giving additional CSS styling for the text,\n//     _or_ a `dom` property containing a DOM node.\n//\n// **`\"label\"`**\n//   : Render the command as a label. Mostly useful for commands\n//     wrapped in a [drop-down](#Dropdown) or similar menu. The object\n//     should have a `label` property providing the text to display.\n\n// :: string #path=MenuCommandSpec.activeLabel\n// When used in a `Dropdown` with `activeLabel` enabled, this should\n// provide the text shown when the command is active.\n\n// :: string #path=MenuCommandSpec.select\n// Controls whether the command's [`select`](#CommandSpec.select)\n// method has influence on its appearance. When set to `\"hide\"`, or\n// not given, the command is hidden when it is not selectable. When\n// set to `\"ignore\"`, the `select` method is not called. When set to\n// `\"disable\"`, the command is shown in disabled form when `select`\n// returns false.\n\n// :: string #path=MenuCommandSpec.class\n// Optionally adds a CSS class to the command's DOM representation.\n\n// :: string #path=MenuCommandSpec.css\n// Optionally adds a string of inline CSS to the command's DOM\n// representation.\n\n// :: string #path=MenuCommandSpec.execEvent\n// Defines which event on the command's DOM representation should\n// trigger the execution of the command. Defaults to mousedown.\n\n// :: MenuCommandGroup\n// The inline command group.\nvar inlineGroup = exports.inlineGroup = new MenuCommandGroup(\"inline\");\n\n// :: Dropdown\n// The default insert dropdown menu.\nvar insertMenu = exports.insertMenu = new Dropdown({ label: \"Insert\" }, new MenuCommandGroup(\"insert\"));\n\n// :: Dropdown\n// The default textblock type menu.\nvar textblockMenu = exports.textblockMenu = new Dropdown({ label: \"Type..\", displayActive: true, class: \"ProseMirror-textblock-dropdown\" }, [new MenuCommandGroup(\"textblock\"), new DropdownSubmenu({ label: \"Heading\" }, new MenuCommandGroup(\"textblockHeading\"))]);\n\n// :: MenuCommandGroup\n// The block command group.\nvar blockGroup = exports.blockGroup = new MenuCommandGroup(\"block\");\n\n// :: MenuCommandGroup\n// The history command group.\nvar historyGroup = exports.historyGroup = new MenuCommandGroup(\"history\");\n\n(0, _dom.insertCSS)(\"\\n\\n.ProseMirror-textblock-dropdown {\\n  min-width: 3em;\\n}\\n\\n.\" + prefix + \" {\\n  margin: 0 -4px;\\n  line-height: 1;\\n}\\n\\n.ProseMirror-tooltip .\" + prefix + \" {\\n  width: -webkit-fit-content;\\n  width: fit-content;\\n  white-space: pre;\\n}\\n\\n.\" + prefix + \"item {\\n  margin-right: 3px;\\n  display: inline-block;\\n}\\n\\n.\" + prefix + \"separator {\\n  border-right: 1px solid #ddd;\\n  margin-right: 3px;\\n}\\n\\n.\" + prefix + \"-dropdown, .\" + prefix + \"-dropdown-menu {\\n  font-size: 90%;\\n  white-space: nowrap;\\n}\\n\\n.\" + prefix + \"-dropdown {\\n  padding: 1px 14px 1px 4px;\\n  display: inline-block;\\n  vertical-align: 1px;\\n  position: relative;\\n  cursor: pointer;\\n}\\n\\n.\" + prefix + \"-dropdown:after {\\n  content: \\\"\\\";\\n  border-left: 4px solid transparent;\\n  border-right: 4px solid transparent;\\n  border-top: 4px solid currentColor;\\n  opacity: .6;\\n  position: absolute;\\n  right: 2px;\\n  top: calc(50% - 2px);\\n}\\n\\n.\" + prefix + \"-dropdown-menu, .\" + prefix + \"-submenu {\\n  position: absolute;\\n  background: white;\\n  color: #666;\\n  border: 1px solid #aaa;\\n  padding: 2px;\\n}\\n\\n.\" + prefix + \"-dropdown-menu {\\n  z-index: 15;\\n  min-width: 6em;\\n}\\n\\n.\" + prefix + \"-dropdown-item {\\n  cursor: pointer;\\n  padding: 2px 8px 2px 4px;\\n}\\n\\n.\" + prefix + \"-dropdown-item:hover {\\n  background: #f2f2f2;\\n}\\n\\n.\" + prefix + \"-submenu-wrap {\\n  position: relative;\\n  margin-right: -4px;\\n}\\n\\n.\" + prefix + \"-submenu-label:after {\\n  content: \\\"\\\";\\n  border-top: 4px solid transparent;\\n  border-bottom: 4px solid transparent;\\n  border-left: 4px solid currentColor;\\n  opacity: .6;\\n  position: absolute;\\n  right: 4px;\\n  top: calc(50% - 4px);\\n}\\n\\n.\" + prefix + \"-submenu {\\n  display: none;\\n  min-width: 4em;\\n  left: 100%;\\n  top: -3px;\\n}\\n\\n.\" + prefix + \"-active {\\n  background: #eee;\\n  border-radius: 4px;\\n}\\n\\n.\" + prefix + \"-active {\\n  background: #eee;\\n  border-radius: 4px;\\n}\\n\\n.\" + prefix + \"-disabled {\\n  opacity: .3;\\n}\\n\\n.\" + prefix + \"-submenu-wrap:hover .\" + prefix + \"-submenu, .\" + prefix + \"-submenu-wrap-active .\" + prefix + \"-submenu {\\n  display: block;\\n}\\n\");\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/menu/menu.js\n ** module id = 61\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/menu/menu.js?");

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIcon = getIcon;\n\nvar _dom = __webpack_require__(10);\n\nvar svgCollection = null;\nvar svgBuilt = Object.create(null);\n\nvar SVG = \"http://www.w3.org/2000/svg\";\nvar XLINK = \"http://www.w3.org/1999/xlink\";\n\nvar prefix = \"ProseMirror-icon\";\n\nfunction getIcon(name, data) {\n  var node = document.createElement(\"div\");\n  node.className = prefix;\n  if (data.path) {\n    if (!svgBuilt[name]) buildSVG(name, data);\n    var svg = node.appendChild(document.createElementNS(SVG, \"svg\"));\n    svg.style.width = data.width / data.height + \"em\";\n    var use = svg.appendChild(document.createElementNS(SVG, \"use\"));\n    use.setAttributeNS(XLINK, \"href\", /([^#]*)/.exec(document.location)[1] + \"#pm-icon-\" + name);\n  } else if (data.dom) {\n    node.appendChild(data.dom.cloneNode(true));\n  } else {\n    node.appendChild(document.createElement(\"span\")).textContent = data.text || '';\n    if (data.style) node.firstChild.style.cssText = data.style;\n  }\n  return node;\n}\n\nfunction buildSVG(name, data) {\n  if (!svgCollection) {\n    svgCollection = document.createElementNS(SVG, \"svg\");\n    svgCollection.style.display = \"none\";\n    document.body.insertBefore(svgCollection, document.body.firstChild);\n  }\n  var sym = document.createElementNS(SVG, \"symbol\");\n  sym.id = \"pm-icon-\" + name;\n  sym.setAttribute(\"viewBox\", \"0 0 \" + data.width + \" \" + data.height);\n  var path = sym.appendChild(document.createElementNS(SVG, \"path\"));\n  path.setAttribute(\"d\", data.path);\n  svgCollection.appendChild(sym);\n  svgBuilt[name] = true;\n}\n\n(0, _dom.insertCSS)(\"\\n.\" + prefix + \" {\\n  display: inline-block;\\n  line-height: .8;\\n  vertical-align: -2px; /* Compensate for padding */\\n  padding: 2px 8px;\\n  cursor: pointer;\\n}\\n\\n.\" + prefix + \" svg {\\n  fill: currentColor;\\n  height: 1em;\\n}\\n\\n.\" + prefix + \" span {\\n  vertical-align: text-top;\\n}\");\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/prosemirror/dist/menu/icons.js\n ** module id = 62\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/prosemirror/dist/menu/icons.js?");

/***/ }
/******/ ]);